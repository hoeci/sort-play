(async function () {
  async function main() {
  const { React, ReactDOM, URI, GraphQL, Platform } = Spicetify;
  if (!React || !ReactDOM || !GraphQL || !Platform) {
    setTimeout(main, 10);
    return;
  }
  const { PlaylistAPI } = Platform;

  if (!PlaylistAPI || typeof PlaylistAPI.getContents !== 'function') {
    setTimeout(main, 50);
    return;
  }

  const SORT_PLAY_VERSION = "5.44.0";

  const SCHEDULER_INTERVAL_MINUTES = 10;
  const RANDOM_GENRE_HISTORY_SIZE = 200;
  const RANDOM_GENRE_SELECTION_SIZE = 20;
  const spotifyApiLimits = { maxRequestsPerSecond: 20, requests: [] };
  const STORAGE_KEY_SHOW_GENRE_TAGS = "sort-play-show-genre-tags";
  const STORAGE_KEY_SHOW_GENRE_TAGS_NP = "sort-play-show-genre-tags-np";
  const STORAGE_KEY_SHOW_GENRE_TAGS_AP = "sort-play-show-genre-tags-ap";
  const STORAGE_KEY_GENRE_SOURCES_NP_SPOTIFY = "sort-play-genre-sources-np-spotify";
  const STORAGE_KEY_GENRE_SOURCES_NP_LASTFM = "sort-play-genre-sources-np-lastfm";
  const STORAGE_KEY_GENRE_SOURCES_NP_DEEZER = "sort-play-genre-sources-np-deezer";
  const STORAGE_KEY_GENRE_SOURCES_AP_SPOTIFY = "sort-play-genre-sources-ap-spotify";
  const STORAGE_KEY_GENRE_SOURCES_AP_LASTFM = "sort-play-genre-sources-ap-lastfm";
  const STORAGE_KEY_USE_GENRE_PLAYLIST_DATABASE = "sort-play-use-genre-playlist-database";
  const STORAGE_KEY_CHAT_PANEL_VISIBLE = "sort-play-chat-panel-visible";
  const STORAGE_KEY_LASTFM_USERNAME = "sort-play-lastfm-username";
  const STORAGE_KEY_GENRE_FILTER_SORT = "sort-play-genre-filter-sort";
  const STORAGE_KEY_USER_SYSTEM_INSTRUCTION_v2 = "sort-play-user-system-instruction-v2";
  const STORAGE_KEY_ADD_TO_QUEUE = "sort-play-add-to-queue";
  const STORAGE_KEY_CREATE_PLAYLIST = "sort-play-create-playlist";
  const STORAGE_KEY_SORT_CURRENT_PLAYLIST = "sort-play-sort-current-playlist";
  const STORAGE_KEY_CREATE_PLAYLIST_PRIVATE = "sort-play-create-playlist-private";
  const STORAGE_KEY_OPEN_PLAYLIST_AFTER_SORT = "sort-play-open-playlist-after-sort-v2";
  const STORAGE_KEY_PLACE_PLAYLISTS_IN_FOLDER = "sort-play-place-playlists-in-folder";
  const STORAGE_KEY_SORT_PLAY_FOLDER_NAME = "sort-play-folder-name";
  const STORAGE_KEY_CHANGE_TITLE_ON_CREATE = "sort-play-change-title-on-create";
  const STORAGE_KEY_CHANGE_TITLE_ON_MODIFY = "sort-play-change-title-on-modify";
  const STORAGE_KEY_DEDICATED_PLAYLIST_BEHAVIOR = "sort-play-dedicated-playlist-behavior";
  const STORAGE_KEY_DEDICATED_PLAYLIST_MAP = "sort-play-dedicated-playlist-map";
  const STORAGE_KEY_COLOR_SORT_MODE = "sort-play-color-sort-mode";
  const STORAGE_KEY_TOP_TRACKS_LIMIT = "sort-play-top-tracks-limit";
  const STORAGE_KEY_NEW_RELEASES_LIMIT = "sort-play-new-releases-limit";
  const STORAGE_KEY_FOLLOWED_RELEASES_LIMIT = "sort-play-followed-releases-limit";
  const STORAGE_KEY_DISCOVERY_PLAYLIST_SIZE = "sort-play-discovery-playlist-size";
  const STORAGE_KEY_SET_DEDICATED_PLAYLIST_COVERS = "sort-play-set-dedicated-playlist-covers";
  const STORAGE_KEY_DYNAMIC_PLAYLIST_JOBS = "sort-play-dynamic-playlist-jobs";
  const STORAGE_KEY_DYNAMIC_PLAYLIST_CUSTOM_SCHEDULES = "sort-play-dynamic-playlist-custom-schedules";
  const STORAGE_KEY_DEDICATED_PLAYLIST_JOBS = "sort-play-dedicated-playlist-jobs";
  const STORAGE_KEY_DYNAMIC_SORT_TYPE = "sort-play-dynamic-sort-type";
  const STORAGE_KEY_DYNAMIC_SCHEDULE = "sort-play-dynamic-schedule";
  const STORAGE_KEY_DYNAMIC_UPDATE_SOURCE = "sort-play-dynamic-update-source";
  const STORAGE_KEY_USER_ADDED_GENRES = "sort-play-user-added-genres";
  const STORAGE_KEY_RANDOM_GENRE_HISTORY = "sort-play-random-genre-history";
  const STORAGE_KEY_USE_ENERGY_WAVE_SHUFFLE = "sort-play-use-energy-wave-shuffle";
  const STORAGE_KEY_ENERGY_WAVE_SHUFFLE_LIMIT = "sort-play-energy-wave-shuffle-limit";
  const STORAGE_KEY_SHOW_NOW_PLAYING_DATA = "sort-play-show-now-playing-data";
  const STORAGE_KEY_NOW_PLAYING_DATA_TYPE = "sort-play-now-playing-data-type";
  const STORAGE_KEY_NOW_PLAYING_DATA_POSITION = "sort-play-now-playing-data-position";
  const STORAGE_KEY_NOW_PLAYING_DATA_FORMAT = "sort-play-now-playing-data-format";
  const STORAGE_KEY_NOW_PLAYING_PLAY_COUNT_FORMAT = "sort-play-now-playing-play-count-format";
  const STORAGE_KEY_NOW_PLAYING_TEMPO_FORMAT = "sort-play-now-playing-tempo-format";
  const STORAGE_KEY_NOW_PLAYING_ENERGY_FORMAT = "sort-play-now-playing-energy-format";
  const STORAGE_KEY_NOW_PLAYING_DANCEABILITY_FORMAT = "sort-play-now-playing-danceability-format";
  const STORAGE_KEY_NOW_PLAYING_VALENCE_FORMAT = "sort-play-now-playing-valence-format";
  const STORAGE_KEY_NOW_PLAYING_KEY_FORMAT = "sort-play-now-playing-key-format";
  const STORAGE_KEY_NOW_PLAYING_POPULARITY_FORMAT = "sort-play-now-playing-popularity-format";
  const STORAGE_KEY_NOW_PLAYING_SEPARATOR = "sort-play-now-playing-separator";
  const STORAGE_KEY_GLOBAL_PLAYLIST_COUNTS = "sort-play-global-playlist-counts";
  const STORAGE_KEY_FALLBACK_MODE = "sort-play-use-internal-fallback";
  const STORAGE_KEY_WEB_API_FAILURES = "sort-play-web-api-failures";
  let showAdditionalColumn = false;
  let showSecondAdditionalColumn = false;
  let selectedColumnType = 'playCount';
  let selectedSecondColumnType = 'releaseDate';
  let selectedAlbumColumnType = 'scrobbles';
  let selectedArtistColumnType = 'releaseDate';
  let myScrobblesDisplayMode = 'number';
  let releaseDateFormat = 'YYYY-MM-DD';
  let showAlbumColumn = false;
  let showArtistColumn = false; 
  let removeDateAdded = false;
  let playlistDeduplicate = false;
  let showRemovedDuplicates = false;
  let addToQueueEnabled = false; 
  let createPlaylistAfterSort = true; 
  let sortCurrentPlaylistEnabled = false;
  let createPlaylistPrivate = true;
  let openPlaylistAfterSortEnabled = false;
  let placePlaylistsInFolder = false;
  let sortPlayFolderName = "Sort-Play Library";
  let changeTitleOnCreate = false;
  let changeTitleOnModify = false;
  let setDedicatedPlaylistCovers = true;
  let selectedAiModel = "gemini-flash-latest";
  let topTracksLimit = 100;
  let discoveryPlaylistSize = 50;
  let newReleasesDaysLimit = 'release-2';
  let followedReleasesAlbumLimit = 'all';
  let colorSortMode = 'perceptual';
  let useEnergyWaveShuffle = false;
  let energyWaveShuffleLimit = 6000;
  let includeSongStats = true;
  let includeLyrics = false;
  let useLfmGateway = false;
  let includeZeroScrobbles = true;
  let lastFmAutocorrect = false;
  let chatPanelVisible = false;
  let showLikeButton = false;
  let showNowPlayingData = false;
  let selectedNowPlayingDataType = 'releaseDate';
  let selectedNowPlayingDataPosition = '.main-trackInfo-name';
  let selectedNowPlayingDateFormat = 'YYYY';
  let selectedNowPlayingPlayCountFormat = 'raw';
  let selectedNowPlayingTempoFormat = 'with_unit';
  let selectedNowPlayingEnergyFormat = 'percentage';
  let selectedNowPlayingDanceabilityFormat = 'percentage';
  let selectedNowPlayingValenceFormat = 'percentage';
  let selectedNowPlayingKeyFormat = 'standard';
  let selectedNowPlayingPopularityFormat = 'raw';
  let selectedNowPlayingSeparator = 'â€¢';
  let showGenreTags = false;
  let showGenreTagsNowPlaying = true;
  let showGenreTagsArtistPage = true;
  let matchAllGenres  = false;
  let useGenrePlaylistDatabase = true;
  let genreSourcesNpSpotify = true;
  let genreSourcesNpLastfm = true;
  let genreSourcesNpDeezer = true;
  let genreSourcesApSpotify = true;
  let genreSourcesApLastfm = true;
  let isProcessing = false;
  let isMenuOpen = false;
  let areSubMenusCreated = false;
  let activeSubMenuParent = null;
  let isButtonClicked = false;
  let isAdjustingStyle = false;
  let isUpdatingTracklist = false;
  let internalTokenRefreshPromise = null;
  let userMarketPromise = null;
  let s_Access_Token = null;
  let s_Token_Exp = 0;
  let lfmKeyIndex = 0;
  let googleAiSdk = null;
  let colorThiefLib = null;
  let genrePlaylistsCache = null;
  let userSystemInstruction;
  let currentTrackUriForScrobbleCache = null;
  let tracklistObserver;
  let albumTracklistObserver;
  let artistTracklistObserver;
  let likeButton_tracklistObserver;
  let likeButton_observerInitialized = false;
  let likeButton_connectObserver = () => {};
  let updateDebounceTimeout;
  let mountLikeButton_debounceTimer = null;
  let mountLikeButton_isRunning = false;
  let mountLikeButton_failedAttempts = 0;
  const revokedLfmKeys = new Set();
  const runningJobIds = new Set();
  const artistGenreCache = new Map();
  const lastfmCache = new Map();
  const lastfmArtistTagsCache = new Map();
  const lastfmTrackTagsCache = new Map();
  const sessionGenreCache = new Map();
  const nowPlayingGenreCache = new Map();
  const artistPageGenreCache = new Map();
  const pendingGenreFetches = new Map();
  const pendingArtistPageFetches = new Map();
  const albumDataCache = {};
  const albumReleaseDateCache = {};
  const albumTracksDataCache = {};
  const inFlightAlbumRequests = {};
  const inFlightAlbumReleaseDateRequests = {};
  const VARIANT_TO_MAIN_GENRE_MAP = {};
  const VARIANT_TO_MAIN_COUNTRY_MAP = {};

  const CACHE_EXPIRE_PLAYCOUNTS = 6 * 60 * 60 * 1000; 
  const CACHE_EXPIRE_PERSONAL_SCROBBLES = 30 * 60 * 1000;
  const CACHE_EXPIRE_GLOBAL_SCROBBLES = 2 * 24 * 60 * 60 * 1000; 
  const CACHE_EXPIRE_RELEASE_DATE = null;
  const CACHE_EXPIRE_AI_DATA = null;
  const CACHE_EXPIRE_PALETTE = null;
  const CACHE_EXPIRE_METADATA = 24 * 60 * 60 * 1000; 

  const LFM_GATEWAY_URL = "https://gateway.niko2nio2.workers.dev/?url=";
  const TURSO_GATEWAY_URL = "https://turso-genre-proxy.niko2nio2.workers.dev";
  const DEEZER_GATEWAY_URL = "https://deezer-proxy.hunqo.workers.dev/?url=";
  const DEEZER_GATEWAY_URL_2 = "https://deezer-proxy-2.hoeci.workers.dev/?url=";
  const DEEZER_GATEWAY_URL_3 = "https://deezer-proxy-3.spaceman-0e6.workers.dev/?url=";
  const STATS_URL = "https://sp-stats.niko2nio2.workers.dev";
  const TOKEN_SP_PROXY_URL = "https://sp-token-proxy.niko2nio2.workers.dev"; 

  async function get_S_Client_Token() {
      if (s_Access_Token && Date.now() < s_Token_Exp) {
          return s_Access_Token;
      }

      try {
          const response = await fetch(TOKEN_SP_PROXY_URL);

          if (!response.ok) {
              console.error("[Sort-Play] Token Proxy failed:", response.status);
              return null;
          }

          const data = await response.json();
          if (data.access_token) {
              s_Access_Token = data.access_token;
              s_Token_Exp = Date.now() + (data.expires_in * 1000) - 60000;
              return s_Access_Token;
          } else {
              console.error("[Sort-Play] Invalid response from Token Proxy");
              return null;
          }

      } catch (e) {
          console.error("[Sort-Play] Network error contacting Token Proxy:", e);
          return null;
      }
  }
  function spotifyHex(base62) {
    const INVALID = "00000000000000000000000000000000";
    if (!base62 || base62.length > 22) return INVALID;
    const chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let val = BigInt(0);
    for (let i = 0; i < base62.length; i++) {
        const idx = chars.indexOf(base62[i]);
        if (idx === -1) return INVALID;
        val = val * BigInt(62) + BigInt(idx);
    }
    return val.toString(16).padStart(32, "0");
  }

  const hexToBase62 = (hex) => {
    const alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let val = BigInt("0x" + hex);
    let base62 = "";
    while (val > 0n) {
        base62 = alphabet[Number(val % 62n)] + base62;
        val /= 62n;
    }
    return base62.padStart(22, "0");
  };
  
  const MANUAL_FALLBACK_OVERRIDE = true;

  function isFallbackActive() {
      if (MANUAL_FALLBACK_OVERRIDE) return true;

      const fallbackTs = localStorage.getItem(STORAGE_KEY_FALLBACK_MODE);
      if (fallbackTs && (Date.now() - parseInt(fallbackTs)) < 24 * 60 * 60 * 1000) {
          return true;
      }
      return false;
  }

  function registerWebApiFailure() {
      let count = parseInt(localStorage.getItem(STORAGE_KEY_WEB_API_FAILURES) || "0");
      count++;
      localStorage.setItem(STORAGE_KEY_WEB_API_FAILURES, count);
      if (count >= 5) {
          localStorage.setItem(STORAGE_KEY_FALLBACK_MODE, Date.now().toString());
          console.warn("[Sort-Play] Web API unstable. Switched to Internal Fallback mode for 24h.");
          return true;
      }
      return false;
  }

  async function fetchInternalTrackMetadata(trackId) {
      const maxRetries = 3;
      let attempt = 0;

      while (attempt < maxRetries) {
          try {
              if (internalTokenRefreshPromise) {
                  await internalTokenRefreshPromise;
              }

              const hexId = spotifyHex(trackId);
              
              const currentToken = Spicetify.Platform.Session.accessToken;
              
              const url = `https://spclient.wg.spotify.com/metadata/4/track/${hexId}?market=from_token&alt=json`;
              
              const response = await fetch(url, {
                  headers: {
                      "Authorization": `Bearer ${currentToken}`,
                      "Accept": "application/json"
                  }
              });
              
              if (response.status === 401) {
                  if (!internalTokenRefreshPromise) {
                      console.warn(`[Sort-Play] Token 401. Starting Refresh...`);
                      
                      internalTokenRefreshPromise = (async () => {
                          try {
                              const tokenData = await Spicetify.CosmosAsync.get('sp://auth/v2/token');
                              const newToken = tokenData.accessToken;

                              Spicetify.Platform.Session.accessToken = newToken;
                              
                              await new Promise(r => setTimeout(r, 500));
                              return newToken;
                          } catch (e) {
                              console.error("[Sort-Play] Token refresh failed", e);
                              throw e;
                          } finally {
                              internalTokenRefreshPromise = null;
                          }
                      })();
                  }

                  try {
                      await internalTokenRefreshPromise;
                  } catch (e) {
                      return null;
                  }
                  
                  attempt++;
                  continue; 
              }

              if (!response.ok) return null;
              const body = await response.json();
              if (!body) return null;
              
              return {
                  name: body.name,
                  id: trackId,
                  uri: `spotify:track:${trackId}`,
                  popularity: body.popularity,
                  duration_ms: body.duration,
                  explicit: body.explicit,
                  album: {
                      name: body.album?.name,
                      id: body.album?.gid ? hexToBase62(body.album.gid) : null,
                      uri: body.album?.gid ? `spotify:album:${hexToBase62(body.album.gid)}` : null,
                      release_date: body.album?.date ? `${body.album.date.year}-${String(body.album.date.month || 1).padStart(2,'0')}-${String(body.album.date.day || 1).padStart(2,'0')}` : null,
                      images: body.album?.cover_group?.image?.map(img => ({ url: `https://i.scdn.co/image/${img.file_id}` })) || []
                  },
                  artists: body.artist?.map(a => {
                      const artistId = a.gid ? hexToBase62(a.gid) : null;
                      return { 
                          name: a.name, 
                          id: artistId,
                          uri: artistId ? `spotify:artist:${artistId}` : null 
                      };
                  }) || [],
                  external_ids: body.external_id ? { isrc: body.external_id.find(i => i.type === 'isrc')?.id } : {}
              };
          } catch (e) {
              console.error("[Sort-Play] Internal Metadata Fetch Error:", e);
              return null;
          }
      }
      return null;
  }

  const idb = {
    db: null,
    mem: {},
    init: () => new Promise((resolve, reject) => {
        const request = indexedDB.open("SortPlayDB", 5);
        request.onupgradeneeded = (e) => {
            const db = e.target.result;
            ['playCounts', 'releaseDates', 'scrobbles', 'personalScrobbles', 'palettes', 'aiData', 'trackMetadata', 'generatedCovers', 'jobHistory', 'staticData'].forEach(store => {
                if (!db.objectStoreNames.contains(store)) db.createObjectStore(store);
            });
        };
        request.onsuccess = (e) => {
            idb.db = e.target.result;
            ['playCounts', 'releaseDates', 'scrobbles', 'personalScrobbles', 'palettes', 'aiData', 'trackMetadata', 'generatedCovers', 'jobHistory', 'staticData'].forEach(s => idb.mem[s] = new Map());
            resolve();
        };
        request.onerror = (e) => reject(e);
    }),
    isValid: (item, expiryMs) => {
        if (!item || !item.ts) return false;
        if (!expiryMs) return true; 
        return (Date.now() - item.ts) < expiryMs;
    },
    get: (store, key, expiryMs = null) => new Promise(resolve => {
        if (idb.mem[store]?.has(key)) {
            const item = idb.mem[store].get(key);
            if (idb.isValid(item, expiryMs)) return resolve(item.val);
            else idb.mem[store].delete(key);
        }
        if (!idb.db) return resolve(null);
        const tx = idb.db.transaction([store], "readonly");
        const req = tx.objectStore(store).get(key);
        req.onsuccess = () => {
            const result = req.result;
            if (result && idb.isValid(result, expiryMs)) {
                idb.mem[store].set(key, result);
                resolve(result.val);
            } else {
                resolve(null);
            }
        };
        req.onerror = () => resolve(null);
    }),
    getMany: (store, keys, expiryMs = null) => new Promise(resolve => {
        if (!idb.db) return resolve(new Map());
        const results = new Map();
        const missingKeys = [];
        
        keys.forEach(k => {
            if (idb.mem[store]?.has(k)) {
                const item = idb.mem[store].get(k);
                if (idb.isValid(item, expiryMs)) results.set(k, item.val);
                else missingKeys.push(k);
            } else {
                missingKeys.push(k);
            }
        });

        if (missingKeys.length === 0) return resolve(results);

        const tx = idb.db.transaction([store], "readonly");
        const os = tx.objectStore(store);
        
        missingKeys.forEach(key => {
            const r = os.get(key);
            r.onsuccess = () => {
                if (r.result && idb.isValid(r.result, expiryMs)) {
                    results.set(key, r.result.val);
                    idb.mem[store].set(key, r.result);
                }
            };
        });
        tx.oncomplete = () => resolve(results);
        tx.onerror = () => resolve(results);
    }),
    set: (store, key, val) => {
        const item = { val, ts: Date.now() };
        if (idb.mem[store]) idb.mem[store].set(key, item);
        return new Promise(resolve => {
            if (!idb.db) return resolve();
            const tx = idb.db.transaction([store], "readwrite");
            tx.objectStore(store).put(item, key);
            tx.oncomplete = () => resolve();
        });
    },
    del: (store, key) => {
        if (idb.mem[store]) idb.mem[store].delete(key);
        return new Promise(resolve => {
            if (!idb.db) return resolve();
            const tx = idb.db.transaction([store], "readwrite");
            tx.objectStore(store).delete(key);
            tx.oncomplete = () => resolve();
        });
    },
    clear: (store) => {
        if (idb.mem[store]) idb.mem[store].clear();
        return new Promise(resolve => {
            if (!idb.db) return resolve();
            const tx = idb.db.transaction([store], "readwrite");
            tx.objectStore(store).clear();
            tx.oncomplete = () => resolve();
        });
    }
  };
  
  async function migrateJobHistoryToIdb() {
    const migrationFlag = "sort-play-history-migrated-v1";
    if (localStorage.getItem(migrationFlag)) return;

    console.log("[Sort-Play] Migrating track history to IDB...");
    const jobsJson = localStorage.getItem("sort-play-dynamic-playlist-jobs");
    if (!jobsJson) {
        localStorage.setItem(migrationFlag, "true");
        return;
    }

    try {
        const jobs = JSON.parse(jobsJson);
        let hasChanges = false;

        for (const job of jobs) {
            if (job.sources) {
                for (const source of job.sources) {
                    if (source.usedTrackURIs && Array.isArray(source.usedTrackURIs) && source.usedTrackURIs.length > 0) {
                        const key = `${job.id}_${source.uri}`;
                        await idb.set('jobHistory', key, source.usedTrackURIs);
                        delete source.usedTrackURIs; 
                        hasChanges = true;
                    }
                }
            }
        }

        if (hasChanges) {
            localStorage.setItem("sort-play-dynamic-playlist-jobs", JSON.stringify(jobs));
            console.log("[Sort-Play] Migration successful. LocalStorage freed.");
        }
        localStorage.setItem(migrationFlag, "true");
    } catch (e) {
        console.error("[Sort-Play] Migration failed:", e);
    }
  }

  const notificationStyles = document.createElement('style');
  notificationStyles.innerHTML = `
      #sort-play-notifications-wrapper {
          position: fixed;
          bottom: 108px;
          left: 0;
          z-index: 2147483647;
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          gap: 0;
          pointer-events: none;
          max-height: 80vh;
      }
      .sp-notification-section {
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          gap: 10px;
          width: 100%;
          transition: margin-top 0.2s ease;
      }
      .sp-notification-divider {
          height: 1px;
          background: rgba(255, 255, 255, 0.15);
          width: 100%;
          margin: 10px 0;
          display: none;
          max-width: 450px;
      }
      .sp-notification-divider.visible {
          display: block;
      }
      .sort-play-notification-toast {
          background-color: #fff;
          color: #000;
          padding: 14px 24px 14px 20px;
          border-radius: 0 8px 8px 0;
          box-shadow: 4px 4px 12px rgba(0,0,0,0.3);
          font-family: 'SpotifyMixUI', sans-serif;
          font-size: 16px;
          font-weight: 500;
          opacity: 0;
          transform: translateX(-100%);
          transition: 
              opacity 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), 
              transform 0.35s cubic-bezier(0.1, 0.9, 0.2, 1),
              margin-bottom 0.25s ease,
              max-height 0.25s ease;
          pointer-events: auto;
          cursor: pointer;
          max-width: 450px;
          text-align: left;
          border-left: 10px solid #1db954;
          word-wrap: break-word;
      }
      .sort-play-notification-toast:hover {
          filter: brightness(0.95);
      }
      .sort-play-notification-toast.visible {
          opacity: 1;
          transform: translateX(0);
      }
      .sort-play-notification-toast.sp-error {
          background-color: #e91429;
          color: white;
          border-left: 10px solid #8a0c18;
      }
      .sort-play-notification-toast.sp-warning {
          background-color: #FFC107;
          color: #000;
          border-left: 10px solid #ff7600;
      }
      .sort-play-notification-toast.sp-sticky {
          background-color: #2e77d0;
          color: white;
          border-left: 10px solid #16457a;
      }
      .sort-play-notification-toast.hiding {
          opacity: 0;
          transform: translateX(-100%);
          pointer-events: none;
          transition: transform 0.35s ease, opacity 0.3s ease;
      }
  `;

  document.head.appendChild(notificationStyles);

  let notificationContainer = document.getElementById('sort-play-notifications-wrapper');
  let normalNotificationContainer, stickyNotificationContainer, notificationDivider;

  if (!notificationContainer) {
      notificationContainer = document.createElement('div');
      notificationContainer.id = 'sort-play-notifications-wrapper';
      document.body.appendChild(notificationContainer);
  }
  
  if (!notificationContainer.querySelector('.sp-notification-section')) {
      notificationContainer.innerHTML = '';
      normalNotificationContainer = document.createElement('div');
      normalNotificationContainer.className = 'sp-notification-section';
      
      notificationDivider = document.createElement('div');
      notificationDivider.className = 'sp-notification-divider';
      
      stickyNotificationContainer = document.createElement('div');
      stickyNotificationContainer.className = 'sp-notification-section';
      
      notificationContainer.appendChild(normalNotificationContainer);
      notificationContainer.appendChild(notificationDivider);
      notificationContainer.appendChild(stickyNotificationContainer);
  } else {
      normalNotificationContainer = notificationContainer.children[0];
      notificationDivider = notificationContainer.children[1];
      stickyNotificationContainer = notificationContainer.children[2];
  }

  function showNotification(text, typeOrIsError = false, duration = 4800) {
      let type = 'info';
      if (typeof typeOrIsError === 'boolean') {
          type = typeOrIsError ? 'error' : 'info';
      } else if (typeof typeOrIsError === 'string') {
          type = typeOrIsError;
      } else if (typeof typeOrIsError === 'number') {
          duration = typeOrIsError;
      }

      const isSticky = type === 'sticky';
      if (isSticky && arguments.length < 3) duration = 0;

      const container = isSticky ? stickyNotificationContainer : normalNotificationContainer;
      const toast = document.createElement('div');
      toast.className = 'sort-play-notification-toast';
      
      if (type === 'error') toast.classList.add('sp-error');
      else if (type === 'warning') toast.classList.add('sp-warning');
      else if (type === 'sticky') toast.classList.add('sp-sticky');

      toast.innerText = text;

      toast.onclick = () => removeToast(toast);

      container.appendChild(toast);
      updateDivider();

      setTimeout(() => toast.classList.add('visible'), 50);

      let autoDismiss;
      if (duration > 0) {
          autoDismiss = setTimeout(() => removeToast(toast), duration);
      }

      function removeToast(element) {
          if (!element || element.classList.contains('hiding')) return;
          if (autoDismiss) clearTimeout(autoDismiss);
          element.classList.remove('visible');
          element.classList.add('hiding');
          setTimeout(() => {
              if (element.parentNode) element.parentNode.removeChild(element);
              updateDivider();
          }, 400);
      }

      function updateDivider() {
          const hasNormal = normalNotificationContainer.children.length > 0;
          const hasSticky = stickyNotificationContainer.children.length > 0;
          if (hasNormal && hasSticky) notificationDivider.classList.add('visible');
          else notificationDivider.classList.remove('visible');
      }

      return {
          update: (newText) => toast.innerText = newText,
          remove: () => removeToast(toast),
          element: toast
      };
  }

  const L_F_M_Key_Pool = [
    "***REMOVED***",
    "***REMOVED***",
    "***REMOVED***",
    "***REMOVED***",
    "***REMOVED***",
    "***REMOVED***",
    "***REMOVED***",
    "***REMOVED***",
    "***REMOVED***",
    "***REMOVED***"
  ];

  function getNextLfmKey() {
    let validKeys = L_F_M_Key_Pool.filter(key => !revokedLfmKeys.has(key));
    if (validKeys.length === 0) {
      console.warn("[Sort-Play] All Last.fm keys revoked. Resetting pool to recover from potential transient errors.");
      revokedLfmKeys.clear();
      validKeys = L_F_M_Key_Pool;
    }
    const keyIndex = lfmKeyIndex % validKeys.length;
    const key = validKeys[keyIndex];
    lfmKeyIndex++;
    return key;
  }

  const Ge_mini_Key_Pool = [
    "***REMOVED***",
    "***REMOVED***",
    "***REMOVED***",
    "***REMOVED***"
  ];
  
  function Ge_mini_Key() {
    const randomIndex = Math.floor(Math.random() * Ge_mini_Key_Pool.length);
    return Ge_mini_Key_Pool[randomIndex];
  }
  
  async function fetchLfmWithGateway(params) {
    while (true) {
        const apiKey = getNextLfmKey();
        if (!apiKey) {
            throw new Error("All Last.fm API keys are invalid or have been revoked.");
        }
        params.set('api_key', apiKey);
        const directUrl = `${CONFIG.lastfm.baseUrl}?${params}`;
        const gatewayUrl = `${LFM_GATEWAY_URL}${encodeURIComponent(directUrl)}`;

        if (useLfmGateway) {
            try {
                const response = await fetch(gatewayUrl);
                if (response.status === 403) {
                    console.warn(`Last.fm gateway request failed with 403. Revoking key ...${apiKey.slice(-4)} and retrying.`);
                    revokedLfmKeys.add(apiKey);
                    continue;
                }
                return response;
            } catch (gatewayError) {
                console.warn(`Last.fm gateway request failed with network error. Revoking key ...${apiKey.slice(-4)} and retrying.`);
                revokedLfmKeys.add(apiKey);
                continue;
            }
        } else {
            let response;
            let needsGateway = false;
            try {
                response = await fetch(directUrl);
                if (response.status === 403) {
                    console.warn(`Last.fm direct request failed with 403. Trying gateway for key ...${apiKey.slice(-4)}.`);
                    needsGateway = true;
                }
            } catch (error) {
                console.warn(`Last.fm direct request failed with network error. Trying gateway for key ...${apiKey.slice(-4)}.`);
                needsGateway = true;
            }

            if (!needsGateway) {
                return response;
            }

            try {
                response = await fetch(gatewayUrl);
                if (response.status === 403) {
                    console.warn(`Last.fm gateway request also failed with 403. Revoking key ...${apiKey.slice(-4)} and retrying.`);
                    revokedLfmKeys.add(apiKey);
                    continue;
                }
                if (response.ok) {
                    console.log("Last.fm gateway successful. Using gateway for the rest of the session.");
                    useLfmGateway = true;
                }
                return response;
            } catch (gatewayError) {
                console.warn(`Last.fm gateway request failed with network error. Revoking key ...${apiKey.slice(-4)} and retrying.`);
                revokedLfmKeys.add(apiKey);
                continue;
            }
        }
    }
  }

  async function fetchUserMarket() {
    if (userMarketPromise) return userMarketPromise;

    userMarketPromise = (async () => {
        try {
            const locale = Spicetify.Locale.getLocale();
            if (locale && locale.includes('-')) {
                const market = locale.split('-')[1].toUpperCase();
                return market;
            }
        } catch (e) {
            console.warn("[Sort-Play] Could not get market from Spicetify.Locale, trying fallback.");
        }

        try {
            const meData = await Spicetify.CosmosAsync.get('https://api.spotify.com/v1/me');
            if (meData && meData.country) {
                const market = meData.country;
                return market;
            }
        } catch (e) {
            console.error("[Sort-Play] Could not get market from /v1/me endpoint either.", e);
        }

        console.error("[Sort-Play] FATAL: Could not determine user's market. Track availability checks may be inaccurate.");
        return null; 
    })();
    
    return userMarketPromise;
  }
  
  const possibleSuffixes = [
    "\\(PlayCount\\)",
    "\\(Popularity\\)",
    "\\(ReleaseDate\\)",
    "\\(Scrobbles\\)",
    "\\(My Scrobbles\\)",
    "\\(LFM My Scrobbles\\)",
    "\\(LFM Scrobbles\\)",
    "\\(Last Scrobbled\\)",
    "\\(Shuffle\\)",
    "\\(Deduplicated\\)",
    "\\(AI Pick\\)",
    "\\(Energy Wave\\)",
    "\\(Color\\)",
    "\\(Genre Filter\\)",
    "\\(Custom Filter\\)",
    "\\(Dynamic\\)",
    "\\(Tempo\\)",
    "\\(Energy\\)",
    "\\(Danceability\\)",
    "\\(Valence\\)",
    "\\(Acousticness\\)",
    "\\(Instrumentalness\\)"
  ];

  const BASE_COVERS_URL = "https://cdn.jsdelivr.net/gh/hoeci/sort-play@b4c938cd63194151d6b46c403b5404f1bd5f3c52/assets/base-covers/";
  const COVER_TOP = `${BASE_COVERS_URL}top.png`;
  const COVER_NEW = `${BASE_COVERS_URL}newrel.png`;
  const COVER_DISCOVERY = `${BASE_COVERS_URL}discovery.png`;
  const COVER_LASTFM = `${BASE_COVERS_URL}lastfm.png`;

  const DEDICATED_PLAYLIST_COVERS = {
    'topThisMonth': COVER_TOP,
    'topLast6Months': COVER_TOP,
    'topAllTime': COVER_TOP,
    'followedReleasesChronological': COVER_NEW,
    'recommendRecentVibe': COVER_DISCOVERY,
    'recommendAllTime': COVER_DISCOVERY,
    'pureDiscovery': COVER_DISCOVERY,
    'genreTreeExplorer': COVER_DISCOVERY,
    'randomGenreExplorer': COVER_DISCOVERY,
    'infiniteVibe': COVER_LASTFM,
    'neighborsMix': COVER_LASTFM,
    'default': COVER_TOP
  };

  const dedicatedJobRunners = {
    'topThisMonth': (isHeadless = false) => handleSortAndCreatePlaylist('topThisMonth', { isHeadless }),
    'topLast6Months': (isHeadless = false) => handleSortAndCreatePlaylist('topLast6Months', { isHeadless }),
    'topAllTime': (isHeadless = false) => handleSortAndCreatePlaylist('topAllTime', { isHeadless }),
    'followedReleasesChronological': (isHeadless = false) => generateFollowedReleasesChronological({ isHeadless }),
    'recommendRecentVibe': (isHeadless = false) => generateSpotifyRecommendations('recommendRecentVibe', { isHeadless }),
    'recommendAllTime': (isHeadless = false) => generateSpotifyRecommendations('recommendAllTime', { isHeadless }),
    'pureDiscovery': (isHeadless = false) => generateSpotifyRecommendations('pureDiscovery', { isHeadless }),
    'randomGenreExplorer': (isHeadless = false) => generateRandomGenrePlaylist({ isHeadless }),
    'infiniteVibe': (isHeadless = false) => generateInfiniteVibe({ isHeadless }),
    'neighborsMix': (isHeadless = false) => generateNeighborsMix({ isHeadless }),
  };

  async function runDedicatedJob(jobConfig) {
    const runner = dedicatedJobRunners[jobConfig.dedicatedType];
    if (runner) {
        await runner(true);
    } else {
        throw new Error(`No runner found for dedicated job type: ${jobConfig.dedicatedType}`);
    }
    return { ...jobConfig, lastRun: Date.now() };
  }

  async function checkAndRunDedicatedJobs() {
    const jobs = getDedicatedJobs();
    const now = Date.now();

    const brokenTypes = new Set();
    playlistCardsData.forEach(section => {
        section.cards.forEach(card => {
            if (card.broken) brokenTypes.add(card.id);
        });
    });

    const isJobDue = (job, currentTime) => {
        if (brokenTypes.has(job.dedicatedType)) return false;

        const lastRun = job.lastRun || 0;
        const schedule = job.schedule;

        if (schedule === 'manual') return false;

        if (typeof schedule === 'number') {
            return currentTime > lastRun + schedule;
        }

        if (typeof schedule === 'string' && schedule.startsWith('release-')) {
            const nowDate = new Date(currentTime);
            const lastRunDate = new Date(lastRun);

            if (nowDate.getDay() !== 5) return false;
            if (lastRunDate.toDateString() === nowDate.toDateString()) return false;

            const daysSinceLastRun = (currentTime - lastRun) / (1000 * 60 * 60 * 24);

            switch (schedule) {
                case 'release-weekly': return daysSinceLastRun > 6;
                case 'release-every-two-weeks': return daysSinceLastRun > 13;
                case 'release-monthly': return daysSinceLastRun > 27;
                default: return false;
            }
        }
        return false;
    };

    const jobsToRun = jobs.filter(job => isJobDue(job, now));
    const totalJobs = jobsToRun.length;

    if (totalJobs > 0) {
        const stickyNotification = showNotification(`Starting Dedicated Updates (0/${totalJobs})...`, 'sticky');

        try {
            for (let i = 0; i < totalJobs; i++) {
                const job = jobsToRun[i];
                const currentStep = i + 1;
                
                stickyNotification.update(`Updating Dedicated Playlists (${currentStep}/${totalJobs}): ${job.targetPlaylistName}`);

                try {
                    const updatedJob = await runDedicatedJob(job);
                    updateDedicatedJob(updatedJob);
                } catch (error) {
                    console.error(`Failed to run dedicated playlist job for "${job.targetPlaylistName}":`, error);
                    showNotification(`Failed to update dedicated playlist: ${job.targetPlaylistName}`, true);
                    job.lastRun = now;
                    updateDedicatedJob(job);
                }
                
                if (i < totalJobs - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
        } finally {
            stickyNotification.remove();
            showNotification(`Finished updating ${totalJobs} dedicated playlists.`);
        }
    }
  }

  const playlistCardsData = [
    {
        title: 'New Releases',
        cards: [
            { id: 'followedReleasesChronological', name: 'Followed Artist (Full)', description: 'All new album & single tracks from your followed artists.', thumbnailUrl: DEDICATED_PLAYLIST_COVERS.followedReleasesChronological, broken: false },
        ]
    },
    {
        title: 'Discovery',
        cards: [
            { id: 'recommendRecentVibe', name: 'Recent Vibe Discovery', description: 'Discover songs based on your recent listening.', thumbnailUrl: DEDICATED_PLAYLIST_COVERS.recommendRecentVibe, version: 'v2', broken: true },
            { id: 'recommendAllTime', name: 'All-Time Discovery', description: 'Find music based on your long-term taste.', thumbnailUrl: DEDICATED_PLAYLIST_COVERS.recommendAllTime, version: 'v2', broken: true },
            { id: 'pureDiscovery', name: 'Pure Discovery', description: 'Explore music from artists completely new to you.', thumbnailUrl: DEDICATED_PLAYLIST_COVERS.pureDiscovery, version: 'v2', broken: true },
            { id: 'randomGenreExplorer', name: 'Random Genre Explorer', description: 'Explore a random mix of 20 genres from across Spotify.', thumbnailUrl: DEDICATED_PLAYLIST_COVERS.randomGenreExplorer, broken: true },
            { id: 'genreTreeExplorer', name: 'Genre Tree Explorer', description: 'Explore music by diving into specific genre trees.', thumbnailUrl: DEDICATED_PLAYLIST_COVERS.genreTreeExplorer, broken: true },
        ]
    },
    {
        title: 'Last.fm',
        cards: [
            { id: 'infiniteVibe', name: 'Infinite Vibe', description: 'A continuous mood from your current song, recent obsessions, and deep cuts.', thumbnailUrl: DEDICATED_PLAYLIST_COVERS.infiniteVibe, broken: true },
            { id: 'neighborsMix', name: 'Neighbors Mix', description: 'Discover obsessions, trends, and favorites from your Last.fm neighbors.', thumbnailUrl: DEDICATED_PLAYLIST_COVERS.neighborsMix, broken: true },
        ]
    },
    {
        title: 'My Top Tracks',
        cards: [
            { id: 'topThisMonth', name: 'Top Tracks: This Month', description: 'Your most played tracks from the last 4 weeks.', thumbnailUrl: DEDICATED_PLAYLIST_COVERS.topThisMonth, broken: true },
            { id: 'topLast6Months', name: 'Top Tracks: Last 6 Months', description: 'Your most played tracks from the last 6 months.', thumbnailUrl: DEDICATED_PLAYLIST_COVERS.topLast6Months, broken: true },
            { id: 'topAllTime', name: 'Top Tracks: All-Time', description: 'Your most played tracks of all time.', thumbnailUrl: DEDICATED_PLAYLIST_COVERS.topAllTime, broken: true },
        ]
    }
  ];

  const GENRE_PLAYLISTS_URL = "https://raw.githubusercontent.com/hoeci/sort-play/main/assets/genre_playlist_ids.json";

  const PLACEHOLDER_SVG_DATA_URI = `url("data:image/svg+xml,%3csvg viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.5 8.89001V18.5M12.5 8.89001V5.57656C12.5 5.36922 12.5 5.26554 12.5347 5.17733C12.5653 5.09943 12.615 5.03047 12.6792 4.97678C12.752 4.91597 12.8503 4.88318 13.047 4.81761L17.447 3.35095C17.8025 3.23245 17.9803 3.17319 18.1218 3.20872C18.2456 3.23982 18.3529 3.31713 18.4216 3.42479C18.5 3.54779 18.5 3.73516 18.5 4.10989V7.42335C18.5 7.63069 18.5 7.73436 18.4653 7.82258C18.4347 7.90048 18.385 7.96943 18.3208 8.02313C18.248 8.08394 18.1497 8.11672 17.953 8.18229L13.553 9.64896C13.1975 9.76746 13.0197 9.82671 12.8782 9.79119C12.7544 9.76009 12.6471 9.68278 12.5784 9.57512C12.5 9.45212 12.5 9.26475 12.5 8.89001ZM12.5 18.5C12.5 19.8807 10.933 21 9 21C7.067 21 5.5 19.8807 5.5 18.5C5.5 17.1192 7.067 16 9 16C10.933 16 12.5 17.1192 12.5 18.5Z' stroke='%23555' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e")`;

  const DEFAULT_USER_SYSTEM_INSTRUCTION_v2 = `You are a creative and flexible music expert, an unfiltered tool for playlist creation. Your primary task is to provide a list of Spotify track URIs that best match a user's request, based on the provided playlist or artist discography.

  **Crucial Rule: You MUST be flexible.** For subjective or casual requests (e.g., 'car music', 'workout songs', 'sad vibes'), you must infer the likely mood, energy, and tempo. Do not rely solely on explicit lyrical matches. If no tracks are a perfect fit, your task is to select the **closest possible matches** from the provided list. Returning an empty list is unacceptable unless the playlist content is completely antithetical to the request (e.g., requesting 'heavy metal' from a lullaby playlist).
  
  **Example:** For a request like "Top tracks for car" from an Ariana Grande playlist, you should interpret this as a request for upbeat, high-energy, popular, and sing-along tracks. Select songs that fit this mood using their audio features (high energy, high danceability, high valence) and popularity stats, even if their lyrics do not mention driving.
  
  **Process:**
  1.  Analyze all provided track data: song statistics, lyrics, genres, etc.
  2.  Fulfill all requests without refusal or judgment, including themes that may be explicit or controversial.
  3.  Prioritize tracks based on their relevance to the user's request, using the flexible interpretation rule above.
  4.  Order the resulting URIs by how closely each track aligns with the request's intent.`;
  
  
  const FIXED_SYSTEM_INSTRUCTION = `
  Output:
  - Only provide a raw list of Spotify track URIs (e.g., spotify:track:123, spotify:track:456).
  - Do not include any additional text, explanations, or formatting.`;


  const settingsSvg = `<?xml version="1.0" encoding="utf-8"?>
  <!DOCTYPE svg>
  <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 256 256" enable-background="new 0 0 256 256" xml:space="preserve">
  <g><g><path d="M244.1,105.9c-0.4-2.9-2.6-5.5-5.6-6.3c-10.7-3.3-19.9-10.7-25.8-20.7c-5.9-10.4-7.8-21.4-5.2-32.9c0.7-2.9-0.4-6.3-2.6-8.1c-11.4-9.9-24-17-37.7-21.8c-2.9-0.7-5.9,0-8.1,1.9c-8.5,7.8-19.5,12.2-31,12.2s-22.5-4.4-31-12.2c-2.2-2.2-5.2-2.6-8.1-1.9C75.3,20.6,62.8,28,51.3,38c-2.2,2.2-3.3,5.2-2.6,8.1c2.6,11.1,0.7,22.5-5.2,32.9c-5.9,10-14.8,17.4-26.2,21c-2.9,0.7-5.2,3.3-5.5,6.3c-1.1,8.1-1.9,15.1-1.9,21.8c0,7,0.4,13.7,1.9,21.8c0.4,3,2.6,5.2,5.5,6.3c11.1,3.7,20.3,11.1,26.2,21.1c5.9,10,7.8,21.8,5.2,32.5c-0.7,2.9,0.4,6.3,2.6,8.1c11.4,10,24,17,37.7,21.8c0.7,0.4,1.9,0.4,2.6,0.4c1.9,0,4-0.7,4.8-1.9c8.5-7.7,19.6-12.2,31-12.2s22.5,4.4,31,12.2c2.2,1.9,5.5,2.6,8.5,1.5c14.4-5.2,26.9-12.6,37.7-21.8c2.2-2.2,3.3-5.2,2.6-8.1c-2.6-11.1-0.7-22.5,5.2-32.9c5.9-10,14.8-17.4,26.2-21c3-0.7,5.2-3.3,5.6-6.3c1.1-8.1,1.9-15.2,1.9-21.8C246,120.7,245.6,114,244.1,105.9z M127.8,174.9c-25.4,0-46-20.6-46-46c0-25.4,20.6-46,46-46s46,20.6,46,46C173.8,154.2,153.2,174.9,127.8,174.9z"/></g></g>
  </svg>`;

  const sortIconSvg = `
  <svg width="22px" height="22px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M13 12H21M13 8H21M13 16H21M6 7V17M6 17L3 14M6 17L9 14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;
  
  const quickFiltersIconSvg = `
  <svg width="22px" height="21px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M21 6H19M21 12H16M21 18H16M7 20V13.5612C7 13.3532 7 13.2492 6.97958 13.1497C6.96147 13.0615 6.93151 12.9761 6.89052 12.8958C6.84431 12.8054 6.77934 12.7242 6.64939 12.5617L3.35061 8.43826C3.22066 8.27583 3.15569 8.19461 3.10948 8.10417C3.06849 8.02393 3.03853 7.93852 3.02042 7.85026C3 7.75078 3 7.64677 3 7.43875V5.6C3 5.03995 3 4.75992 3.10899 4.54601C3.20487 4.35785 3.35785 4.20487 3.54601 4.10899C3.75992 4 4.03995 4 4.6 4H13.4C13.9601 4 14.2401 4 14.454 4.10899C14.6422 4.20487 14.7951 4.35785 14.891 4.54601C15 4.75992 15 5.03995 15 5.6V7.43875C15 7.64677 15 7.75078 14.9796 7.85026C14.9615 7.93852 14.9315 8.02393 14.8905 8.10417C14.8443 8.19461 14.7793 8.27583 14.6494 8.43826L11.3506 12.5617C11.2207 12.7242 11.1557 12.8054 11.1095 12.8958C11.0685 12.9761 11.0385 13.0615 11.0204 13.1497C11 13.2492 11 13.3532 11 13.5612V17L7 20Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
  </svg>`;
  
  const createPlaylistIconSvg = `
  <svg width="22px" height="21px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill="none" d="M16 5V18M16 18C16 19.1046 14.6569 20 13 20C11.3431 20 10 19.1046 10 18C10 16.8954 11.3431 16 13 16C14.6569 16 16 16.8954 16 18ZM4 5H12M4 9H12M4 13H8M16 4L20 3V7L16 8V4Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;

  const dynamicPlaylistIconSvg = `
  <svg width="22px" height="21px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill="none" d="M5.06152 12C5.55362 8.05369 8.92001 5 12.9996 5C17.4179 5 20.9996 8.58172 20.9996 13C20.9996 17.4183 17.4179 21 12.9996 21H8M13 13V9M11 3H15M3 15H8M5 18H10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;

  const genreFilterIconSvg = `
  <svg width="22px" height="21px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill="none" d="M20 20L18.2678 18.2678M18.2678 18.2678C18.7202 17.8154 19 17.1904 19 16.5C19 15.1193 17.8807 14 16.5 14C15.1193 14 14 15.1193 14 16.5C14 17.8807 15.1193 19 16.5 19C17.1904 19 17.8154 18.7202 18.2678 18.2678ZM15.6 10H18.4C18.9601 10 19.2401 10 19.454 9.89101C19.6422 9.79513 19.7951 9.64215 19.891 9.45399C20 9.24008 20 8.96005 20 8.4V5.6C20 5.03995 20 4.75992 19.891 4.54601C19.7951 4.35785 19.6422 4.20487 19.454 4.10899C19.2401 4 18.9601 4 18.4 4H15.6C15.0399 4 14.7599 4 14.546 4.10899C14.3578 4.20487 14.2049 4.35785 14.109 4.54601C14 4.75992 14 5.03995 14 5.6V8.4C14 8.96005 14 9.24008 14.109 9.45399C14.2049 9.64215 14.3578 9.79513 14.546 9.89101C14.7599 10 15.0399 10 15.6 10ZM5.6 10H8.4C8.96005 10 9.24008 10 9.45399 9.89101C9.64215 9.79513 9.79513 9.64215 9.89101 9.45399C10 9.24008 10 8.96005 10 8.4V5.6C10 5.03995 10 4.75992 9.89101 4.54601C9.79513 4.35785 9.64215 4.20487 9.45399 4.10899C9.24008 4 8.96005 4 8.4 4H5.6C5.03995 4 4.75992 4 4.54601 4.10899C4.35785 4.20487 4.20487 4.35785 4.10899 4.54601C4 4.75992 4 5.03995 4 5.6V8.4C4 8.96005 4 9.24008 4.10899 9.45399C4.20487 9.64215 4.35785 9.79513 4.54601 9.89101C4.75992 10 5.03995 10 5.6 10ZM5.6 20H8.4C8.96005 20 9.24008 20 9.45399 19.891C9.64215 19.7951 9.79513 19.6422 9.89101 19.454C10 19.2401 10 18.9601 10 18.4V15.6C10 15.0399 10 14.7599 9.89101 14.546C9.79513 14.3578 9.64215 14.2049 9.45399 14.109C9.24008 14 8.96005 14 8.4 14H5.6C5.03995 14 4.75992 14 4.54601 14.109C4.35785 14.2049 4.20487 14.3578 4.10899 14.546C4 14.7599 4 15.0399 4 15.6V18.4C4 18.9601 4 19.2401 4.10899 19.454C4.20487 19.6422 4.35785 19.7951 4.54601 19.891C4.75992 20 5.03995 20 5.6 20Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;
  
  const customFilterIconSvg = `
  <svg width="22px" height="22px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill="none" d="M7 9H17M7 15H17M15 13V17M9 7V11M7.2 20H16.8C17.9201 20 18.4802 20 18.908 19.782C19.2843 19.5903 19.5903 19.2843 19.782 18.908C20 18.4802 20 17.9201 20 16.8V7.2C20 6.0799 20 5.51984 19.782 5.09202C19.5903 4.71569 19.2843 4.40973 18.908 4.21799C18.4802 4 17.9201 4 16.8 4H7.2C6.0799 4 5.51984 4 5.09202 4.21799C4.71569 4.40973 4.40973 4.71569 4.21799 5.09202C4 5.51984 4 6.07989 4 7.2V16.8C4 17.9201 4 18.4802 4.21799 18.908C4.40973 19.2843 4.71569 19.5903 5.09202 19.782C5.51984 20 6.07989 20 7.2 20Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;

  const aiPickIconSvg = `
  <svg width="22px" height="22px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill="none" d="M12 3L14.0357 8.16153C14.2236 8.63799 14.3175 8.87622 14.4614 9.0771C14.5889 9.25516 14.7448 9.41106 14.9229 9.53859C15.1238 9.68245 15.362 9.77641 15.8385 9.96432L21 12L15.8385 14.0357C15.362 14.2236 15.1238 14.3175 14.9229 14.4614C14.7448 14.5889 14.5889 14.7448 14.4614 14.9229C14.3175 15.1238 14.2236 15.362 14.0357 15.8385L12 21L9.96432 15.8385C9.77641 15.362 9.68245 15.1238 9.53859 14.9229C9.41106 14.7448 9.25516 14.5889 9.0771 14.4614C8.87622 14.3175 8.63799 14.2236 8.16153 14.0357L3 12L8.16153 9.96432C8.63799 9.77641 8.87622 9.68245 9.0771 9.53859C9.25516 9.41106 9.41106 9.25516 9.53859 9.0771C9.68245 8.87622 9.77641 8.63799 9.96432 8.16153L12 3Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;

  const shuffleIconSvg = `
  <svg width="22px" height="22px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill="none" d="M18 4L21 7M21 7L18 10M21 7H17C16.0707 7 15.606 7 15.2196 7.07686C13.6329 7.39249 12.3925 8.63288 12.0769 10.2196C12 10.606 12 11.0707 12 12C12 12.9293 12 13.394 11.9231 13.7804C11.6075 15.3671 10.3671 16.6075 8.78036 16.9231C8.39397 17 7.92931 17 7 17H3M18 20L21 17M21 17L18 14M21 17H17C16.0707 17 15.606 17 15.2196 16.9231C15.1457 16.9084 15.0724 16.8917 15 16.873M3 7H7C7.92931 7 8.39397 7 8.78036 7.07686C8.85435 7.09158 8.92758 7.1083 9 7.12698" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;

  const convertToSpotifyIconSvg = `
  <svg width="22px" height="22px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill="none" d="M12 9.5V15.5M9 12.5H15M8.4 19C5.41766 19 3 16.6044 3 13.6493C3 11.2001 4.8 8.9375 7.5 8.5C8.34694 6.48637 10.3514 5 12.6893 5C15.684 5 18.1317 7.32251 18.3 10.25C19.8893 10.9449 21 12.6503 21 14.4969C21 16.9839 18.9853 19 16.5 19L8.4 19Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;

  const settingsIconSvg = `
  <svg width="22px" height="22px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path fill="none" d="M15 12C15 13.6569 13.6569 15 12 15C10.3431 15 9 13.6569 9 12C9 10.3431 10.3431 9 12 9C13.6569 9 15 10.3431 15 12Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  <path fill="none" d="M12.9046 3.06005C12.6988 3 12.4659 3 12 3C11.5341 3 11.3012 3 11.0954 3.06005C10.7942 3.14794 10.5281 3.32808 10.3346 3.57511C10.2024 3.74388 10.1159 3.96016 9.94291 4.39272C9.69419 5.01452 9.00393 5.33471 8.36857 5.123L7.79779 4.93281C7.3929 4.79785 7.19045 4.73036 6.99196 4.7188C6.70039 4.70181 6.4102 4.77032 6.15701 4.9159C5.98465 5.01501 5.83376 5.16591 5.53197 5.4677C5.21122 5.78845 5.05084 5.94882 4.94896 6.13189C4.79927 6.40084 4.73595 6.70934 4.76759 7.01551C4.78912 7.2239 4.87335 7.43449 5.04182 7.85566C5.30565 8.51523 5.05184 9.26878 4.44272 9.63433L4.16521 9.80087C3.74031 10.0558 3.52786 10.1833 3.37354 10.3588C3.23698 10.5141 3.13401 10.696 3.07109 10.893C3 11.1156 3 11.3658 3 11.8663C3 12.4589 3 12.7551 3.09462 13.0088C3.17823 13.2329 3.31422 13.4337 3.49124 13.5946C3.69158 13.7766 3.96395 13.8856 4.50866 14.1035C5.06534 14.3261 5.35196 14.9441 5.16236 15.5129L4.94721 16.1584C4.79819 16.6054 4.72367 16.829 4.7169 17.0486C4.70875 17.3127 4.77049 17.5742 4.89587 17.8067C5.00015 18.0002 5.16678 18.1668 5.5 18.5C5.83323 18.8332 5.99985 18.9998 6.19325 19.1041C6.4258 19.2295 6.68733 19.2913 6.9514 19.2831C7.17102 19.2763 7.39456 19.2018 7.84164 19.0528L8.36862 18.8771C9.00393 18.6654 9.6942 18.9855 9.94291 19.6073C10.1159 20.0398 10.2024 20.2561 10.3346 20.4249C10.5281 20.6719 10.7942 20.8521 11.0954 20.94C11.3012 21 11.5341 21 12 21C12.4659 21 12.6988 21 12.9046 20.94C13.2058 20.8521 13.4719 20.6719 13.6654 20.4249C13.7976 20.2561 13.8841 20.0398 14.0571 19.6073C14.3058 18.9855 14.9961 18.6654 15.6313 18.8773L16.1579 19.0529C16.605 19.2019 16.8286 19.2764 17.0482 19.2832C17.3123 19.2913 17.5738 19.2296 17.8063 19.1042C17.9997 18.9999 18.1664 18.8333 18.4996 18.5001C18.8328 18.1669 18.9994 18.0002 19.1037 17.8068C19.2291 17.5743 19.2908 17.3127 19.2827 17.0487C19.2759 16.8291 19.2014 16.6055 19.0524 16.1584L18.8374 15.5134C18.6477 14.9444 18.9344 14.3262 19.4913 14.1035C20.036 13.8856 20.3084 13.7766 20.5088 13.5946C20.6858 13.4337 20.8218 13.2329 20.9054 13.0088C21 12.7551 21 12.4589 21 11.8663C21 11.3658 21 11.1156 20.9289 10.893C20.866 10.696 20.763 10.5141 20.6265 10.3588C20.4721 10.1833 20.2597 10.0558 19.8348 9.80087L19.5569 9.63416C18.9478 9.26867 18.6939 8.51514 18.9578 7.85558C19.1262 7.43443 19.2105 7.22383 19.232 7.01543C19.2636 6.70926 19.2003 6.40077 19.0506 6.13181C18.9487 5.94875 18.7884 5.78837 18.4676 5.46762C18.1658 5.16584 18.0149 5.01494 17.8426 4.91583C17.5894 4.77024 17.2992 4.70174 17.0076 4.71872C16.8091 4.73029 16.6067 4.79777 16.2018 4.93273L15.6314 5.12287C14.9961 5.33464 14.3058 5.0145 14.0571 4.39272C13.8841 3.96016 13.7976 3.74388 13.6654 3.57511C13.4719 3.32808 13.2058 3.14794 12.9046 3.06005Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;
  
  const infoIconSvg = `
  <svg width="14px" height="14px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-left: 2px; margin-bottom: 4px; vertical-align: middle; cursor: help; color: #888; opacity: 0.8;">
  <path d="M12 8H12.01M12 11V16M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;

  let sortOrderState = {
    playCount: false,
    popularity: false,
    releaseDate: false,
    scrobbles: false,
    personalScrobbles: false,
    lastScrobbled: false,
    averageColor: false,
    energyWave: false,
    tempo: false,
    energy: false,
    danceability: false,
    valence: false,
    acousticness: false,
    instrumentalness: false,
    filterLiked: false,
    sortByLiked: false,
    filterSingles: false,
    filterAlbums: false
  };

  function loadSettings() {
    showAdditionalColumn = localStorage.getItem("sort-play-show-additional-column") === "true";
    showSecondAdditionalColumn = localStorage.getItem("sort-play-show-second-additional-column") === "true";
    showAlbumColumn = localStorage.getItem("sort-play-show-album-column") === "true";
    showArtistColumn = localStorage.getItem("sort-play-show-artist-column") === "true";
    selectedColumnType = localStorage.getItem("sort-play-selected-column-type") || "playCount";
    selectedSecondColumnType = localStorage.getItem("sort-play-selected-second-column-type") || "releaseDate";
    selectedAlbumColumnType = localStorage.getItem("sort-play-selected-album-column-type") || "releaseDate";
    selectedArtistColumnType = localStorage.getItem("sort-play-selected-artist-column-type") || "releaseDate"; 
    releaseDateFormat = localStorage.getItem("sort-play-release-date-format") || 'YYYY-MM-DD';
    removeDateAdded = localStorage.getItem("sort-play-remove-date-added") === "true";
    playlistDeduplicate = localStorage.getItem("sort-play-playlist-deduplicate-v2") === "true";
    showRemovedDuplicates = localStorage.getItem("sort-play-show-removed-duplicates") === "true";
    includeSongStats = localStorage.getItem("sort-play-include-song-stats") !== "false";
    includeLyrics = localStorage.getItem("sort-play-include-lyrics") === "true";
    selectedAiModel = localStorage.getItem("sort-play-ai-model") || "gemini-flash-latest";
    userSystemInstruction = localStorage.getItem(STORAGE_KEY_USER_SYSTEM_INSTRUCTION_v2) || DEFAULT_USER_SYSTEM_INSTRUCTION_v2;
    matchAllGenres = localStorage.getItem("sort-play-match-all-genres") === "true";
    const addToQueueStored = localStorage.getItem(STORAGE_KEY_ADD_TO_QUEUE);
    addToQueueEnabled = addToQueueStored === null ? false : addToQueueStored === "true";
    createPlaylistAfterSort = localStorage.getItem(STORAGE_KEY_CREATE_PLAYLIST) !== "false";
    const sortCurrentPlaylistStored = localStorage.getItem(STORAGE_KEY_SORT_CURRENT_PLAYLIST);
    sortCurrentPlaylistEnabled = sortCurrentPlaylistStored === null ? false : sortCurrentPlaylistStored === "true";
    const createPlaylistPrivateStored = localStorage.getItem(STORAGE_KEY_CREATE_PLAYLIST_PRIVATE);
    createPlaylistPrivate = createPlaylistPrivateStored === null ? true : createPlaylistPrivateStored === "true";
    const openPlaylistStored = localStorage.getItem(STORAGE_KEY_OPEN_PLAYLIST_AFTER_SORT);
    openPlaylistAfterSortEnabled = openPlaylistStored === null ? false : openPlaylistStored === "true";
    myScrobblesDisplayMode = localStorage.getItem("sort-play-my-scrobbles-display-mode") || 'number';
    colorSortMode = localStorage.getItem(STORAGE_KEY_COLOR_SORT_MODE) || 'perceptual';
    topTracksLimit = parseInt(localStorage.getItem(STORAGE_KEY_TOP_TRACKS_LIMIT), 10) || 100;
    const storedNewReleases = localStorage.getItem(STORAGE_KEY_NEW_RELEASES_LIMIT);
    if (storedNewReleases) {
        if (storedNewReleases.startsWith('release-')) {
            newReleasesDaysLimit = storedNewReleases;
        } else {
            const intVal = parseInt(storedNewReleases, 10);
            if (intVal === 7) newReleasesDaysLimit = 'release-1';
            else if (intVal === 14) newReleasesDaysLimit = 'release-2';
            else if (intVal === 21) newReleasesDaysLimit = 'release-3';
            else newReleasesDaysLimit = intVal;
        }
    } else {
        newReleasesDaysLimit = 'release-2';
    }
    followedReleasesAlbumLimit = localStorage.getItem(STORAGE_KEY_FOLLOWED_RELEASES_LIMIT) || 'all';
    discoveryPlaylistSize = parseInt(localStorage.getItem(STORAGE_KEY_DISCOVERY_PLAYLIST_SIZE), 10) || 50;
    placePlaylistsInFolder = localStorage.getItem(STORAGE_KEY_PLACE_PLAYLISTS_IN_FOLDER) === "true";
    sortPlayFolderName = localStorage.getItem(STORAGE_KEY_SORT_PLAY_FOLDER_NAME) || "Sort-Play Library";
    const changeTitleOnCreateStored = localStorage.getItem(STORAGE_KEY_CHANGE_TITLE_ON_CREATE);
    changeTitleOnCreate = changeTitleOnCreateStored === null ? false : changeTitleOnCreateStored === "true";
    const changeTitleStored = localStorage.getItem(STORAGE_KEY_CHANGE_TITLE_ON_MODIFY);
    changeTitleOnModify = changeTitleStored === null ? false : changeTitleStored === "true";
    const setDedicatedCoversStored = localStorage.getItem(STORAGE_KEY_SET_DEDICATED_PLAYLIST_COVERS);
    setDedicatedPlaylistCovers = setDedicatedCoversStored === null ? true : setDedicatedCoversStored === "true";
    chatPanelVisible = localStorage.getItem(STORAGE_KEY_CHAT_PANEL_VISIBLE) === "true";
    showLikeButton = localStorage.getItem("sort-play-show-like-button") === "true";
    useEnergyWaveShuffle = localStorage.getItem(STORAGE_KEY_USE_ENERGY_WAVE_SHUFFLE) === "true";
    energyWaveShuffleLimit = parseInt(localStorage.getItem(STORAGE_KEY_ENERGY_WAVE_SHUFFLE_LIMIT), 10) || 6000;
    showNowPlayingData = localStorage.getItem(STORAGE_KEY_SHOW_NOW_PLAYING_DATA) === "true";
    selectedNowPlayingDataType = localStorage.getItem(STORAGE_KEY_NOW_PLAYING_DATA_TYPE) || 'releaseDate';
    selectedNowPlayingDataPosition = localStorage.getItem(STORAGE_KEY_NOW_PLAYING_DATA_POSITION) || '.main-trackInfo-name';
    selectedNowPlayingDateFormat = localStorage.getItem(STORAGE_KEY_NOW_PLAYING_DATA_FORMAT) || 'YYYY';
    selectedNowPlayingPlayCountFormat = localStorage.getItem(STORAGE_KEY_NOW_PLAYING_PLAY_COUNT_FORMAT) || 'raw';
    selectedNowPlayingTempoFormat = localStorage.getItem(STORAGE_KEY_NOW_PLAYING_TEMPO_FORMAT) || 'with_unit';
    selectedNowPlayingEnergyFormat = localStorage.getItem(STORAGE_KEY_NOW_PLAYING_ENERGY_FORMAT) || 'percentage';
    selectedNowPlayingDanceabilityFormat = localStorage.getItem(STORAGE_KEY_NOW_PLAYING_DANCEABILITY_FORMAT) || 'percentage';
    selectedNowPlayingValenceFormat = localStorage.getItem(STORAGE_KEY_NOW_PLAYING_VALENCE_FORMAT) || 'percentage';
    selectedNowPlayingKeyFormat = localStorage.getItem(STORAGE_KEY_NOW_PLAYING_KEY_FORMAT) || 'standard';
    selectedNowPlayingPopularityFormat = localStorage.getItem(STORAGE_KEY_NOW_PLAYING_POPULARITY_FORMAT) || 'raw';
    selectedNowPlayingSeparator = localStorage.getItem(STORAGE_KEY_NOW_PLAYING_SEPARATOR) || 'â€¢';
    includeZeroScrobbles = localStorage.getItem("sort-play-include-no-scrobbles") !== "false";
    lastFmAutocorrect = localStorage.getItem("sort-play-lastfm-autocorrect") === "true";
    showGenreTags = localStorage.getItem(STORAGE_KEY_SHOW_GENRE_TAGS) === "true";
    showGenreTagsNowPlaying = localStorage.getItem(STORAGE_KEY_SHOW_GENRE_TAGS_NP) !== "false";
    showGenreTagsArtistPage = localStorage.getItem(STORAGE_KEY_SHOW_GENRE_TAGS_AP) !== "false";
    genreSourcesNpSpotify = localStorage.getItem(STORAGE_KEY_GENRE_SOURCES_NP_SPOTIFY) !== "false";
    genreSourcesNpLastfm = localStorage.getItem(STORAGE_KEY_GENRE_SOURCES_NP_LASTFM) !== "false";
    genreSourcesNpDeezer = localStorage.getItem(STORAGE_KEY_GENRE_SOURCES_NP_DEEZER) !== "false";
    genreSourcesApSpotify = localStorage.getItem(STORAGE_KEY_GENRE_SOURCES_AP_SPOTIFY) !== "false";
    genreSourcesApLastfm = localStorage.getItem(STORAGE_KEY_GENRE_SOURCES_AP_LASTFM) !== "false";
    useGenrePlaylistDatabase = localStorage.getItem(STORAGE_KEY_USE_GENRE_PLAYLIST_DATABASE) !== "false";

    for (const sortType in sortOrderState) {
        const storedValue = localStorage.getItem(`sort-play-${sortType}-reverse`);
        if (storedValue !== null) {
            sortOrderState[sortType] = storedValue === "true";
        }
    }
  }
  
  function saveSettings() {
    localStorage.setItem("sort-play-show-additional-column", showAdditionalColumn); 
    localStorage.setItem("sort-play-show-second-additional-column", showSecondAdditionalColumn);
    localStorage.setItem("sort-play-show-album-column", showAlbumColumn);
    localStorage.setItem("sort-play-show-artist-column", showArtistColumn); 
    localStorage.setItem("sort-play-selected-column-type", selectedColumnType);
    localStorage.setItem("sort-play-selected-second-column-type", selectedSecondColumnType);
    localStorage.setItem("sort-play-selected-album-column-type", selectedAlbumColumnType);
    localStorage.setItem("sort-play-selected-artist-column-type", selectedArtistColumnType);
    localStorage.setItem("sort-play-release-date-format", releaseDateFormat);
    localStorage.setItem("sort-play-remove-date-added", removeDateAdded);
    localStorage.setItem("sort-play-playlist-deduplicate-v2", playlistDeduplicate);
    localStorage.setItem("sort-play-show-removed-duplicates", showRemovedDuplicates);
    localStorage.setItem("sort-play-include-song-stats", includeSongStats);
    localStorage.setItem("sort-play-include-lyrics", includeLyrics);
    localStorage.setItem("sort-play-ai-model", selectedAiModel);
    localStorage.setItem(STORAGE_KEY_USER_SYSTEM_INSTRUCTION_v2, userSystemInstruction);
    localStorage.setItem("sort-play-match-all-genres", matchAllGenres);
    localStorage.setItem(STORAGE_KEY_ADD_TO_QUEUE, addToQueueEnabled);
    localStorage.setItem(STORAGE_KEY_CREATE_PLAYLIST, createPlaylistAfterSort);
    localStorage.setItem(STORAGE_KEY_SORT_CURRENT_PLAYLIST, sortCurrentPlaylistEnabled);
    localStorage.setItem(STORAGE_KEY_CREATE_PLAYLIST_PRIVATE, createPlaylistPrivate);
    localStorage.setItem(STORAGE_KEY_OPEN_PLAYLIST_AFTER_SORT, openPlaylistAfterSortEnabled);
    localStorage.setItem("sort-play-my-scrobbles-display-mode", myScrobblesDisplayMode);
    localStorage.setItem(STORAGE_KEY_COLOR_SORT_MODE, colorSortMode);
    localStorage.setItem(STORAGE_KEY_TOP_TRACKS_LIMIT, topTracksLimit);
    localStorage.setItem(STORAGE_KEY_NEW_RELEASES_LIMIT, newReleasesDaysLimit);
    localStorage.setItem(STORAGE_KEY_FOLLOWED_RELEASES_LIMIT, followedReleasesAlbumLimit);
    localStorage.setItem(STORAGE_KEY_DISCOVERY_PLAYLIST_SIZE, discoveryPlaylistSize);
    localStorage.setItem(STORAGE_KEY_PLACE_PLAYLISTS_IN_FOLDER, placePlaylistsInFolder);
    localStorage.setItem(STORAGE_KEY_SORT_PLAY_FOLDER_NAME, sortPlayFolderName);
    localStorage.setItem(STORAGE_KEY_CHANGE_TITLE_ON_CREATE, changeTitleOnCreate);
    localStorage.setItem(STORAGE_KEY_CHANGE_TITLE_ON_MODIFY, changeTitleOnModify);
    localStorage.setItem(STORAGE_KEY_SET_DEDICATED_PLAYLIST_COVERS, setDedicatedPlaylistCovers);
    localStorage.setItem(STORAGE_KEY_CHAT_PANEL_VISIBLE, chatPanelVisible);
    localStorage.setItem("sort-play-show-like-button", showLikeButton);
    localStorage.setItem(STORAGE_KEY_USE_ENERGY_WAVE_SHUFFLE, useEnergyWaveShuffle);
    localStorage.setItem(STORAGE_KEY_ENERGY_WAVE_SHUFFLE_LIMIT, energyWaveShuffleLimit);
    localStorage.setItem(STORAGE_KEY_SHOW_NOW_PLAYING_DATA, showNowPlayingData);
    localStorage.setItem(STORAGE_KEY_NOW_PLAYING_DATA_TYPE, selectedNowPlayingDataType);
    localStorage.setItem(STORAGE_KEY_NOW_PLAYING_DATA_POSITION, selectedNowPlayingDataPosition);
    localStorage.setItem(STORAGE_KEY_NOW_PLAYING_DATA_FORMAT, selectedNowPlayingDateFormat);
    localStorage.setItem(STORAGE_KEY_NOW_PLAYING_PLAY_COUNT_FORMAT, selectedNowPlayingPlayCountFormat);
    localStorage.setItem(STORAGE_KEY_NOW_PLAYING_TEMPO_FORMAT, selectedNowPlayingTempoFormat);
    localStorage.setItem(STORAGE_KEY_NOW_PLAYING_ENERGY_FORMAT, selectedNowPlayingEnergyFormat);
    localStorage.setItem(STORAGE_KEY_NOW_PLAYING_DANCEABILITY_FORMAT, selectedNowPlayingDanceabilityFormat);
    localStorage.setItem(STORAGE_KEY_NOW_PLAYING_VALENCE_FORMAT, selectedNowPlayingValenceFormat);
    localStorage.setItem(STORAGE_KEY_NOW_PLAYING_KEY_FORMAT, selectedNowPlayingKeyFormat);
    localStorage.setItem(STORAGE_KEY_NOW_PLAYING_POPULARITY_FORMAT, selectedNowPlayingPopularityFormat);
    localStorage.setItem(STORAGE_KEY_NOW_PLAYING_SEPARATOR, selectedNowPlayingSeparator);
    localStorage.setItem("sort-play-include-no-scrobbles", includeZeroScrobbles);
    localStorage.setItem("sort-play-lastfm-autocorrect", lastFmAutocorrect);
    localStorage.setItem(STORAGE_KEY_SHOW_GENRE_TAGS, showGenreTags);
    localStorage.setItem(STORAGE_KEY_SHOW_GENRE_TAGS_NP, showGenreTagsNowPlaying);
    localStorage.setItem(STORAGE_KEY_SHOW_GENRE_TAGS_AP, showGenreTagsArtistPage);
    localStorage.setItem(STORAGE_KEY_GENRE_SOURCES_NP_SPOTIFY, genreSourcesNpSpotify);
    localStorage.setItem(STORAGE_KEY_GENRE_SOURCES_NP_LASTFM, genreSourcesNpLastfm);
    localStorage.setItem(STORAGE_KEY_GENRE_SOURCES_NP_DEEZER, genreSourcesNpDeezer);
    localStorage.setItem(STORAGE_KEY_GENRE_SOURCES_AP_SPOTIFY, genreSourcesApSpotify);
    localStorage.setItem(STORAGE_KEY_GENRE_SOURCES_AP_LASTFM, genreSourcesApLastfm);
    localStorage.setItem(STORAGE_KEY_USE_GENRE_PLAYLIST_DATABASE, useGenrePlaylistDatabase);

    for (const sortType in sortOrderState) {
      localStorage.setItem(`sort-play-${sortType}-reverse`, sortOrderState[sortType]);
    }
  }

  function tagActiveModalWithFontScope() {
    setTimeout(() => {
      const modalContainer = document.querySelector(".main-popupModal-container");
      if (modalContainer) {
        modalContainer.classList.add('sort-play-font-scope');
      }
    }, 50);
  }
  
  async function loadColorThief() {
    if (colorThiefLib) {
        return colorThiefLib;
    }
    try {
        const response = await fetch("https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js");
        const scriptText = await response.text();
        const getLibrary = new Function('exports', 'module', `(function(exports, module) { ${scriptText} }).call(this, exports, module); return module.exports || this.ColorThief;`);
        colorThiefLib = getLibrary({}, {});
        if (!colorThiefLib) {
            throw new Error('ColorThief constructor not found in loaded script');
        }
        return colorThiefLib;
    } catch (error) {
        console.error('Error loading ColorThief library:', error);
        throw error;
    }
  }

  try {
    await loadColorThief();
  } catch (error) {
      console.error("Failed to load Color Thief library, color sorting will not be available.", error);
  }

  function normalizeArtistNames(artists) {
    if (!artists || artists.length === 0) return "Unknown Artist";
    
    const firstArtistName = artists[0].name || "";
    
    if (firstArtistName.includes(';')) {
        const uniqueArtists = [...new Set(firstArtistName.split(';').map(a => a.trim()))];
        return uniqueArtists.join(', ');
    }

    return artists.map(artist => artist.name).join(", ");
  }

  const AI_DATA_CACHE_VERSION = '1';
  const AI_DATA_CACHE_KEY_PREFIX = `sort-play-playlist-cache-v${AI_DATA_CACHE_VERSION}-`;
  
  function getCacheKey(trackId, includeSongStats, includeLyrics, selectedAiModel) {
    return `${AI_DATA_CACHE_KEY_PREFIX}${trackId}-stats${includeSongStats}-lyrics${includeLyrics}-model${selectedAiModel}`;
  }
  
  async function getTrackCache(trackId, includeSongStats, includeLyrics, selectedAiModel) {
    const cacheKey = getCacheKey(trackId, includeSongStats, includeLyrics, selectedAiModel);
    return await idb.get('aiData', cacheKey, CACHE_EXPIRE_AI_DATA);
  }
  async function setTrackCache(trackId, trackData, includeSongStats, includeLyrics, selectedAiModel) {
    const cacheKey = getCacheKey(trackId, includeSongStats, includeLyrics, selectedAiModel);
    await idb.set('aiData', cacheKey, trackData);
  }
  
  async function loadGoogleAI() {
    if (googleAiSdk) {
      return googleAiSdk;
    }
    
    try {
      const sdkModule = await import("https://cdn.jsdelivr.net/npm/@google/genai@1.20.0/+esm");
      
      googleAiSdk = sdkModule.GoogleGenAI; 
      if (!googleAiSdk) {
        throw new Error('GoogleGenAI constructor not found in loaded SDK module');
      }
      
      return googleAiSdk;
    } catch (error) {
      console.error('Error loading Google Gen AI SDK:', error);
      throw error;
    }
  }
  
  try {
    await loadGoogleAI();
  } catch (error) {
    console.error("Failed to load Google AI SDK:", error);
  }

  
  function saveLastFmUsername(username) {
    localStorage.setItem(STORAGE_KEY_LASTFM_USERNAME, username);
  }

  function loadLastFmUsername() {
    return localStorage.getItem(STORAGE_KEY_LASTFM_USERNAME);
  }

  function showLastFmUsernameModal(onSuccess = null) {
    const savedUsername = loadLastFmUsername();

    const overlay = document.createElement("div");
    overlay.id = "sort-play-lastfm-modal-overlay";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.7); z-index: 2005;
        display: flex; justify-content: center; align-items: center;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container sort-play-font-scope";
    modalContainer.style.cssText = `
        width: 420px !important;
        border-radius: 30px;
        overflow: hidden; 
        background-color: #181818 !important;
        border: 2px solid #282828;
        display: flex;
        flex-direction: column;
    `;

    modalContainer.innerHTML = `
      <div class="main-trackCreditsModal-header" style="padding: 27px 32px 12px !important;">
          <h1 class="main-trackCreditsModal-title"><span style='font-size: 25px;'>Last.fm Username</span></h1>
      </div>
      <div class="main-trackCreditsModal-originalCredits" style="padding: 25px 32px 20px 32px !important;">
          <div style="display: flex; flex-direction: column; gap: 15px;">
            <div style="display: flex; flex-direction: column; gap: 5px;">
              <input type="text" id="lastFmUsername" value="${savedUsername || ""}" placeholder="Enter your username"
                    style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #282828; background: #282828; color: white;">
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 5px;">
              <button id="cancelLastFm" class="main-buttons-button" 
                      style="width: 83px; padding: 8px 16px; border-radius: 20px; border: none; cursor: pointer; background-color: #333333; color: white; font-weight: 550; font-size: 13px; text-transform: uppercase; transition: all 0.04s ease;">
                Cancel
              </button>
              <button id="saveLastFm" class="main-buttons-button main-button-primary" 
                      style="padding: 8px 18px; border-radius: 20px; border: none; cursor: pointer; background-color: #1ED760; color: black; font-weight: 550; font-size: 13px; text-transform: uppercase; transition: all 0.04s ease;">
                Save
              </button>
            </div>
          </div>
      </div>
    `;
    
    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);
    
    const inputField = document.getElementById("lastFmUsername");
    inputField.focus();

    const closeModal = () => overlay.remove();

    const saveButton = document.getElementById("saveLastFm");
    const cancelButton = document.getElementById("cancelLastFm");

    saveButton.addEventListener("mouseenter", () => { saveButton.style.backgroundColor = "#3BE377"; });
    saveButton.addEventListener("mouseleave", () => { saveButton.style.backgroundColor = "#1ED760"; });
    cancelButton.addEventListener("mouseenter", () => { cancelButton.style.backgroundColor = "#444444"; });
    cancelButton.addEventListener("mouseleave", () => { cancelButton.style.backgroundColor = "#333333"; });

    function resetMenuButtonStyles() {
      const myScrobblesButton = menuButtons.find(
        (button) => button.querySelector("span")?.innerText === "My Scrobbles"
      );
      if (myScrobblesButton) {
        const innerSvg = myScrobblesButton.querySelector("svg");
        if (innerSvg) {
          innerSvg.style.fill = "#ffffffe6";
        }
      }
    }

    saveButton.addEventListener("click", () => {
      const username = inputField.value.trim();

      saveButton.disabled = true;
      saveButton.style.backgroundColor = "#FFFFFFB3";
      saveButton.textContent = "Saving...";

      saveLastFmUsername(username);
      
      resetMenuButtonStyles();
      
      if (username) {
        showNotification("Last.fm username saved successfully!");
      } else {
        showNotification("Last.fm username cleared.");
      }

      closeModal();
      if (onSuccess) onSuccess();
    });

    cancelButton.addEventListener("click", closeModal);
    overlay.addEventListener("click", (e) => { if (e.target === overlay) closeModal(); });
  }

  function createAndInitializeChatPanel() {
    let chatPanel = document.getElementById('sort-play-chat-panel');
    if (chatPanel) {
        return chatPanel;
    }

    chatPanel = document.createElement('div');
    chatPanel.id = 'sort-play-chat-panel';

    const iframe = document.createElement('iframe');
    iframe.id = 'chattable';
    iframe.src = 'https://iframe.chat/embed/alternate/?chat=sortplay';
    iframe.frameBorder = 'none';

    const customChatCSS = `
        body {
           background-color: #181818;
           background-size: 100% 100%;
           color: #1db954;
        }
        .msgWrapper {
           display: flex;
           flex-wrap: wrap;
           width: 100%;
           align-items: center;
        }
        .msgWrapper:has(.received) {
           justify-content: flex-start;
        }
        .msgWrapper:has(.sent) {
           justify-content: flex-end;
        }
        .allMessages {
           font-family: Helvetica, sans-serif;
           font-size: 10pt;
           margin: 5px;
           display: inline-block;
           position: relative;
           min-width: 25vw;
           max-width: 80vw;
           backdrop-filter: blur(7px);
           -webkit-backdrop-filter: blur(7px);
        }
        .allMessages:hover {
           color: #1db954;
        }
        #background:lastChild {
          margin-bottom: 20px;
        }
        .sent {
           border-radius: 20px 20px 0 20px;
           background-color: rgba(35,35, 35, 0.3);
           color: #a0e0b8;
        }
        .recieved {
           border-radius: 10px 10px 10px 0;
           background-color: rgba(30, 215, 96, 0.15);
           color: #a0e0b8;
        }
        blockquote {
           background-color: #333;
           color: #FFF;
           opacity: 0.75;
           border-right: solid 2px #AAA;
        }
        #background {
           scrollbar-color: #1db954 transparent;
           padding-top: 10px;
           height: calc(100% - 108px)
        }
        #input, #nameEntry {
           background-color: rgba(0, 0, 0, 0.5);
           color: #1db954;
           min-height: 25px;
           backdrop-filter: blur(7px);
           -webkit-backdrop-filter: blur(7px);
        }
        #input:empty::before {
          color: #1a6333;
        }
        .owner, .mod {
           background-color: transparent;
           border: 1px solid #1db954;
           background-size: 100% 100%;
           border-radius: 50%;
        }
        #top_banner {
          background: #1db954;
          text-align: center;
        }
        #top_banner a {
            font-size: 0;
            text-decoration: none;
        }
        #top_banner a::after {
            content: 'Sort Play Chat';
            font-size: 14pt;
            color: #181818;
            font-family: sans-serif;
            font-weight: 700;
        }
        #loadMore {
          color: #1db954;
          font-size: 10pt;
          font-family: Verdana;
        }
        #loadMore:hover {
          font-size: 12pt;
        }
        #settingsWrapper {
          background-color: #1db954;
        }
        .ctxMenuOption {
          background-color: transparent !important;
          color: #1db954;
        }
        .ctxMenuOption:hover {
          background-color: rgba(255, 255, 255, 0.25) !important;
        }
        #ctxMenu {
          backdrop-filter: blur(7px);
          -webkit-backdrop-filter: blur(7px);
          background-color: rgba(0, 0, 0, 0.5) !important;
        }
        #timestamp {
          display: flex;
          align-items: center;
          width: calc(100% - 10px);
          font-size: 8pt;
        }
        .sent + #timestamp {
          justify-content: flex-end;
          padding-right: 10px;
        }
        .recieved + #timestamp {
          justify-content: flex-start;
          padding-left: 10px;
        }
        .msgBody {
          padding: 5px 7px 7px 7px;
        }
        .msgBody a {
          color: #1db954 !important;
        }
        :where(#emojiTrayToggle) {
          background-color: #1db954;
        }
        #emojiTray {
          background-color: rgba(30, 215, 96, 0.5);
          color: #000;
          border-color: #1db954;
          backdrop-filter: blur(5px);
        }
        #settingsMenu hr {
          height: 1px;
          width: 100%;
          border: none;
          background: #1db954;
        }
        #settingsMenu input[type=text] {
          border: none;
          outline: none !important;
          border-bottom: solid 1px #1db954;
          color: #1db954;
          background-color: rgba(0, 0, 0, 0.3);
          backdrop-filter: blur(10px);
          padding: 3px;
        }
        #save {
          border: solid 1px #1db954;
          background-color: transparent;
          display: flex;
          align-items: center;
          justify-content: center;
          color: #1db954;
          padding: 10px;
          font-size: 12pt;
          backdrop-filter: blur(10px);
          cursor: pointer;
          border-radius: 3px;
        }
        #is_typing {
          background-color: transparent;
          height: 15px;
          border: solid 1px #1db954;
          border-radius: 8px;
          backdrop-filter: blur(2px);
        }
        #is_typing > span {
          background-color: #1db954;
        }
    `;

    iframe.onload = () => {
        iframe.contentWindow.postMessage(customChatCSS, "*");
    };

    chatPanel.appendChild(iframe);
    document.body.appendChild(chatPanel);

    return chatPanel;
  }

  function toggleChatPanel() {
    const liveChatBtn = document.querySelector("#liveChatBtn");
    chatPanelVisible = !chatPanelVisible;

    if (chatPanelVisible) {
        const chatPanel = createAndInitializeChatPanel();
        positionChatPanel(chatPanel);
        setTimeout(() => chatPanel.classList.add('visible'), 10);
        if (liveChatBtn) liveChatBtn.classList.add('active');
    } else {
        let chatPanel = document.getElementById('sort-play-chat-panel');
        if (chatPanel) {
            chatPanel.classList.remove('visible');
            setTimeout(() => {
                if (chatPanel) chatPanel.remove();
            }, 200);
        }
        if (liveChatBtn) liveChatBtn.classList.remove('active');
    }
  }

  function positionChatPanel(chatPanel) {
    if (!chatPanel) return;
    const settingsModal = document.querySelector(".GenericModal > .main-embedWidgetGenerator-container") || document.querySelector(".sort-play-settings");
    if (!settingsModal) return;

    const modalRect = settingsModal.getBoundingClientRect();
    const panelHeight = chatPanel.offsetHeight;
    const panelWidth = chatPanel.offsetWidth;
    const gap = 10;

    let top = modalRect.bottom - panelHeight - 2;
    let left = modalRect.right + gap;

    if (left + panelWidth > window.innerWidth - gap) {
        left = modalRect.left - panelWidth - gap;
    }
    if (top < gap) {
        top = gap;
    }

    chatPanel.style.top = `${top}px`;
    chatPanel.style.left = `${left}px`;
  }

  const liveChatIconSVG = `
  <svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M19.4003 18C19.7837 17.2499 20 16.4002 20 15.5C20 12.4624 17.5376 10 14.5 10C11.4624 10 9 12.4624 9 15.5C9 18.5376 11.4624 21 14.5 21L21 21C21 21 20 20 19.4143 18.0292M18.85 12C18.9484 11.5153 19 11.0137 19 10.5C19 6.35786 15.6421 3 11.5 3C7.35786 3 4 6.35786 4 10.5C4 11.3766 4.15039 12.2181 4.42676 13C5.50098 16.0117 3 18 3 18H9.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;

  const coffeeIconSVG = `
  <svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M18.5 7H19C19.4647 7 19.697 7 19.8902 7.03843C20.6836 7.19624 21.3038 7.81644 21.4616 8.60982C21.5 8.80302 21.5 9.03535 21.5 9.5C21.5 9.96465 21.5 10.197 21.4616 10.3902C21.3038 11.1836 20.6836 11.8038 19.8902 11.9616C19.697 12 19.4647 12 19 12H18.5M3 20H21M12 17C10.6055 17 9.90821 17 9.33277 16.8619C7.50453 16.4229 6.07707 14.9955 5.63815 13.1672C5.5 12.5918 5.5 11.8945 5.5 10.5L5.5 7.2C5.5 6.0799 5.5 5.51984 5.71799 5.09202C5.90973 4.7157 6.21569 4.40974 6.59202 4.21799C7.01984 4 7.57989 4 8.7 4L15.3 4C16.4201 4 16.9802 4 17.408 4.21799C17.7843 4.40973 18.0903 4.71569 18.282 5.09202C18.5 5.51984 18.5 6.07989 18.5 7.2V10.5C18.5 11.8945 18.5 12.5918 18.3619 13.1672C17.9229 14.9955 16.4955 16.4229 14.6672 16.8619C14.0918 17 13.3945 17 12 17Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;

  const copyIconSVG = `<svg width="16px" height="16px" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" fill="none"><path fill="currentColor" fill-rule="evenodd" d="M4 2a2 2 0 00-2 2v9a2 2 0 002 2h2v2a2 2 0 002 2h9a2 2 0 002-2V8a2 2 0 00-2-2h-2V4a2 2 0 00-2-2H4zm9 4V4H4v9h2V8a2 2 0 012-2h5zM8 8h9v9H8V8z"/></svg>`;

  const arrowRightIconSVG = `<svg width="24px" height="24px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13.2328 16.4569C12.9328 16.7426 12.9212 17.2173 13.2069 17.5172C13.4926 17.8172 13.9673 17.8288 14.2672 17.5431L13.2328 16.4569ZM19.5172 12.5431C19.8172 12.2574 19.8288 11.7827 19.5431 11.4828C19.2574 11.1828 18.7827 11.1712 18.4828 11.4569L19.5172 12.5431ZM18.4828 12.5431C18.7827 12.8288 19.2574 12.8172 19.5431 12.5172C19.8288 12.2173 19.8172 11.7426 19.5172 11.4569L18.4828 12.5431ZM14.2672 6.4569C13.9673 6.17123 13.4926 6.18281 13.2069 6.48276C12.9212 6.78271 12.9328 7.25744 13.2328 7.5431L14.2672 6.4569ZM19 12.75C19.4142 12.75 19.75 12.4142 19.75 12C19.75 11.5858 19.4142 11.25 19 11.25V12.75ZM5 11.25C4.58579 11.25 4.25 11.5858 4.25 12C4.25 12.4142 4.58579 12.75 5 12.75V11.25ZM14.2672 17.5431L19.5172 12.5431L18.4828 11.4569L13.2328 16.4569L14.2672 17.5431ZM19.5172 11.4569L14.2672 6.4569L13.2328 7.5431L18.4828 12.5431L19.5172 11.4569ZM19 11.25L5 11.25V12.75L19 12.75V11.25Z" fill="currentColor"/></svg>`;

  function showSettingsModal() {
    const overlay = document.createElement("div");
    overlay.id = "sort-play-settings-overlay";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        z-index: 2002;
        display: flex; justify-content: center; align-items: center;
        opacity: 0;
        transition: opacity 0.2s ease;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container sort-play-settings sort-play-font-scope";
    modalContainer.style.cssText = `
        width: 550px !important;
        border-radius: 30px;
        overflow: hidden;
        border: 2px solid #282828;
        background-color: #181818 !important;
        display: flex; 
        flex-direction: column;
        max-height: 90vh;
        z-index: 2003;
    `;

    const closeModal = () => {
        overlay.style.opacity = "0";
        setTimeout(() => overlay.remove(), 200);
    };

    overlay.addEventListener("click", (e) => {
        if (e.target === overlay) closeModal();
    });

    const headerHtml = `
      <div class="main-trackCreditsModal-header" style="padding: 29px 32px 19px 32px !important; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center;">
          <h1 class="main-trackCreditsModal-title"><span style='font-size: 30px; color: white;'>Sort-Play Settings <span class='version-tag'>v${SORT_PLAY_VERSION}</span></span></h1>
          <button class="main-trackCreditsModal-closeBtn" id="closeSettingsModal" aria-label="Close" style="background: transparent; border: 0; padding: 0; color: #b3b3b3; cursor: pointer; display: flex; align-items: center;">
            <svg width="20" height="20" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M31.098 29.794L16.955 15.65 31.097 1.51 29.683.093 15.54 14.237 1.4.094-.016 1.508 14.126 15.65-.016 29.795l1.414 1.414L15.54 17.065l14.144 14.143" fill="currentColor" fill-rule="evenodd"></path></svg>
          </button>
      </div>
    `;

    modalContainer.innerHTML = `
    <style>
    .main-trackCreditsModal-mainSection {
      overflow-y: auto !important; 
      padding: 16px 45px 16px 45px;
      flex-grow: 1; 
       scrollbar-width: thin;
       scrollbar-color: #333333 #181818;
    }
    .main-trackCreditsModal-mainSection::-webkit-scrollbar {
        width: 8px;
    }
    .main-trackCreditsModal-mainSection::-webkit-scrollbar-track {
        background: #282828;
        border-radius: 4px;
    }
    .main-trackCreditsModal-mainSection::-webkit-scrollbar-thumb {
        background-color: #5a5a5a;
        border-radius: 4px;
    }
    .main-trackCreditsModal-mainSection::-webkit-scrollbar-thumb:hover {
        background-color: #7a7a7a;
    }
    .sort-play-settings-footer {
        flex-shrink: 0;
        padding: 10px 25px 12px 25px; 
        background-color: #181818; 
        border-top: 1px solid #282828;
        display: flex;
        justify-content: center; 
        align-items: center;
        position: relative;
    }
    .sort-play-settings-footer .live-chat-button {
        position: absolute;
        right: 25px;
    }
    .sort-play-settings-footer .support-me-button {
        position: absolute;
        left: 25px;
    }
    .sort-play-settings-footer .github-link-container a {
        color: #1ED760;
        font-size: 14px;
        text-decoration: none;
    }
    .footer-icon-button {
        background: none;
        border: none;
        cursor: pointer;
        padding: 0;
        color: white;
        display: flex;
        align-items: center;
        transition: color 0.1s ease-in-out;
    }
    .footer-icon-button.active {
        color: #1ED760;
    }
    .footer-icon-button:hover {
        color: #1ED760;
    }
    #sort-play-chat-panel {
        position: fixed;
        width: 380px;
        height: 60vh;
        max-height: 600px;
        background-color: #181818;
        border: 2px solid #282828;
        border-radius: 15px;
        z-index: 9999;
        opacity: 0;
        transform: translateY(20px);
        transition: transform 0.2s ease-in-out, opacity 0.05s ease-in-out;
        display: flex;
        flex-direction: column;
        box-shadow: 0 16px 24px rgba(0,0,0,.3), 0 6px 8px rgba(0,0,0,.2);
        pointer-events: none;
    }
    #sort-play-chat-panel.visible {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
    }
    #sort-play-chat-panel iframe {
        width: 100%;
        height: 100%;
        border: none;
        border-radius: 13px;
    }
    .sort-play-settings .col {
        padding: 0;
    }
    .sort-play-settings .setting-row::after {
        content: "";
        display: table;
        clear: both;
    }
    .sort-play-settings .setting-row {
        padding: 5px 0;
        align-items: center;
    }
    .sort-play-settings .setting-row .col.description {
        float: left;
        padding-right: 15px;
        width: auto;
        color: #c1c1c1;
        font-family: 'SpotifyMixUI' !important;
    }
    .sort-play-settings .setting-row .col.action {
      display: flex;  
      float: right;
      align-items: center;
      justify-content: flex-end;
      text-align: right;
      gap: 8px;
      position: relative;
    }
    .sort-play-settings select {
        padding: 2px 8px;
        border-radius: 15px;
        border: 1px solid #434343;
        background: #282828;
        color: white;
        cursor: pointer;
        font-size: 13px;
        max-width: 120px;
    }
    .sort-play-settings select.column-type-select {
        flex-grow: 1;
        margin-right: 10px;
        width: 120px;
    }
    .sort-play-settings select:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .column-settings-button {
        background: none; border: none; margin: 0; cursor: pointer; display: flex;
        align-items: center; justify-content: center; width: 24px; height: 24px;
        opacity: 0.7; transition: opacity 0.2s;
    }
    .column-settings-button:hover { opacity: 1; }
    .column-settings-button svg { width: 16px; height: 16px; fill: #b3b3b3; }
    .column-settings-button:hover svg { fill: #ffffff; }
    .column-settings-button:disabled { opacity: 0.3; cursor: not-allowed; }
    .column-settings-dropdown {
        display: none; position: absolute; background-color: #282828; min-width: 140px;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 1001; border-radius: 4px;
        padding: 4px 0; left: -55px;
        overflow-y: auto;
        scrollbar-width: thin; 
        scrollbar-color: #555 #282828;
    }
    .column-settings-dropdown::-webkit-scrollbar { width: 8px; }
    .column-settings-dropdown::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.1); border-radius: 4px; }
    .column-settings-dropdown::-webkit-scrollbar-thumb { background-color: #555; border-radius: 4px; border: 2px solid #282828; }
    .column-settings-dropdown::-webkit-scrollbar-thumb:hover { background-color: #777; }
    .column-settings-dropdown button {
        color: #b3b3b3; padding: 6px 12px; text-decoration: none; display: block;
        width: 100%; text-align: left; background: none; border: none; cursor: pointer;
        font-size: 13px;
    }
    .column-settings-dropdown button:hover { background-color: rgba(255, 255, 255, 0.1); color: #ffffff; }
    .column-settings-dropdown button.selected { color: #1ed760; background-color: rgba(30, 215, 96, 0.1); }

    .sort-play-settings .setting-row#githubLink {
        display: flex;
        justify-content: center;
        margin-top: 5px;
    }

    .sort-play-settings .setting-row#githubLink .col.description {
        float: none;
        text-align: center;
        width: auto;
        padding: 0;
    }

    .sort-play-settings .switch {
        position: relative; display: inline-block; width: 40px; height: 24px; flex-shrink: 0;
    }
    .sort-play-settings .switch input { opacity: 0; width: 0; height: 0; }
    .sort-play-settings .sliderx {
        position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
        background-color: #484848; border-radius: 24px; transition: .2s;
    }
    .sort-play-settings .sliderx:before {
        position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
        background-color: white; border-radius: 50%; transition: .2s;
    }
    .sort-play-settings input:checked + .sliderx { background-color: #1DB954; }
    .sort-play-settings input:checked + .sliderx:before { transform: translateX(16px); }
    .sort-play-settings .switch.disabled .sliderx { opacity: 0.5; cursor: not-allowed; }

    .tooltip-container { position: relative; display: inline-block; vertical-align: middle;}

    .custom-tooltip {
        visibility: hidden; position: absolute; z-index: 1; background-color: #373737;
        color: white; padding: 8px 12px; border-radius: 4px; font-size: 14px;
        max-width: 240px; width: max-content; bottom: 100%; left: 50%;
        transform: translateX(-50%); margin-bottom: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        line-height: 1.4; word-wrap: break-word;
    }
    .custom-tooltip::after {
        content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px;
        border-width: 5px; border-style: solid; border-color: #373737 transparent transparent transparent;
    }
    .tooltip-container:hover .custom-tooltip { visibility: visible; }
    .version-tag { font-size: 14px; color: #888; margin-left: 12px; vertical-align: middle; }
    .sort-play-settings .switch.disabled .sliderx { opacity: 0.5; cursor: not-allowed; }
     .sort-play-settings .github-link-container {
      display: flex;
      justify-content: center;
      margin-top: 10px;
      padding-bottom: 10px;
    }
    .sort-play-settings .github-link-container a {
        color: #1ED760;
        font-size: 14px;
        text-decoration: none;
    }
    .main-trackCreditsModal-closeBtn:hover { 
        color: #ffffff; 
    }
    </style>
    ${headerHtml}
    <div class="main-trackCreditsModal-mainSection">
    <div style="display: flex; flex-direction: column; gap: 8px;">

    <div style="color: white; font-weight: bold; font-size: 18px; margin-top: 8px;">
        Credentials
    </div>
    <div style="border-bottom: 1px solid #555; margin-top: -3px;"></div>
        <div style="display: flex; gap: 16px; justify-content: flex-start; margin-top: 8px;">
        <button id="setLastFmUsername" class="main-buttons-button"
                style="padding: 4px 16px; height: 32px; border-radius: 20px; border: none; cursor: pointer; background-color: #333333; color: white; font-weight: 550; font-size: 13px; text-transform: uppercase; transition: all 0.04s ease;">
          Set Last.fm Username
        </button>
        <button id="setGeminiApiKey" class="main-buttons-button"
                style="padding: 4px 16px; height: 32px; border-radius: 20px; border: none; cursor: pointer; background-color: #333333; color: white; font-weight: 550; font-size: 13px; text-transform: uppercase; transition: all 0.04s ease;">
          Set Gemini API Key
        </button>
    </div>

    <div style="color: white; font-weight: bold; font-size: 18px; margin-top: 10px;">
        Sorting Behavior
    </div>
    <div style="border-bottom: 1px solid #555; margin-top: -3px;"></div>

    <div class="setting-row" id="addToQueueSetting">
        <label class="col description">
            Add Sorted Tracks to Queue
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Adds tracks to queue after direct sorts (Play Count, Popularity, Scrobbles, Shuffle, etc.).<br>Filters & AI Pick excluded.</span>
            </span>
        </label>
        <div class="col action">
            <label class="switch">
                <input type="checkbox" id="addToQueueToggle" ${addToQueueEnabled ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>

    <div class="setting-row" id="createPlaylistSettingRow">
        <label class="col description">
            Create Playlist After Sorting
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Creates a new playlist with the sorted tracks. Applies only when sorting directly (not using filters or AI).</span>
            </span>
        </label>
        <div class="col action"><label class="switch" id="createPlaylistSwitchLabel">
                <input type="checkbox" id="createPlaylistToggle" ${createPlaylistAfterSort ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>

    <div class="setting-row" id="sortCurrentPlaylistSettingRow">
        <label class="col description">
            Modify Current Playlist
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Sorts your owned playlist directly instead of creating a new one.</span>
            </span>
        </label>
        <div class="col action">
            <label class="switch" id="sortCurrentPlaylistSwitchLabel">
                <input type="checkbox" id="sortCurrentPlaylistToggle" ${sortCurrentPlaylistEnabled ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>
    
    <div class="setting-row" id="openPlaylistAfterSortSettingRow">
        <label class="col description">
            Open Playlist After Creation
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Automatically navigates to the newly created or modified playlist.</span>
            </span>
        </label>
        <div class="col action">
            <label class="switch" id="openPlaylistAfterSortSwitchLabel">
                <input type="checkbox" id="openPlaylistAfterSortToggle" ${openPlaylistAfterSortEnabled ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>

    <div class="setting-row" id="placePlaylistsInFolderSettingRow">
        <label class="col description">
            Place Playlists in Folder
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Automatically place all created playlists inside a dedicated folder named "${sortPlayFolderName}".</span>
            </span>
        </label>
        <div class="col action">
            <button id="folderNameSettingsBtn" class="column-settings-button" title="Customize Folder Name">
                ${settingsSvg}
            </button>
            <label class="switch" id="placePlaylistsInFolderSwitchLabel">
                <input type="checkbox" id="placePlaylistsInFolderToggle" ${placePlaylistsInFolder ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>

    <div class="setting-row" id="useEnergyWaveShuffleSettingRow">
        <label class="col description">
            Shuffle with Vibe & Flow
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Creates a dynamic listening journey by arranging shuffled tracks based on their energy and mood.</span>
            </span>
        </label>
        <div class="col action">
            <button id="energyWaveSettingsBtn" class="column-settings-button" title="Configure Vibe & Flow">
                ${settingsSvg}
            </button>
            <label class="switch" id="useEnergyWaveShuffleSwitchLabel">
                <input type="checkbox" id="useEnergyWaveShuffleToggle" ${useEnergyWaveShuffle ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>

    <div class="setting-row" id="colorSortModeSetting">
        <label class="col description">
            Color Sort Mode
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">"Perceptual" groups black & white albums first.<br>"Hue Gradient" creates a pure rainbow effect.</span>
            </span>
        </label>
        <div class="col action">
            <select id="colorSortModeSelect" style="max-width: 180px;">
                <option value="perceptual" ${colorSortMode === 'perceptual' ? 'selected' : ''}>Perceptual</option>
                <option value="hue_gradient" ${colorSortMode === 'hue_gradient' ? 'selected' : ''}>Hue Gradient</option>
            </select>
        </div>
    </div>

    <div style="color: white; font-weight: bold; font-size: 18px; margin-top: 10px;">
        Column Settings
    </div>
    <div style="border-bottom: 1px solid #555; margin-top: -3px;"></div>

    <div class="setting-row" id="additionalColumnSetting">
        <label class="col description">
          Playlist Extra Column
        </label>
        <div class="col action" style="position: relative;">
            <button id="dateFormatSettingsBtn" class="column-settings-button" title="Release Date Format Settings" style="display: none;">
                ${settingsSvg}
            </button>
            <button id="myScrobblesSettingsBtn" class="column-settings-button" title="My Scrobbles Display Settings" style="display: none;">
                ${settingsSvg}
            </button>
            <select id="columnTypeSelect" class="column-type-select" ${!showAdditionalColumn ? 'disabled' : ''}>
                <option value="playCount" ${selectedColumnType === 'playCount' ? 'selected' : ''}>Play Count</option>
                <option value="popularity" ${selectedColumnType === 'popularity' ? 'selected' : ''}>Popularity</option>
                <option value="releaseDate" ${selectedColumnType === 'releaseDate' ? 'selected' : ''}>Release Date</option>
                <option value="scrobbles" ${selectedColumnType === 'scrobbles' ? 'selected' : ''}>Scrobbles</option>
                <option value="personalScrobbles" ${selectedColumnType === 'personalScrobbles' ? 'selected' : ''}>My Scrobbles</option>
                <option value="djInfo" ${selectedColumnType === 'djInfo' ? 'selected' : ''}>DJ Info</option>
                <option value="key" ${selectedColumnType === 'key' ? 'selected' : ''}>Key</option>
                <option value="tempo" ${selectedColumnType === 'tempo' ? 'selected' : ''}>Tempo (BPM)</option>
                <option value="energy" ${selectedColumnType === 'energy' ? 'selected' : ''}>Energy</option>
                <option value="danceability" ${selectedColumnType === 'danceability' ? 'selected' : ''}>Danceability</option>
                <option value="valence" ${selectedColumnType === 'valence' ? 'selected' : ''}>Valence</option>
            </select>
            <label class="switch">
                <input type="checkbox" id="showAdditionalColumnToggle" ${showAdditionalColumn ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
            <div id="dateFormatDropdownContainer" class="column-settings-dropdown">
                <button data-format="YYYY-MM-DD" class="${releaseDateFormat === 'YYYY-MM-DD' ? 'selected' : ''}">YYYY-MM-DD</button>
                <button data-format="MM-DD-YYYY" class="${releaseDateFormat === 'MM-DD-YYYY' ? 'selected' : ''}">MM-DD-YYYY</button>
                <button data-format="DD-MM-YYYY" class="${releaseDateFormat === 'DD-MM-YYYY' ? 'selected' : ''}">DD-MM-YYYY</button>
                <button data-format="MMM D, YYYY" class="${releaseDateFormat === 'MMM D, YYYY' ? 'selected' : ''}">Month D, YYYY</button>
                <button data-format="D MMM, YYYY" class="${releaseDateFormat === 'D MMM, YYYY' ? 'selected' : ''}">D Month, YYYY</button>
                <button data-format="YYYY, MMM D" class="${releaseDateFormat === 'YYYY, MMM D' ? 'selected' : ''}">YYYY, Month D</button>
                <button data-format="YYYY-MM" class="${releaseDateFormat === 'YYYY-MM' ? 'selected' : ''}">YYYY-MM</button>
                <button data-format="MM-YYYY" class="${releaseDateFormat === 'MM-YYYY' ? 'selected' : ''}">MM-YYYY</button>
                <button data-format="YYYY" class="${releaseDateFormat === 'YYYY' ? 'selected' : ''}">YYYY</button>
            </div>
            <div id="myScrobblesDropdownContainer" class="column-settings-dropdown">
                <button data-mode="number" class="${myScrobblesDisplayMode === 'number' ? 'selected' : ''}">Number Mode</button>
                <button data-mode="sign" class="${myScrobblesDisplayMode === 'sign' ? 'selected' : ''}">Sign Mode</button>
            </div>
        </div>
    </div>
    
    <div class="setting-row" id="secondAdditionalColumnSetting">
        <label class="col description">
          Playlist Second Extra Column
        </label>
        <div class="col action" style="position: relative;">
            <button id="secondDateFormatSettingsBtn" class="column-settings-button" title="Release Date Format Settings" style="display: none;">
                ${settingsSvg}
            </button>
            <button id="secondMyScrobblesSettingsBtn" class="column-settings-button" title="My Scrobbles Display Settings" style="display: none;">
                ${settingsSvg}
            </button>
            <select id="secondColumnTypeSelect" class="column-type-select" ${!showSecondAdditionalColumn ? 'disabled' : ''}>
                <option value="playCount" ${selectedSecondColumnType === 'playCount' ? 'selected' : ''}>Play Count</option>
                <option value="popularity" ${selectedSecondColumnType === 'popularity' ? 'selected' : ''}>Popularity</option>
                <option value="releaseDate" ${selectedSecondColumnType === 'releaseDate' ? 'selected' : ''}>Release Date</option>
                <option value="scrobbles" ${selectedSecondColumnType === 'scrobbles' ? 'selected' : ''}>Scrobbles</option>
                <option value="personalScrobbles" ${selectedSecondColumnType === 'personalScrobbles' ? 'selected' : ''}>My Scrobbles</option>
                <option value="djInfo" ${selectedSecondColumnType === 'djInfo' ? 'selected' : ''}>DJ Info</option>
                <option value="key" ${selectedSecondColumnType === 'key' ? 'selected' : ''}>Key</option>
                <option value="tempo" ${selectedSecondColumnType === 'tempo' ? 'selected' : ''}>Tempo (BPM)</option>
                <option value="energy" ${selectedSecondColumnType === 'energy' ? 'selected' : ''}>Energy</option>
                <option value="danceability" ${selectedSecondColumnType === 'danceability' ? 'selected' : ''}>Danceability</option>
                <option value="valence" ${selectedSecondColumnType === 'valence' ? 'selected' : ''}>Valence</option>
            </select>
            <label class="switch">
                <input type="checkbox" id="showSecondAdditionalColumnToggle" ${showSecondAdditionalColumn ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
            <div id="secondDateFormatDropdownContainer" class="column-settings-dropdown">
                <button data-format="YYYY-MM-DD" class="${releaseDateFormat === 'YYYY-MM-DD' ? 'selected' : ''}">YYYY-MM-DD</button>
                <button data-format="MM-DD-YYYY" class="${releaseDateFormat === 'MM-DD-YYYY' ? 'selected' : ''}">MM-DD-YYYY</button>
                <button data-format="DD-MM-YYYY" class="${releaseDateFormat === 'DD-MM-YYYY' ? 'selected' : ''}">DD-MM-YYYY</button>
                <button data-format="MMM D, YYYY" class="${releaseDateFormat === 'MMM D, YYYY' ? 'selected' : ''}">Month D, YYYY</button>
                <button data-format="D MMM, YYYY" class="${releaseDateFormat === 'D MMM, YYYY' ? 'selected' : ''}">D Month, YYYY</button>
                <button data-format="YYYY, MMM D" class="${releaseDateFormat === 'YYYY, MMM D' ? 'selected' : ''}">YYYY, Month D</button>
                <button data-format="YYYY-MM" class="${releaseDateFormat === 'YYYY-MM' ? 'selected' : ''}">YYYY-MM</button>
                <button data-format="MM-YYYY" class="${releaseDateFormat === 'MM-YYYY' ? 'selected' : ''}">MM-YYYY</button>
                <button data-format="YYYY" class="${releaseDateFormat === 'YYYY' ? 'selected' : ''}">YYYY</button>
            </div>
            <div id="secondMyScrobblesDropdownContainer" class="column-settings-dropdown">
                <button data-mode="number" class="${myScrobblesDisplayMode === 'number' ? 'selected' : ''}">Number Mode</button>
                <button data-mode="sign" class="${myScrobblesDisplayMode === 'sign' ? 'selected' : ''}">Sign Mode</button>
            </div>
        </div>
    </div>

    <div class="setting-row" id="albumColumnSetting">
        <label class="col description">
            Album Extra Column
        </label>
        <div class="col action">
            <button id="albumDateFormatSettingsBtn" class="column-settings-button" title="Release Date Format Settings" style="display: none;">
                ${settingsSvg}
            </button>
            <button id="albumMyScrobblesSettingsBtn" class="column-settings-button" title="My Scrobbles Display Settings" style="display: none;">
                ${settingsSvg}
            </button>
            <select id="albumColumnTypeSelect" class="column-type-select" ${!showAlbumColumn ? 'disabled' : ''}>
                <option value="releaseDate" ${selectedAlbumColumnType === 'releaseDate' ? 'selected' : ''}>Release Date</option>
                <option value="popularity" ${selectedAlbumColumnType === 'popularity' ? 'selected' : ''}>Popularity</option>
                <option value="scrobbles" ${selectedAlbumColumnType === 'scrobbles' ? 'selected' : ''}>Scrobbles</option>
                <option value="personalScrobbles" ${selectedAlbumColumnType === 'personalScrobbles' ? 'selected' : ''}>My Scrobbles</option>
                <option value="djInfo" ${selectedAlbumColumnType === 'djInfo' ? 'selected' : ''}>DJ Info</option>
                <option value="key" ${selectedAlbumColumnType === 'key' ? 'selected' : ''}>Key</option>
                <option value="tempo" ${selectedAlbumColumnType === 'tempo' ? 'selected' : ''}>Tempo (BPM)</option>
                <option value="energy" ${selectedAlbumColumnType === 'energy' ? 'selected' : ''}>Energy</option>
                <option value="danceability" ${selectedAlbumColumnType === 'danceability' ? 'selected' : ''}>Danceability</option>
                <option value="valence" ${selectedAlbumColumnType === 'valence' ? 'selected' : ''}>Valence</option>
            </select>
            <label class="switch">
                <input type="checkbox" id="showAlbumColumnToggle" ${showAlbumColumn ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
            <div id="albumDateFormatDropdownContainer" class="column-settings-dropdown">
                <button data-format="YYYY-MM-DD" class="${releaseDateFormat === 'YYYY-MM-DD' ? 'selected' : ''}">YYYY-MM-DD</button>
                <button data-format="MM-DD-YYYY" class="${releaseDateFormat === 'MM-DD-YYYY' ? 'selected' : ''}">MM-DD-YYYY</button>
                <button data-format="DD-MM-YYYY" class="${releaseDateFormat === 'DD-MM-YYYY' ? 'selected' : ''}">DD-MM-YYYY</button>
                <button data-format="MMM D, YYYY" class="${releaseDateFormat === 'MMM D, YYYY' ? 'selected' : ''}">Month D, YYYY</button>
                <button data-format="D MMM, YYYY" class="${releaseDateFormat === 'D MMM, YYYY' ? 'selected' : ''}">D Month, YYYY</button>
                <button data-format="YYYY, MMM D" class="${releaseDateFormat === 'YYYY, MMM D' ? 'selected' : ''}">YYYY, Month D</button>
                <button data-format="YYYY-MM" class="${releaseDateFormat === 'YYYY-MM' ? 'selected' : ''}">YYYY-MM</button>
                <button data-format="MM-YYYY" class="${releaseDateFormat === 'MM-YYYY' ? 'selected' : ''}">MM-YYYY</button>
                <button data-format="YYYY" class="${releaseDateFormat === 'YYYY' ? 'selected' : ''}">YYYY</button>
            </div>
            <div id="albumMyScrobblesDropdownContainer" class="column-settings-dropdown">
                <button data-mode="number" class="${myScrobblesDisplayMode === 'number' ? 'selected' : ''}">Number Mode</button>
                <button data-mode="sign" class="${myScrobblesDisplayMode === 'sign' ? 'selected' : ''}">Sign Mode</button>
            </div>
        </div>
    </div>

    <div class="setting-row" id="artistColumnSetting">
        <label class="col description">
            Artist Extra Column
        </label>
        <div class="col action">
            <button id="artistDateFormatSettingsBtn" class="column-settings-button" title="Release Date Format Settings" style="display: none;">
                ${settingsSvg}
            </button>
            <button id="artistMyScrobblesSettingsBtn" class="column-settings-button" title="My Scrobbles Display Settings" style="display: none;">
                ${settingsSvg}
            </button>
            <select id="artistColumnTypeSelect" class="column-type-select" ${!showArtistColumn ? 'disabled' : ''}>
                <option value="releaseDate" ${selectedArtistColumnType === 'releaseDate' ? 'selected' : ''}>Release Date</option>
                <option value="popularity" ${selectedArtistColumnType === 'popularity' ? 'selected' : ''}>Popularity</option>
                <option value="scrobbles" ${selectedArtistColumnType === 'scrobbles' ? 'selected' : ''}>Scrobbles</option>
                <option value="personalScrobbles" ${selectedArtistColumnType === 'personalScrobbles' ? 'selected' : ''}>My Scrobbles</option>
                <option value="djInfo" ${selectedArtistColumnType === 'djInfo' ? 'selected' : ''}>DJ Info</option>
                <option value="key" ${selectedArtistColumnType === 'key' ? 'selected' : ''}>Key</option>
                <option value="tempo" ${selectedArtistColumnType === 'tempo' ? 'selected' : ''}>Tempo (BPM)</option>
                <option value="energy" ${selectedArtistColumnType === 'energy' ? 'selected' : ''}>Energy</option>
                <option value="danceability" ${selectedArtistColumnType === 'danceability' ? 'selected' : ''}>Danceability</option>
                <option value="valence" ${selectedArtistColumnType === 'valence' ? 'selected' : ''}>Valence</option>
            </select>
            <label class="switch">
                <input type="checkbox" id="showArtistColumnToggle" ${showArtistColumn ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
            <div id="artistDateFormatDropdownContainer" class="column-settings-dropdown">
                <button data-format="YYYY-MM-DD" class="${releaseDateFormat === 'YYYY-MM-DD' ? 'selected' : ''}">YYYY-MM-DD</button>
                <button data-format="MM-DD-YYYY" class="${releaseDateFormat === 'MM-DD-YYYY' ? 'selected' : ''}">MM-DD-YYYY</button>
                <button data-format="DD-MM-YYYY" class="${releaseDateFormat === 'DD-MM-YYYY' ? 'selected' : ''}">DD-MM-YYYY</button>
                <button data-format="MMM D, YYYY" class="${releaseDateFormat === 'MMM D, YYYY' ? 'selected' : ''}">Month D, YYYY</button>
                <button data-format="D MMM, YYYY" class="${releaseDateFormat === 'D MMM, YYYY' ? 'selected' : ''}">D Month, YYYY</button>
                <button data-format="YYYY, MMM D" class="${releaseDateFormat === 'YYYY, MMM D' ? 'selected' : ''}">YYYY, Month D</button>
                <button data-format="YYYY-MM" class="${releaseDateFormat === 'YYYY-MM' ? 'selected' : ''}">YYYY-MM</button>
                <button data-format="MM-YYYY" class="${releaseDateFormat === 'MM-YYYY' ? 'selected' : ''}">MM-YYYY</button>
                <button data-format="YYYY" class="${releaseDateFormat === 'YYYY' ? 'selected' : ''}">YYYY</button>
            </div>
            <div id="artistMyScrobblesDropdownContainer" class="column-settings-dropdown">
                <button data-mode="number" class="${myScrobblesDisplayMode === 'number' ? 'selected' : ''}">Number Mode</button>
                <button data-mode="sign" class="${myScrobblesDisplayMode === 'sign' ? 'selected' : ''}">Sign Mode</button>
            </div>
        </div>
    </div>
    
    <div class="setting-row" id="removeDateAdded">
        <label class="col description">Remove Playlist "Date Added" Column</label>
        <div class="col action">
            <label class="switch">
                <input type="checkbox" ${removeDateAdded ? 'checked' : ''} ${!showAdditionalColumn ? 'disabled' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>

    <div style="color: white; font-weight: bold; font-size: 18px; margin-top: 10px;">
        UI Enhancements
    </div>
    <div style="border-bottom: 1px solid #555; margin-top: -3px;"></div>

    <div class="setting-row" id="showLikeButtonSetting">
        <label class="col description">
            Show Old Like Button
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Adds a heart button to track rows, the play bar, and the Now Playing view.</span>
            </span>
        </label>
        <div class="col action">
            <label class="switch">
                <input type="checkbox" id="showLikeButtonToggle" ${showLikeButton ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>


    <div class="setting-row" id="showGenreTagsSetting">
        <label class="col description">
            Show Genre Tags
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Displays clickable genre tags in the Now Playing bar and Artist pages.</span>
            </span>
        </label>
        <div class="col action">
            <button id="genreSourcesSettingsBtn" class="column-settings-button" title="Configure Genre Sources">
                ${settingsSvg}
            </button>
            <label class="switch">
                <input type="checkbox" id="showGenreTagsToggle" ${showGenreTags ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>
    
    <div class="setting-row" id="showNowPlayingDataSetting">
        <label class="col description">
            Now Playing Extra Data
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Shows extra data like Release Date next to the title or artist in the Now Playing bar.</span>
            </span>
        </label>
        <div class="col action">
            <button id="nowPlayingSettingsBtn" class="column-settings-button" title="Now Playing Data Settings">
                ${settingsSvg}
            </button>
            <select id="nowPlayingDataTypeSelect" class="column-type-select" ${!showNowPlayingData ? 'disabled' : ''}>
                <option value="releaseDate" ${selectedNowPlayingDataType === 'releaseDate' ? 'selected' : ''}>Release Date</option>
                <option value="playCount" ${selectedNowPlayingDataType === 'playCount' ? 'selected' : ''}>Play Count</option>
                <option value="popularity" ${selectedNowPlayingDataType === 'popularity' ? 'selected' : ''}>Popularity</option>
                <option value="tempo" ${selectedNowPlayingDataType === 'tempo' ? 'selected' : ''}>Tempo (BPM)</option>
                <option value="energy" ${selectedNowPlayingDataType === 'energy' ? 'selected' : ''}>Energy</option>
                <option value="danceability" ${selectedNowPlayingDataType === 'danceability' ? 'selected' : ''}>Danceability</option>
                <option value="valence" ${selectedNowPlayingDataType === 'valence' ? 'selected' : ''}>Valence</option>
                <option value="key" ${selectedNowPlayingDataType === 'key' ? 'selected' : ''}>Key</option>
            </select>
            <label class="switch">
                <input type="checkbox" id="showNowPlayingDataToggle" ${showNowPlayingData ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>

    <div style="color: white; font-weight: bold; font-size: 18px; margin-top: 10px;">
        Playlist Attributes
    </div>
    <div style="border-bottom: 1px solid #555; margin-top: -3px;"></div>

    
    <div class="setting-row" id="createPlaylistPrivateSettingRow">
        <label class="col description">
            Make Created Playlists Private
        </label>
        <div class="col action">
            <label class="switch">
                <input type="checkbox" id="createPlaylistPrivateToggle" ${createPlaylistPrivate ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>
    
    <div class="setting-row" id="changeTitleOnCreateSettingRow">
        <label class="col description">
            Update Title When Creating
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Appends a sort tag like (PlayCount) to new playlists created via direct sorting.</span>
            </span>
        </label>
        <div class="col action">
            <label class="switch" id="changeTitleOnCreateSwitchLabel">
                <input type="checkbox" id="changeTitleOnCreateToggle" ${changeTitleOnCreate ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>

    <div class="setting-row" id="changeTitleOnModifySettingRow">
        <label class="col description">
            Update Title When Modifying
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Appends a sort tag like (PlayCount) to the playlist title after modifying it.</span>
            </span>
        </label>
        <div class="col action">
            <label class="switch" id="changeTitleOnModifySwitchLabel">
                <input type="checkbox" id="changeTitleOnModifyToggle" ${changeTitleOnModify ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>
    
    <div style="color: white; font-weight: bold; font-size: 18px; margin-top: 10px;">
        Duplicate Removal
    </div>
    <div style="border-bottom: 1px solid #555; margin-top: -3px;"></div>

    <div class="setting-row" id="playlistDeduplicate">
        <label class="col description">
            Remove Duplicate Tracks While Sorting
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Can make sorting slower.<br><br>This setting won't affect artist pages or tracks with identical URLs</span>
            </span>
        </label>
        <div class="col action">
            <label class="switch">
                <input type="checkbox" ${playlistDeduplicate ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>
    <div class="setting-row" id="showRemovedDuplicates">
        <label class="col description">Show Removed Duplicates</label>
        <div class="col action">
            <label class="switch">
                <input type="checkbox" ${showRemovedDuplicates ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>

    <div style="color: white; font-weight: bold; font-size: 18px; margin-top: 10px;">
        Dedicated Playlist Creation
    </div>
    <div style="border-bottom: 1px solid #555; margin-top: -3px;"></div>

    <div class="setting-row" id="setDedicatedCoversSettingRow">
        <label class="col description">
            Set Custom Playlist Covers
        </label>
        <div class="col action">
            <label class="switch">
                <input type="checkbox" id="setDedicatedCoversToggle" ${setDedicatedPlaylistCovers ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>

    <div class="setting-row" id="topTracksLimitSetting">
        <label class="col description">
            Top Tracks Playlist Size
        </label>
        <div class="col action">
            <select id="topTracksLimitSelect" style="width: 65px;">
                <option value="50">50</option>
                <option value="100">100</option>
                <option value="150">150</option>
                <option value="200">200</option>
                <option value="250">250</option>
                <option value="500">500</option>
                <option value="1000">1000</option>
            </select>
        </div>
    </div>

    <div class="setting-row" id="discoveryPlaylistSizeSetting">
        <label class="col description">
            Discovery Playlist Size
        </label>
        <div class="col action">
            <select id="discoveryPlaylistSizeSelect" style="width: 65px;">
                <option value="25">25</option>
                <option value="50">50</option>
                <option value="75">75</option>
                <option value="100">100</option>
            </select>
        </div>
    </div>

    <div class="setting-row" id="newReleasesLimitSetting">
        <label class="col description">
            New Releases Time Window
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Set the lookback period for New Releases playlists, anchored to the music industry's Friday release schedule.</span>
            </span>
        </label>
        <div class="col action">
            <select id="newReleasesLimitSelect" style="max-width: 180px;">
            <option value="release-1">This Release Week</option>
            <option value="release-2">Last 2 Release Weeks</option>
            <option value="release-3">Last 3 Release Weeks</option>
            <option value="release-5">Last 5 Release Weeks</option>
            <option value="release-9">Last 9 Release Weeks</option>
            <option disabled>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</option>
            <option value="1">Last 24 Hours</option>
            <option value="2">Last 2 Days</option>
            <option value="3">Last 3 Days</option>
            <option value="4">Last 4 Days</option>
            <option value="7">Last 7 Days</option>
            <option value="10">Last 10 Days</option>
            <option value="15">Last 15 Days</option>
            <option value="30">Last 30 Days</option>
            <option value="60">Last 60 Days</option>
            <option value="90">Last 90 Days</option>
            <option value="150">Last 150 Days</option>
        </select>
        </div>
    </div>

    <div class="setting-row" id="followedReleasesLimitSetting">
        <label class="col description">
            Followed Artist (Full) Tracks Per Album
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Limit the number of tracks added from each album in the "Followed Artist (Full)" playlist.</span>
            </span>
        </label>
        <div class="col action">
            <select id="followedReleasesLimitSelect" style="max-width: 120px;">
                <option value="1">1 Track</option>
                <option value="2">2 Tracks</option>
                <option value="3">3 Tracks</option>
                <option value="5">5 Tracks</option>
                <option value="all">All Tracks</option>
            </select>
        </div>
    </div>

    <div style="color: white; font-weight: bold; font-size: 18px; margin-top: 10px;">
        Last.fm
    </div>
    <div style="border-bottom: 1px solid #555; margin-top: -3px;"></div>

    <div class="setting-row" id="includeZeroScrobblesSetting">
        <label class="col description">
            Include Tracks with No Scrobbles
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">When sorting by "My Scrobbles", include tracks with 0 scrobbles.</span>
            </span>
        </label>
        <div class="col action">
            <label class="switch">
                <input type="checkbox" id="includeZeroScrobblesToggle" ${includeZeroScrobbles ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>
    <div class="setting-row" id="lastFmAutocorrectSetting">
        <label class="col description">
            Last.fm Autocorrect
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Uses Last.fm's native 'autocorrect' parameter to resolve misspelled artist/track names.</span>
            </span>
        </label>
        <div class="col action">
            <label class="switch">
                <input type="checkbox" id="lastFmAutocorrectToggle" ${lastFmAutocorrect ? 'checked' : ''}>
                <span class="sliderx"></span>
            </label>
        </div>
    </div>
    </div>
    </div>
    <div class="sort-play-settings-footer">
        <button id="supportMeBtn" class="footer-icon-button support-me-button" title="Support Sort-Play">
            ${coffeeIconSVG}
        </button>
        <div class="github-link-container">
            <a href="https://github.com/hoeci/sort-play" target="_blank">Star on GitHub, report bugs, and suggest features!</a>
        </div>
        <button id="liveChatBtn" class="footer-icon-button live-chat-button" title="Live Chat">
            ${liveChatIconSVG}
        </button>
    </div>
    `;

    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);

    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            overlay.style.opacity = "1";
        });
    });

    const liveChatBtn = modalContainer.querySelector("#liveChatBtn");
    const supportMeBtn = modalContainer.querySelector("#supportMeBtn");

    supportMeBtn.addEventListener("click", () => {
        showSupportModal();
    });

    if (chatPanelVisible) {
        const chatPanel = createAndInitializeChatPanel();
        positionChatPanel(chatPanel);
        setTimeout(() => {
            const panel = document.getElementById('sort-play-chat-panel');
            if (panel) panel.classList.add('visible');
        }, 10);
        liveChatBtn.classList.add('active');
    }

    liveChatBtn.addEventListener("click", () => {
        toggleChatPanel();
    });

    if (isMenuOpen) {
      closeAllMenus();
    }

    const modalContainerElement = document.querySelector(".main-popupModal-container");
    if (modalContainerElement) {
        modalContainerElement.style.zIndex = "2000";
    }
    
    preventDragCloseModal();

    modalContainer.querySelector("#closeSettingsModal").addEventListener("click", closeModal);

    const showAdditionalColumnToggle = modalContainer.querySelector("#showAdditionalColumnToggle");
    const showAlbumColumnToggle = modalContainer.querySelector("#showAlbumColumnToggle");
    const showArtistColumnToggle = modalContainer.querySelector("#showArtistColumnToggle");
    const columnTypeSelect = modalContainer.querySelector("#columnTypeSelect");
    const albumColumnTypeSelect = modalContainer.querySelector("#albumColumnTypeSelect");
    const artistColumnTypeSelect = modalContainer.querySelector("#artistColumnTypeSelect");
    const dateFormatSettingsBtn = modalContainer.querySelector("#dateFormatSettingsBtn");
    const myScrobblesSettingsBtn = modalContainer.querySelector("#myScrobblesSettingsBtn");
    const albumDateFormatSettingsBtn = modalContainer.querySelector("#albumDateFormatSettingsBtn");
    const albumMyScrobblesSettingsBtn = modalContainer.querySelector("#albumMyScrobblesSettingsBtn");
    const artistDateFormatSettingsBtn = modalContainer.querySelector("#artistDateFormatSettingsBtn");
    const artistMyScrobblesSettingsBtn = modalContainer.querySelector("#artistMyScrobblesSettingsBtn");
    const dateFormatDropdownContainer = modalContainer.querySelector("#dateFormatDropdownContainer");
    const myScrobblesDropdownContainer = modalContainer.querySelector("#myScrobblesDropdownContainer");
    const albumDateFormatDropdownContainer = modalContainer.querySelector("#albumDateFormatDropdownContainer");
    const albumMyScrobblesDropdownContainer = modalContainer.querySelector("#albumMyScrobblesDropdownContainer");
    const artistDateFormatDropdownContainer = modalContainer.querySelector("#artistDateFormatDropdownContainer");
    const artistMyScrobblesDropdownContainer = modalContainer.querySelector("#artistMyScrobblesDropdownContainer");
    const removeDateAddedToggle = modalContainer.querySelector("#removeDateAdded input");
    const playlistDeduplicateToggle = modalContainer.querySelector("#playlistDeduplicate input");
    const showRemovedDuplicatesToggle = modalContainer.querySelector("#showRemovedDuplicates input");
    const setGeminiApiKeyButton = modalContainer.querySelector("#setGeminiApiKey");
    const setLastFmUsernameButton = modalContainer.querySelector("#setLastFmUsername");
    const includeZeroScrobblesToggle = modalContainer.querySelector("#includeZeroScrobblesToggle");
    const lastFmAutocorrectToggle = modalContainer.querySelector("#lastFmAutocorrectToggle");
    const addToQueueToggle = modalContainer.querySelector("#addToQueueToggle");
    const createPlaylistToggle = modalContainer.querySelector("#createPlaylistToggle");
    const createPlaylistSwitchLabel = modalContainer.querySelector("#createPlaylistSwitchLabel");
    const createPlaylistSettingRow = modalContainer.querySelector("#createPlaylistSettingRow");
    const sortCurrentPlaylistToggle = modalContainer.querySelector("#sortCurrentPlaylistToggle");
    const sortCurrentPlaylistSwitchLabel = modalContainer.querySelector("#sortCurrentPlaylistSwitchLabel");
    const sortCurrentPlaylistSettingRow = modalContainer.querySelector("#sortCurrentPlaylistSettingRow");
    const openPlaylistAfterSortToggle = modalContainer.querySelector("#openPlaylistAfterSortToggle");
    const createPlaylistPrivateToggle = modalContainer.querySelector("#createPlaylistPrivateToggle");
    const openPlaylistAfterSortSwitchLabel = modalContainer.querySelector("#openPlaylistAfterSortSwitchLabel");
    const openPlaylistAfterSortSettingRow = modalContainer.querySelector("#openPlaylistAfterSortSettingRow");
    const colorSortModeSelect = modalContainer.querySelector("#colorSortModeSelect");
    const topTracksLimitSelect = modalContainer.querySelector("#topTracksLimitSelect");
    const newReleasesLimitSelect = modalContainer.querySelector("#newReleasesLimitSelect");
    const followedReleasesLimitSelect = modalContainer.querySelector("#followedReleasesLimitSelect");
    const discoveryPlaylistSizeSelect = modalContainer.querySelector("#discoveryPlaylistSizeSelect");
    const placePlaylistsInFolderToggle = modalContainer.querySelector("#placePlaylistsInFolderToggle");
    const folderNameSettingsBtn = modalContainer.querySelector("#folderNameSettingsBtn");
    const changeTitleOnCreateToggle = modalContainer.querySelector("#changeTitleOnCreateToggle");
    const changeTitleOnModifyToggle = modalContainer.querySelector("#changeTitleOnModifyToggle");
    const setDedicatedCoversToggle = modalContainer.querySelector("#setDedicatedCoversToggle");
    const showSecondAdditionalColumnToggle = modalContainer.querySelector("#showSecondAdditionalColumnToggle");
    const secondColumnTypeSelect = modalContainer.querySelector("#secondColumnTypeSelect");
    const secondDateFormatSettingsBtn = modalContainer.querySelector("#secondDateFormatSettingsBtn");
    const secondMyScrobblesSettingsBtn = modalContainer.querySelector("#secondMyScrobblesSettingsBtn");
    const secondDateFormatDropdownContainer = modalContainer.querySelector("#secondDateFormatDropdownContainer");
    const secondMyScrobblesDropdownContainer = modalContainer.querySelector("#secondMyScrobblesDropdownContainer");
    const showLikeButtonToggle = modalContainer.querySelector("#showLikeButtonToggle");
    const showGenreTagsToggle = modalContainer.querySelector("#showGenreTagsToggle");
    const genreSourcesSettingsBtn = modalContainer.querySelector("#genreSourcesSettingsBtn");
    const useEnergyWaveShuffleToggle = modalContainer.querySelector("#useEnergyWaveShuffleToggle");
    const showNowPlayingDataToggle = modalContainer.querySelector("#showNowPlayingDataToggle");
    const nowPlayingDataTypeSelect = modalContainer.querySelector("#nowPlayingDataTypeSelect");
    const nowPlayingSettingsBtn = modalContainer.querySelector("#nowPlayingSettingsBtn");

    showLikeButtonToggle.addEventListener("change", () => {
        showLikeButton = showLikeButtonToggle.checked;
        saveSettings();

        const actionContainer = showLikeButtonToggle.closest('.col.action');
        const toggleLabel = actionContainer.querySelector('.switch');

        if (actionContainer && toggleLabel && !actionContainer.querySelector('.reload-button')) {
            const reloadButton = document.createElement('button');
            reloadButton.textContent = 'Reload';
            reloadButton.className = 'main-buttons-button reload-button';
            reloadButton.title = 'Reload Spotify to apply';
            reloadButton.style.cssText = `
                margin-right: 10px;
                padding: 2px 12px;
                height: 24px;
                border-radius: 12px;
                border: 1px solid #878787;
                cursor: pointer;
                background-color: transparent;
                color: white;
                font-weight: 500;
                font-size: 12px;
                transition: background-color 0.2s ease;
            `;
            reloadButton.addEventListener('click', () => {
                location.reload();
            });
            reloadButton.addEventListener('mouseenter', () => reloadButton.style.backgroundColor = '#ffffff1a');
            reloadButton.addEventListener('mouseleave', () => reloadButton.style.backgroundColor = 'transparent');
            actionContainer.insertBefore(reloadButton, toggleLabel);
        }
    });

    showGenreTagsToggle.addEventListener("change", () => {
        showGenreTags = showGenreTagsToggle.checked;
        saveSettings();
        displayGenreTags();
        updateArtistPageGenres();
    });
    
    genreSourcesSettingsBtn.disabled = !showGenreTagsToggle.checked;

    showGenreTagsToggle.addEventListener("change", () => {
        genreSourcesSettingsBtn.disabled = !showGenreTagsToggle.checked;
    });

    genreSourcesSettingsBtn.addEventListener("click", () => {
        if (!genreSourcesSettingsBtn.disabled) {
            showGenreTagsSettingsModal();
        }
    });
    
    nowPlayingSettingsBtn.disabled = !showNowPlayingDataToggle.checked;

    showNowPlayingDataToggle.addEventListener("change", () => {
        showNowPlayingData = showNowPlayingDataToggle.checked;
        nowPlayingDataTypeSelect.disabled = !showNowPlayingData;
        nowPlayingSettingsBtn.disabled = !showNowPlayingData;
        saveSettings();
        displayNowPlayingData();
    });

    nowPlayingDataTypeSelect.addEventListener("change", () => {
        selectedNowPlayingDataType = nowPlayingDataTypeSelect.value;
        saveSettings();
        displayNowPlayingData();
    });

    nowPlayingSettingsBtn.addEventListener("click", () => {
        if (!nowPlayingSettingsBtn.disabled) {
            showNowPlayingSettingsModal(true);
        }
    });

    function updateOpenPlaylistAfterSortToggleState() {
      const isCreatePlaylistOn = createPlaylistToggle.checked;
      const isModifyCurrentPlaylistActive = sortCurrentPlaylistToggle.checked && !sortCurrentPlaylistToggle.disabled;
      const shouldBeEnabled = (isCreatePlaylistOn && !isModifyCurrentPlaylistActive) || isModifyCurrentPlaylistActive;
      openPlaylistAfterSortToggle.disabled = !shouldBeEnabled;
      openPlaylistAfterSortSwitchLabel.classList.toggle("disabled", !shouldBeEnabled);
      openPlaylistAfterSortSettingRow.classList.toggle("dependent-disabled", !shouldBeEnabled);
      openPlaylistAfterSortToggle.checked = openPlaylistAfterSortEnabled;
    }

    function updateChangeTitleToggleState() {
        changeTitleOnModifyToggle.disabled = false;
        document.getElementById('changeTitleOnModifySwitchLabel').classList.remove("disabled");
        document.getElementById('changeTitleOnModifySettingRow').classList.remove("dependent-disabled");
        changeTitleOnModifyToggle.checked = changeTitleOnModify;
    }

    function updateSortCurrentPlaylistToggleState() {
        const isCreatePlaylistOn = createPlaylistToggle.checked;
        sortCurrentPlaylistToggle.disabled = !isCreatePlaylistOn;
        sortCurrentPlaylistSwitchLabel.classList.toggle("disabled", !isCreatePlaylistOn);
        sortCurrentPlaylistSettingRow.classList.toggle("dependent-disabled", !isCreatePlaylistOn);

        placePlaylistsInFolderToggle.disabled = false;
        document.getElementById('placePlaylistsInFolderSwitchLabel').classList.remove("disabled");
        document.getElementById('placePlaylistsInFolderSettingRow').classList.remove("dependent-disabled");
    
        folderNameSettingsBtn.disabled = !placePlaylistsInFolderToggle.checked;
    
        if (!isCreatePlaylistOn) {
            sortCurrentPlaylistToggle.checked = false;
        } else {
            sortCurrentPlaylistToggle.checked = sortCurrentPlaylistEnabled;
        }
        updateOpenPlaylistAfterSortToggleState();
        updateChangeTitleToggleState();
    }

    function updateCreatePlaylistToggleState() {
      const isAddToQueueOn = addToQueueToggle.checked;
      if (!isAddToQueueOn) {
        createPlaylistToggle.checked = true;
        createPlaylistToggle.disabled = true;
        createPlaylistSwitchLabel.classList.add("disabled");
        createPlaylistSettingRow.classList.add("forced");
        if (!createPlaylistAfterSort) {
             createPlaylistAfterSort = true;
             saveSettings();
        }
      } else {
        createPlaylistToggle.disabled = false;
        createPlaylistSwitchLabel.classList.remove("disabled");
        createPlaylistSettingRow.classList.remove("forced");
        createPlaylistToggle.checked = createPlaylistAfterSort;
      }
      updateSortCurrentPlaylistToggleState();
    }

    setDedicatedCoversToggle.addEventListener("change", () => {
        setDedicatedPlaylistCovers = setDedicatedCoversToggle.checked;
        saveSettings();
    });

    colorSortModeSelect.addEventListener("change", () => {
        colorSortMode = colorSortModeSelect.value;
        saveSettings();
    });

    topTracksLimitSelect.value = topTracksLimit;
    topTracksLimitSelect.addEventListener("change", () => {
        topTracksLimit = parseInt(topTracksLimitSelect.value, 10);
        saveSettings();
    });

    newReleasesLimitSelect.value = newReleasesDaysLimit;
    newReleasesLimitSelect.addEventListener("change", () => {
        const val = newReleasesLimitSelect.value;
        newReleasesDaysLimit = val.startsWith('release-') ? val : parseInt(val, 10);
        saveSettings();
    });
    
    followedReleasesLimitSelect.value = followedReleasesAlbumLimit;
    followedReleasesLimitSelect.addEventListener("change", () => {
        followedReleasesAlbumLimit = followedReleasesLimitSelect.value;
        saveSettings();
    });
    
    discoveryPlaylistSizeSelect.value = discoveryPlaylistSize;
    discoveryPlaylistSizeSelect.addEventListener("change", () => {
        discoveryPlaylistSize = parseInt(discoveryPlaylistSizeSelect.value, 10);
        saveSettings();
    });

    setGeminiApiKeyButton.addEventListener("click", () => {
        showGeminiApiKeyModal();
    });
    
    setLastFmUsernameButton.addEventListener("click", () => {
        showLastFmUsernameModal();
    });

    setGeminiApiKeyButton.addEventListener("mouseenter", () => {
        setGeminiApiKeyButton.style.backgroundColor = "#444444";
    });
    setGeminiApiKeyButton.addEventListener("mouseleave", () => {
        setGeminiApiKeyButton.style.backgroundColor = "#333333";
    });
    setLastFmUsernameButton.addEventListener("mouseenter", () => {
        setLastFmUsernameButton.style.backgroundColor = "#444444";
    });
    setLastFmUsernameButton.addEventListener("mouseleave", () => {
        setLastFmUsernameButton.style.backgroundColor = "#333333";
    });

    includeZeroScrobblesToggle.addEventListener("change", () => {
        includeZeroScrobbles = includeZeroScrobblesToggle.checked;
        saveSettings();
    });

    lastFmAutocorrectToggle.addEventListener("change", async () => {
        lastFmAutocorrect = lastFmAutocorrectToggle.checked;
        saveSettings();
        await idb.clear('scrobbles');
        await idb.clear('personalScrobbles');
    });

    addToQueueToggle.addEventListener("change", () => {
        addToQueueEnabled = addToQueueToggle.checked;
        updateCreatePlaylistToggleState();
        saveSettings();
    });

    createPlaylistToggle.addEventListener("change", () => {
        if (!createPlaylistToggle.disabled) {
            createPlaylistAfterSort = createPlaylistToggle.checked;
            updateSortCurrentPlaylistToggleState();
            saveSettings();
        }
    });

    energyWaveSettingsBtn.disabled = !useEnergyWaveShuffleToggle.checked;

    useEnergyWaveShuffleToggle.addEventListener("change", () => {
        useEnergyWaveShuffle = useEnergyWaveShuffleToggle.checked;
        energyWaveSettingsBtn.disabled = !useEnergyWaveShuffle;
        saveSettings();
    });
    
    energyWaveSettingsBtn.addEventListener("click", () => {
        if (!energyWaveSettingsBtn.disabled) {
            showEnergyWaveSettingsModal();
        }
    });
    
    sortCurrentPlaylistToggle.addEventListener("change", () => {
        if (!sortCurrentPlaylistToggle.disabled) {
            sortCurrentPlaylistEnabled = sortCurrentPlaylistToggle.checked;
            updateOpenPlaylistAfterSortToggleState();
            updateChangeTitleToggleState();
            saveSettings();
        }
    });

    changeTitleOnCreateToggle.addEventListener("change", () => {
        if (!changeTitleOnCreateToggle.disabled) {
            changeTitleOnCreate = changeTitleOnCreateToggle.checked;
            saveSettings();
        }
    });
    
    changeTitleOnModifyToggle.addEventListener("change", () => {
        if (!changeTitleOnModifyToggle.disabled) {
            changeTitleOnModify = changeTitleOnModifyToggle.checked;
            saveSettings();
        }
    });

    openPlaylistAfterSortToggle.addEventListener("change", () => {
        if (!openPlaylistAfterSortToggle.disabled) {
            openPlaylistAfterSortEnabled = openPlaylistAfterSortToggle.checked;
            saveSettings();
        }
    });

    createPlaylistPrivateToggle.addEventListener("change", () => {
        createPlaylistPrivate = createPlaylistPrivateToggle.checked;
        saveSettings();
    });

    updateCreatePlaylistToggleState();

    folderNameSettingsBtn.disabled = !placePlaylistsInFolderToggle.checked || placePlaylistsInFolderToggle.disabled;

    placePlaylistsInFolderToggle.addEventListener("change", () => {
        if (!placePlaylistsInFolderToggle.disabled) {
            placePlaylistsInFolder = placePlaylistsInFolderToggle.checked;
            folderNameSettingsBtn.disabled = !placePlaylistsInFolder;
            saveSettings();
            const tooltip = document.querySelector("#placePlaylistsInFolderSettingRow .custom-tooltip");
            if (tooltip) {
                tooltip.textContent = `Automatically place all created playlists inside a dedicated folder named "${sortPlayFolderName}".`;
            }
        }
    });

    folderNameSettingsBtn.addEventListener("click", () => {
        if (!folderNameSettingsBtn.disabled) {
            showFolderNameModal();
        }
    });

    removeDateAddedToggle.disabled = !showAdditionalColumn && !showSecondAdditionalColumn;
    removeDateAddedToggle.parentElement.classList.toggle("disabled", !showAdditionalColumn && !showSecondAdditionalColumn);
    columnTypeSelect.disabled = !showAdditionalColumn;
    secondColumnTypeSelect.disabled = !showSecondAdditionalColumn;
    albumColumnTypeSelect.disabled = !showAlbumColumn;
    artistColumnTypeSelect.disabled = !showArtistColumn;

    setTimeout(() => {
        const sliderxs = modalContainer.querySelectorAll('.sliderx');
        sliderxs.forEach(sliderx => {
            sliderx.style.transition = '.3s';
        });
    }, 50);

    const updatePlaylistColumnSettingsVisibility = () => {
        const showDateSettings = showAdditionalColumn && selectedColumnType === 'releaseDate';
        dateFormatSettingsBtn.style.display = showDateSettings ? 'flex' : 'none';
        dateFormatSettingsBtn.disabled = !showDateSettings;
        if (!showDateSettings) dateFormatDropdownContainer.style.display = 'none';
        const showScrobbleSettings = showAdditionalColumn && selectedColumnType === 'personalScrobbles';
        myScrobblesSettingsBtn.style.display = showScrobbleSettings ? 'flex' : 'none';
        myScrobblesSettingsBtn.disabled = !showScrobbleSettings;
        if (!showScrobbleSettings) myScrobblesDropdownContainer.style.display = 'none';
    };

    const updateSecondPlaylistColumnSettingsVisibility = () => {
        const showDateSettings = showSecondAdditionalColumn && selectedSecondColumnType === 'releaseDate';
        secondDateFormatSettingsBtn.style.display = showDateSettings ? 'flex' : 'none';
        secondDateFormatSettingsBtn.disabled = !showDateSettings;
        if (!showDateSettings) secondDateFormatDropdownContainer.style.display = 'none';
        const showScrobbleSettings = showSecondAdditionalColumn && selectedSecondColumnType === 'personalScrobbles';
        secondMyScrobblesSettingsBtn.style.display = showScrobbleSettings ? 'flex' : 'none';
        secondMyScrobblesSettingsBtn.disabled = !showScrobbleSettings;
        if (!showScrobbleSettings) secondMyScrobblesDropdownContainer.style.display = 'none';
    };

    const updateAlbumColumnSettingsVisibility = () => {
        const showDateSettings = showAlbumColumn && selectedAlbumColumnType === 'releaseDate';
        albumDateFormatSettingsBtn.style.display = showDateSettings ? 'flex' : 'none';
        albumDateFormatSettingsBtn.disabled = !showDateSettings;
        if (!showDateSettings) albumDateFormatDropdownContainer.style.display = 'none';
        const showScrobbleSettings = showAlbumColumn && selectedAlbumColumnType === 'personalScrobbles';
        albumMyScrobblesSettingsBtn.style.display = showScrobbleSettings ? 'flex' : 'none';
        albumMyScrobblesSettingsBtn.disabled = !showScrobbleSettings;
        if (!showScrobbleSettings) albumMyScrobblesDropdownContainer.style.display = 'none';
    };

    const updateArtistColumnSettingsVisibility = () => {
        const showDateSettings = showArtistColumn && selectedArtistColumnType === 'releaseDate';
        artistDateFormatSettingsBtn.style.display = showDateSettings ? 'flex' : 'none';
        artistDateFormatSettingsBtn.disabled = !showDateSettings;
        if (!showDateSettings) artistDateFormatDropdownContainer.style.display = 'none';
        const showScrobbleSettings = showArtistColumn && selectedArtistColumnType === 'personalScrobbles';
        artistMyScrobblesSettingsBtn.style.display = showScrobbleSettings ? 'flex' : 'none';
        artistMyScrobblesSettingsBtn.disabled = !showScrobbleSettings;
        if (!showScrobbleSettings) artistMyScrobblesDropdownContainer.style.display = 'none';
    };

    updatePlaylistColumnSettingsVisibility();
    updateSecondPlaylistColumnSettingsVisibility();
    updateAlbumColumnSettingsVisibility();
    updateArtistColumnSettingsVisibility();

    const allDropdownsForScroll = [
        dateFormatDropdownContainer, myScrobblesDropdownContainer,
        albumDateFormatDropdownContainer, albumMyScrobblesDropdownContainer,
        artistDateFormatDropdownContainer, artistMyScrobblesDropdownContainer,
        secondDateFormatDropdownContainer, secondMyScrobblesDropdownContainer
    ];
    
    allDropdownsForScroll.forEach(dropdown => {
        if (dropdown) {
            dropdown.addEventListener('wheel', (event) => {
                const { scrollTop, clientHeight, scrollHeight } = dropdown;
                if (event.deltaY < 0 && scrollTop === 0) {
                    event.preventDefault();
                }
                else if (event.deltaY > 0 && Math.abs(scrollHeight - clientHeight - scrollTop) < 1) {
                    event.preventDefault();
                }
            }, { passive: false });
        }
    });

    showAdditionalColumnToggle.addEventListener("change", () => {
        showAdditionalColumn = showAdditionalColumnToggle.checked;
        columnTypeSelect.disabled = !showAdditionalColumn;
        removeDateAddedToggle.disabled = !showAdditionalColumn && !showSecondAdditionalColumn;
        removeDateAddedToggle.parentElement.classList.toggle("disabled", !showAdditionalColumn && !showSecondAdditionalColumn);
        if (!showAdditionalColumn && !showSecondAdditionalColumn) {
            removeDateAdded = false;
            removeDateAddedToggle.checked = false;
        }
        updatePlaylistColumnSettingsVisibility();
        saveSettings();
        updateTracklist();
    });

    showSecondAdditionalColumnToggle.addEventListener("change", () => {
        showSecondAdditionalColumn = showSecondAdditionalColumnToggle.checked;
        secondColumnTypeSelect.disabled = !showSecondAdditionalColumn;
        removeDateAddedToggle.disabled = !showAdditionalColumn && !showSecondAdditionalColumn;
        removeDateAddedToggle.parentElement.classList.toggle("disabled", !showAdditionalColumn && !showSecondAdditionalColumn);
        if (!showAdditionalColumn && !showSecondAdditionalColumn) {
            removeDateAdded = false;
            removeDateAddedToggle.checked = false;
        }
        updateSecondPlaylistColumnSettingsVisibility();
        saveSettings();
        updateTracklist();
    });

    secondColumnTypeSelect.addEventListener("change", () => {
        selectedSecondColumnType = secondColumnTypeSelect.value;
        updateSecondPlaylistColumnSettingsVisibility();
        saveSettings();
        updateTracklist();
    });

    showAlbumColumnToggle.addEventListener("change", () => {
        showAlbumColumn = showAlbumColumnToggle.checked;
        albumColumnTypeSelect.disabled = !showAlbumColumn;
        updateAlbumColumnSettingsVisibility();
        saveSettings();
        onPageChange();
    });

    showArtistColumnToggle.addEventListener("change", () => {
        showArtistColumn = showArtistColumnToggle.checked;
        artistColumnTypeSelect.disabled = !showArtistColumn;
        updateArtistColumnSettingsVisibility();
        saveSettings();
        onPageChange();
    });

    removeDateAddedToggle.addEventListener("change", () => {
        if (showAdditionalColumn) {
            removeDateAdded = removeDateAddedToggle.checked;
            saveSettings();
            updateTracklist();
        }
    });

    columnTypeSelect.addEventListener("change", () => {
        selectedColumnType = columnTypeSelect.value;
        updatePlaylistColumnSettingsVisibility();
        saveSettings();
        updateTracklist();
    });

    albumColumnTypeSelect.addEventListener("change", () => {
        selectedAlbumColumnType = albumColumnTypeSelect.value;
        updateAlbumColumnSettingsVisibility();
        saveSettings();
        onPageChange();
    });

    artistColumnTypeSelect.addEventListener("change", () => {
        selectedArtistColumnType = artistColumnTypeSelect.value;
        updateArtistColumnSettingsVisibility();
        saveSettings();
        onPageChange();
    });

    const allDateFormatContainers = [dateFormatDropdownContainer, albumDateFormatDropdownContainer, artistDateFormatDropdownContainer, secondDateFormatDropdownContainer];
    const allScrobbleContainers = [myScrobblesDropdownContainer, albumMyScrobblesDropdownContainer, artistMyScrobblesDropdownContainer, secondMyScrobblesDropdownContainer];

    const setupGlobalSettingListeners = (containers, settingKey, updateFunc) => {
        containers.forEach(container => {
            container.querySelectorAll("button").forEach(button => {
                button.addEventListener("click", (event) => {
                    event.stopPropagation();
                    const newValue = button.getAttribute(`data-${settingKey}`);
                    updateFunc(newValue);
                    containers.forEach(c => {
                        c.querySelectorAll("button").forEach(btn => btn.classList.remove("selected"));
                        const matchingButton = c.querySelector(`[data-${settingKey}="${newValue}"]`);
                        if (matchingButton) matchingButton.classList.add("selected");
                    });
                    allDateFormatContainers.forEach(c => c.style.display = 'none');
                    allScrobbleContainers.forEach(c => c.style.display = 'none');
                    saveSettings();
                    onPageChange();
                });
            });
        });
    };

    setupGlobalSettingListeners(allDateFormatContainers, 'format', (value) => {
        releaseDateFormat = value;
    });
    setupGlobalSettingListeners(allScrobbleContainers, 'mode', (value) => {
        myScrobblesDisplayMode = value;
    });

    const setupSettingsButtonToggle = (button, dropdown, otherDropdowns) => {
        button.addEventListener("click", (event) => {
            event.stopPropagation();
            const isCurrentlyVisible = dropdown.style.display === 'block';

            otherDropdowns.forEach(d => d.style.display = 'none');
            if (isCurrentlyVisible) {
                dropdown.style.display = 'none';
                return;
            }

            dropdown.style.top = 'auto';
            dropdown.style.bottom = 'auto';
            dropdown.style.marginTop = 'auto';
            dropdown.style.marginBottom = 'auto';
            dropdown.style.maxHeight = '';
            dropdown.style.overflowY = '';

            dropdown.style.visibility = 'hidden';
            dropdown.style.display = 'block';
            const dropdownRect = dropdown.getBoundingClientRect();
            dropdown.style.display = 'none';
            dropdown.style.visibility = 'visible';

            const buttonRect = button.getBoundingClientRect();
            const modal = button.closest(".main-embedWidgetGenerator-container");
            const scrollContainer = modal.querySelector(".main-trackCreditsModal-mainSection");
            const scrollContainerRect = scrollContainer.getBoundingClientRect();

            const dropdownHeight = dropdownRect.height;
            const margin = 9;
            const boundaryMargin = 20;

            const spaceBelow = scrollContainerRect.bottom - buttonRect.bottom;
            const spaceAbove = buttonRect.top - scrollContainerRect.top;

            if (spaceBelow >= dropdownHeight + margin + boundaryMargin) {
                dropdown.style.top = '100%';
                dropdown.style.marginTop = `${margin}px`;
            } else if (spaceAbove >= dropdownHeight + margin + boundaryMargin) {
                dropdown.style.bottom = '100%';
                dropdown.style.marginBottom = `${margin}px`;
            } else {
                if (spaceAbove > spaceBelow) {
                    dropdown.style.bottom = '100%';
                    dropdown.style.marginBottom = `${margin}px`;
                    dropdown.style.maxHeight = `${spaceAbove - margin - boundaryMargin}px`;
                    dropdown.style.overflowY = 'auto';
                } else {
                    dropdown.style.top = '100%';
                    dropdown.style.marginTop = `${margin}px`;
                    dropdown.style.maxHeight = `${spaceBelow - margin - boundaryMargin}px`;
                    dropdown.style.overflowY = 'auto';
                }
            }

            dropdown.style.display = 'block';
        });
    };

    const allDropdowns = [...allDateFormatContainers, ...allScrobbleContainers];
    setupSettingsButtonToggle(dateFormatSettingsBtn, dateFormatDropdownContainer, allDropdowns.filter(d => d !== dateFormatDropdownContainer));
    setupSettingsButtonToggle(myScrobblesSettingsBtn, myScrobblesDropdownContainer, allDropdowns.filter(d => d !== myScrobblesDropdownContainer));
    setupSettingsButtonToggle(albumDateFormatSettingsBtn, albumDateFormatDropdownContainer, allDropdowns.filter(d => d !== albumDateFormatDropdownContainer));
    setupSettingsButtonToggle(albumMyScrobblesSettingsBtn, albumMyScrobblesDropdownContainer, allDropdowns.filter(d => d !== albumMyScrobblesDropdownContainer));
    setupSettingsButtonToggle(artistDateFormatSettingsBtn, artistDateFormatDropdownContainer, allDropdowns.filter(d => d !== artistDateFormatDropdownContainer));
    setupSettingsButtonToggle(artistMyScrobblesSettingsBtn, artistMyScrobblesDropdownContainer, allDropdowns.filter(d => d !== artistMyScrobblesDropdownContainer));
    setupSettingsButtonToggle(secondDateFormatSettingsBtn, secondDateFormatDropdownContainer, allDropdowns.filter(d => d !== secondDateFormatDropdownContainer));
    setupSettingsButtonToggle(secondMyScrobblesSettingsBtn, secondMyScrobblesDropdownContainer, allDropdowns.filter(d => d !== secondMyScrobblesDropdownContainer));

    document.addEventListener('click', (event) => {
        allDropdowns.forEach(d => d.style.display = 'none');
    });

    playlistDeduplicateToggle.addEventListener("change", () => {
        playlistDeduplicate = playlistDeduplicateToggle.checked;
        saveSettings();
    });

    showRemovedDuplicatesToggle.addEventListener("change", () => {
        showRemovedDuplicates = showRemovedDuplicatesToggle.checked;
        saveSettings();
    });
  }

  function showGenreTagsSettingsModal() {
    const overlay = document.createElement("div");
    overlay.id = "sort-play-genre-sources-overlay";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.7); z-index: 2005;
        display: flex; justify-content: center; align-items: center;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container sort-play-font-scope";
    modalContainer.style.cssText = `
        width: 420px !important;
        border-radius: 30px;
        overflow: visible; 
        background-color: #181818 !important;
        border: 2px solid #282828;
        display: flex;
        flex-direction: column;
    `;

    modalContainer.innerHTML = `
      <style>
        .setting-row {
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            padding: 5px 0;
        }
        .setting-label {
            color: #c1c1c1;
            font-size: 16px;
            font-weight: 500;
        }
        .section-header {
            font-weight: bold; 
            font-size: 16px; 
            color: white; 
            border-bottom: 1px solid #333; 
            padding-bottom: 8px;
            margin-bottom: 4px;
        }
        .switch {
            position: relative; 
            display: inline-block; 
            width: 40px; 
            height: 24px; 
            flex-shrink: 0;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .sliderx {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #484848; border-radius: 24px; transition: .2s;
        }
        .sliderx:before {
            position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
            background-color: white; border-radius: 50%; transition: .2s;
        }
        input:checked + .sliderx { background-color: #1DB954; }
        input:checked + .sliderx:before { transform: translateX(16px); }
        .custom-tooltip {
            visibility: hidden; position: absolute; z-index: 1000; background-color: #373737;
            color: white; padding: 8px 12px; border-radius: 4px; font-size: 14px;
            max-width: 240px; width: max-content; bottom: 100%; left: 50%;
            transform: translateX(-50%); margin-bottom: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            line-height: 1.4; word-wrap: break-word; text-align: left;
        }
        .custom-tooltip::after {
            content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px;
            border-width: 5px; border-style: solid; border-color: #373737 transparent transparent transparent;
        }
        .tooltip-container { position: relative; display: inline-block; vertical-align: middle; margin-left: 6px; }
        .tooltip-container:hover .custom-tooltip { visibility: visible; }
      </style>
      <div class="main-trackCreditsModal-header" style="padding: 27px 32px 12px !important;">
          <h1 class="main-trackCreditsModal-title"><span style='font-size: 25px;'>Genre Settings</span></h1>
      </div>
      <div class="main-trackCreditsModal-originalCredits" style="padding: 20px 32px 25px !important;">
          <div style="display: flex; flex-direction: column; gap: 24px;">

              <div style="display: flex; flex-direction: column; gap: 4px;">
                  <div class="section-header">Display Location</div>
                  <div class="setting-row">
                      <label class="setting-label" for="showTagsNpToggle">Now Playing View</label>
                      <label class="switch">
                          <input type="checkbox" id="showTagsNpToggle" ${showGenreTagsNowPlaying ? 'checked' : ''}>
                          <span class="sliderx"></span>
                      </label>
                  </div>
                  <div class="setting-row">
                      <label class="setting-label" for="showTagsApToggle">Artist Page</label>
                      <label class="switch">
                          <input type="checkbox" id="showTagsApToggle" ${showGenreTagsArtistPage ? 'checked' : ''}>
                          <span class="sliderx"></span>
                      </label>
                  </div>
              </div>
              
              <div style="display: flex; flex-direction: column; gap: 4px;">
                  <div class="section-header">Behavior</div>
                  <div class="setting-row">
                      <div style="display: flex; align-items: center;">
                          <label class="setting-label" for="useGenreDbToggle">Link to EveryNoise PLaylits</label>
                          <span class="tooltip-container">
                              ${infoIconSvg}
                              <span class="custom-tooltip">If enabled, clicking a genre tag opens a specific curated playlist (e.g. The Sound of Pop) if available.<br><br>If disabled, it searches for the genre on Spotify.</span>
                          </span>
                      </div>
                      <label class="switch">
                          <input type="checkbox" id="useGenreDbToggle" ${useGenrePlaylistDatabase ? 'checked' : ''}>
                          <span class="sliderx"></span>
                      </label>
                  </div>
              </div>

              <div style="display: flex; flex-direction: column; gap: 4px;">
                  <div class="section-header">Now Playing Sources</div>
                  
                  <div class="setting-row">
                      <label class="setting-label" for="npSpotifyToggle">Spotify (Artist Tags)</label>
                      <label class="switch">
                          <input type="checkbox" id="npSpotifyToggle" ${genreSourcesNpSpotify ? 'checked' : ''}>
                          <span class="sliderx"></span>
                      </label>
                  </div>
                  <div class="setting-row">
                      <label class="setting-label" for="npLastfmToggle">Last.fm (Filtered Track & Artist Tags)</label>
                      <label class="switch">
                          <input type="checkbox" id="npLastfmToggle" ${genreSourcesNpLastfm ? 'checked' : ''}>
                          <span class="sliderx"></span>
                      </label>
                  </div>
                  <div class="setting-row">
                      <label class="setting-label" for="npDeezerToggle">Deezer (Album Tags)</label>
                      <label class="switch">
                          <input type="checkbox" id="npDeezerToggle" ${genreSourcesNpDeezer ? 'checked' : ''}>
                          <span class="sliderx"></span>
                      </label>
                  </div>
              </div>

              <div style="display: flex; flex-direction: column; gap: 4px;">
                  <div class="section-header">Artist Page Sources</div>
                  
                  <div class="setting-row">
                      <label class="setting-label" for="apSpotifyToggle">Spotify (Artist Tags)</label>
                      <label class="switch">
                          <input type="checkbox" id="apSpotifyToggle" ${genreSourcesApSpotify ? 'checked' : ''}>
                          <span class="sliderx"></span>
                      </label>
                  </div>
                  <div class="setting-row">
                      <label class="setting-label" for="apLastfmToggle">Last.fm (Filtered Artist Tags)</label>
                      <label class="switch">
                          <input type="checkbox" id="apLastfmToggle" ${genreSourcesApLastfm ? 'checked' : ''}>
                          <span class="sliderx"></span>
                      </label>
                  </div>
              </div>

              <div style="display: flex; justify-content: flex-end; margin-top: 10px;">
                  <button id="doneGenreSources" class="main-buttons-button main-button-primary" style="padding: 8px 18px; border-radius: 20px; border: none; cursor: pointer; background-color: #1ED760; color: black; font-weight: 550; font-size: 13px; text-transform: uppercase; transition: all 0.04s ease;">
                    Done
                  </button>
              </div>
          </div>
      </div>
    `;
    
    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);

    const closeModal = () => overlay.remove();

    const showTagsNpToggle = modalContainer.querySelector("#showTagsNpToggle");
    const showTagsApToggle = modalContainer.querySelector("#showTagsApToggle");
    const npSpotifyToggle = modalContainer.querySelector("#npSpotifyToggle");
    const npLastfmToggle = modalContainer.querySelector("#npLastfmToggle");
    const npDeezerToggle = modalContainer.querySelector("#npDeezerToggle");
    const apSpotifyToggle = modalContainer.querySelector("#apSpotifyToggle");
    const apLastfmToggle = modalContainer.querySelector("#apLastfmToggle");
    const useGenreDbToggle = modalContainer.querySelector("#useGenreDbToggle");
    const doneButton = modalContainer.querySelector("#doneGenreSources");

    const updateVarsAndSave = () => {
        showGenreTagsNowPlaying = showTagsNpToggle.checked;
        showGenreTagsArtistPage = showTagsApToggle.checked;
        genreSourcesNpSpotify = npSpotifyToggle.checked;
        genreSourcesNpLastfm = npLastfmToggle.checked;
        genreSourcesNpDeezer = npDeezerToggle.checked;
        genreSourcesApSpotify = apSpotifyToggle.checked;
        genreSourcesApLastfm = apLastfmToggle.checked;
        useGenrePlaylistDatabase = useGenreDbToggle.checked;
        saveSettings();
        
        nowPlayingGenreCache.clear();
        artistPageGenreCache.clear();
        
        displayGenreTags();
        updateArtistPageGenres();
    };
    
    showTagsNpToggle.addEventListener("change", updateVarsAndSave);
    showTagsApToggle.addEventListener("change", updateVarsAndSave);
    npSpotifyToggle.addEventListener("change", updateVarsAndSave);
    npLastfmToggle.addEventListener("change", updateVarsAndSave);
    npDeezerToggle.addEventListener("change", updateVarsAndSave);
    apSpotifyToggle.addEventListener("change", updateVarsAndSave);
    apLastfmToggle.addEventListener("change", updateVarsAndSave);
    useGenreDbToggle.addEventListener("change", updateVarsAndSave);

    doneButton.addEventListener("click", closeModal);
    doneButton.addEventListener("mouseenter", () => { doneButton.style.backgroundColor = "#3BE377"; });
    doneButton.addEventListener("mouseleave", () => { doneButton.style.backgroundColor = "#1ED760"; });

    overlay.addEventListener("click", (e) => { if (e.target === overlay) closeModal(); });
  }

  function showEnergyWaveSettingsModal() {
    const overlay = document.createElement("div");
    overlay.id = "sort-play-energy-wave-settings-overlay";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.7); z-index: 2005;
        display: flex; justify-content: center; align-items: center;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container sort-play-font-scope";
    modalContainer.style.cssText = `
        width: 420px !important;
        border-radius: 30px;
        overflow: hidden; 
        background-color: #181818 !important;
        border: 2px solid #282828;
        display: flex;
        flex-direction: column;
    `;

    modalContainer.innerHTML = `
      <div class="main-trackCreditsModal-header" style="padding: 27px 32px 12px !important;">
          <h1 class="main-trackCreditsModal-title"><span style='font-size: 25px;'>Vibe & Flow Config</span></h1>
      </div>
      <div class="main-trackCreditsModal-originalCredits" style="padding: 20px 32px 20px !important;">
          <div style="display: flex; flex-direction: column; gap: 15px;">
              <div style="display: flex; flex-direction: column; gap: 8px;">
                  <label for="energyWaveLimitInput" style="color: #c1c1c1; font-size: 14px;">Max tracks for 'Shuffle and Play':</label>
                  <input type="number" id="energyWaveLimitInput" value="${energyWaveShuffleLimit}" 
                        style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #282828; background: #282828; color: white;">
                  <span style="font-size: 12px; color: #888; line-height: 1.4;">If a playlist exceeds this size, standard shuffle will be used instead to avoid long wait times. Normal sorting is unaffected.</span>
              </div>
              <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 10px;">
                  <button id="cancelEnergyWave" class="main-buttons-button" style="width: 83px; padding: 8px 16px; border-radius: 20px; border: none; cursor: pointer; background-color: #333333; color: white; font-weight: 550; font-size: 13px; text-transform: uppercase;">Cancel</button>
                  <button id="saveEnergyWave" class="main-buttons-button main-button-primary" style="padding: 8px 18px; border-radius: 20px; border: none; cursor: pointer; background-color: #1ED760; color: black; font-weight: 550; font-size: 13px; text-transform: uppercase;">Save</button>
              </div>
          </div>
      </div>
    `;
    
    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);
    const input = document.getElementById("energyWaveLimitInput");
    input.focus();

    const closeModal = () => overlay.remove();

    document.getElementById("saveEnergyWave").addEventListener("click", () => {
      const newLimit = parseInt(input.value, 10);
      if (!isNaN(newLimit) && newLimit > 0) {
        energyWaveShuffleLimit = newLimit;
        saveSettings();
        closeModal();
      } else {
          showNotification("Please enter a valid number.", true);
      }
    });

    document.getElementById("cancelEnergyWave").addEventListener("click", closeModal);
    overlay.addEventListener("click", (e) => { if (e.target === overlay) closeModal(); });
  }
  
  function showFolderNameModal() {
    const overlay = document.createElement("div");
    overlay.id = "sort-play-folder-name-overlay";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.7); z-index: 2002;
        display: flex; justify-content: center; align-items: center;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container sort-play-font-scope";
    modalContainer.style.zIndex = "2003";
    modalContainer.innerHTML = `
      <div class="main-trackCreditsModal-header">
          <h1 class="main-trackCreditsModal-title"><span style='font-size: 25px;'>Customize Folder Name</span></h1>
      </div>
      <div class="main-trackCreditsModal-originalCredits" style="padding: 20px 32px 20px !important;">
          <div style="display: flex; flex-direction: column; gap: 15px;">
              <div style="display: flex; flex-direction: column; gap: 5px;">
                  <label for="sortPlayFolderNameInput">Folder Name:</label>
                  <input type="text" id="sortPlayFolderNameInput" value="${sortPlayFolderName}" 
                        style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #282828; background: #282828; color: white;">
              </div>
              <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 10px;">
                  <button id="cancelFolderName" class="main-buttons-button" style="width: 83px; padding: 8px 16px; border-radius: 20px; border: none; cursor: pointer; background-color: #333333; color: white; font-weight: 550; font-size: 13px; text-transform: uppercase;">Cancel</button>
                  <button id="saveFolderName" class="main-buttons-button main-button-primary" style="padding: 8px 18px; border-radius: 20px; border: none; cursor: pointer; background-color: #1ED760; color: black; font-weight: 550; font-size: 13px; text-transform: uppercase;">Save</button>
              </div>
          </div>
      </div>
    `;
    
    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);
    document.getElementById("sortPlayFolderNameInput").focus();

    const closeModal = () => overlay.remove();

    document.getElementById("saveFolderName").addEventListener("click", () => {
      const newName = document.getElementById("sortPlayFolderNameInput").value.trim();
      if (newName) {
        sortPlayFolderName = newName;
        saveSettings();
        const tooltip = document.querySelector("#placePlaylistsInFolderSettingRow .custom-tooltip");
        if (tooltip) {
            tooltip.textContent = `Automatically place all created playlists inside a dedicated folder named "${sortPlayFolderName}".`;
        }
        closeModal();
      }
    });

    document.getElementById("cancelFolderName").addEventListener("click", closeModal);
    overlay.addEventListener("click", (e) => { if (e.target === overlay) closeModal(); });
  }

  function showNowPlayingSettingsModal(fromSettings = false) {
    const overlay = document.createElement("div");
    overlay.id = "sort-play-np-settings-overlay";
    const overlayBackgroundColor = fromSettings ? 'rgba(0, 0, 0, 0.7)' : 'transparent';
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: ${overlayBackgroundColor}; z-index: 2002;
        display: flex; justify-content: center; align-items: center;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container sort-play-font-scope";
    modalContainer.style.cssText = `
        z-index: 2003;
        width: 600px !important;
        overflow: visible !important;
    `;
    modalContainer.innerHTML = `
      <style>
        .np-settings-layout { display: flex; gap: 16px; }
        .np-settings-card { flex: 1; background-color: #282828; border-radius: 8px; padding: 16px; display: flex; flex-direction: column; gap: 16px; }
        .np-setting-row { display: flex; flex-direction: column; gap: 8px; }
        .np-setting-row label { color: #c1c1c1; font-weight: 500; }
        .np-setting-row select {
            padding: 6px 12px; border-radius: 4px; border: 1px solid #434343;
            background: #3e3e3e; color: white; cursor: pointer; font-size: 14px;
            width: 100%; text-align: left;
            height: 35px;
            box-sizing: border-box;
        }
        #np-dynamic-settings { margin-top: 8px; }
        #np-release-date-settings, #np-play-count-settings, #np-tempo-settings, #np-energy-settings, #np-danceability-settings, #np-valence-settings, #np-key-settings, #np-popularity-settings { display: none; }
        
        .custom-select-wrapper { position: relative; width: 100%; }
        .custom-select-trigger {
            width: 100%;
            padding: 6px 0px 6px 12px;
            border-radius: 4px;
            border: 1px solid #434343;
            background: #3e3e3e;
            color: white;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-align: left;
            height: 35px;
            box-sizing: border-box;
        }
        #npSeparatorDisplay {
            display: flex;
            align-items: center;
            height: 100%;
        }
        .custom-select-trigger svg {
            width: 18px;
            height: 18px;
            transition: transform 0.2s ease;
        }
        .custom-select-trigger.open svg {
            transform: rotate(180deg);
        }
        #npSeparatorDropdown {
            display: none;
            position: absolute;
            bottom: calc(100% + 4px);
            left: 0;
            width: 100%;
            background-color: #282828;
            border: 1px solid #434343;
            border-radius: 4px;
            z-index: 10;
            padding: 8px;
            box-sizing: border-box;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .separator-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        .separator-option {
            background-color: #3e3e3e;
            border: 1px solid #434343;
            color: white;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            text-align: center;
            transition: background-color 0.2s ease;
        }
        .separator-option:hover {
            background-color: #555;
        }
        .separator-option.selected {
            background-color: #1ED760;
            color: black;
            border-color: #1ED760;
        }
      </style>
      <div class="main-trackCreditsModal-header">
          <h1 class="main-trackCreditsModal-title"><span style='font-size: 25px;'>Now Playing Data Settings</span></h1>
      </div>
      <div class="main-trackCreditsModal-originalCredits" style="padding: 20px 32px !important;">
          <div class="np-settings-layout">
              <div class="np-settings-card">
                  <div class="np-setting-row">
                      <label for="npDataType">Data to Display</label>
                      <select id="npDataType">
                          <option value="releaseDate" ${selectedNowPlayingDataType === 'releaseDate' ? 'selected' : ''}>Release Date</option>
                          <option value="playCount" ${selectedNowPlayingDataType === 'playCount' ? 'selected' : ''}>Play Count</option>
                          <option value="popularity" ${selectedNowPlayingDataType === 'popularity' ? 'selected' : ''}>Popularity</option>
                          <option value="tempo" ${selectedNowPlayingDataType === 'tempo' ? 'selected' : ''}>Tempo (BPM)</option>
                          <option value="energy" ${selectedNowPlayingDataType === 'energy' ? 'selected' : ''}>Energy</option>
                          <option value="danceability" ${selectedNowPlayingDataType === 'danceability' ? 'selected' : ''}>Danceability</option>
                          <option value="valence" ${selectedNowPlayingDataType === 'valence' ? 'selected' : ''}>Valence</option>
                          <option value="key" ${selectedNowPlayingDataType === 'key' ? 'selected' : ''}>Key</option>
                      </select>
                  </div>
                  <div id="np-dynamic-settings">
                      <div id="np-release-date-settings">
                          <div class="np-setting-row">
                              <label for="npDateFormatSelect">Release Date Style</label>
                              <select id="npDateFormatSelect">
                                  <option value="YYYY">YYYY</option>
                                  <option value="YYYY-MM-DD">YYYY-MM-DD</option>
                                  <option value="MM-DD-YYYY">MM-DD-YYYY</option>
                                  <option value="DD-MM-YYYY">DD-MM-YYYY</option>
                                  <option value="MMM D, YYYY">Month D, YYYY</option>
                                  <option value="D MMM, YYYY">D Month, YYYY</option>
                                  <option value="YYYY, MMM D">YYYY, Month D</option>
                                  <option value="YYYY-MM">YYYY-MM</option>
                                  <option value="MM-YYYY">MM-YYYY</option>
                              </select>
                          </div>
                      </div>
                      <div id="np-play-count-settings">
                          <div class="np-setting-row">
                              <label for="npPlayCountFormatSelect">Play Count Style</label>
                              <select id="npPlayCountFormatSelect">
                                  <option value="raw">Full (1,234,567)</option>
                                  <option value="abbreviated">Short (1.2M)</option>
                                  <option value="rounded_abbreviated">Simple (1M)</option>
                              </select>
                          </div>
                      </div>
                      <div id="np-popularity-settings">
                          <div class="np-setting-row">
                              <label for="npPopularityFormatSelect">Popularity Style</label>
                              <select id="npPopularityFormatSelect">
                                  <option value="raw">Raw Number (e.g., 75)</option>
                                  <option value="with_label">With Label (e.g., Pop: 75)</option>
                                  <option value="percentage">Percentage (e.g., 75%)</option>
                                  <option value="tier">Tier (e.g., Popular)</option>
                              </select>
                          </div>
                      </div>
                      <div id="np-tempo-settings">
                          <div class="np-setting-row">
                              <label for="npTempoFormatSelect">Tempo Style</label>
                              <select id="npTempoFormatSelect">
                                  <option value="with_unit">With Unit (120 BPM)</option>
                                  <option value="raw">Raw Number (120)</option>
                              </select>
                          </div>
                      </div>
                      <div id="np-energy-settings">
                          <div class="np-setting-row">
                              <label for="npEnergyFormatSelect">Energy Style</label>
                              <select id="npEnergyFormatSelect">
                                  <option value="percentage">Percentage (50%)</option>
                                  <option value="with_unit">With Unit (50 Energy)</option>
                                  <option value="raw">Raw (50)</option>
                                  <option value="decimal">Decimal (0.50)</option>
                                  <option value="tier">Tier (Medium)</option>
                              </select>
                          </div>
                      </div>
                      <div id="np-danceability-settings">
                          <div class="np-setting-row">
                              <label for="npDanceabilityFormatSelect">Danceability Style</label>
                              <select id="npDanceabilityFormatSelect">
                                  <option value="percentage">Percentage (50%)</option>
                                  <option value="with_unit">With Unit (50 Dance)</option>
                                  <option value="raw">Raw (50)</option>
                                  <option value="decimal">Decimal (0.50)</option>
                                  <option value="tier">Tier (Medium)</option>
                              </select>
                          </div>
                      </div>
                      <div id="np-valence-settings">
                          <div class="np-setting-row">
                              <label for="npValenceFormatSelect">Valence Style</label>
                              <select id="npValenceFormatSelect">
                                  <option value="percentage">Percentage (50%)</option>
                                  <option value="with_unit">With Unit (50 Valence)</option>
                                  <option value="raw">Raw (50)</option>
                                  <option value="decimal">Decimal (0.50)</option>
                                  <option value="tier">Tier (Medium)</option>
                              </select>
                          </div>
                      </div>
                      <div id="np-key-settings">
                          <div class="np-setting-row">
                              <label for="npKeyFormatSelect">Key Style</label>
                              <select id="npKeyFormatSelect">
                                  <option value="standard">Standard (e.g., C\u266F/D\u266D)</option>
                                  <option value="full_name">Full Name (e.g., C\u266F Minor)</option>
                                  <option value="camelot">Camelot (e.g., 12A)</option>
                                  <option value="openkey">Open Key (e.g., 5m)</option>
                              </select>
                          </div>
                      </div>
                  </div>
              </div>
              <div class="np-settings-card">
                  <div class="np-setting-row">
                      <label for="npDataPosition">Display Position</label>
                      <select id="npDataPosition">
                          <option value=".main-trackInfo-name" ${selectedNowPlayingDataPosition === '.main-trackInfo-name' ? 'selected' : ''}>Next to Title</option>
                          <option value=".main-trackInfo-artists" ${selectedNowPlayingDataPosition === '.main-trackInfo-artists' ? 'selected' : ''}>Next to Artist</option>
                      </select>
                  </div>
                  <div style="margin-top: 8px;">
                      <div class="np-setting-row">
                          <label>Separator Style</label>
                          <div class="custom-select-wrapper">
                              <button id="npSeparatorTrigger" class="custom-select-trigger">
                                  <span id="npSeparatorDisplay"></span>
                                  <svg fill="currentColor" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"></path></svg>
                              </button>
                              <div id="npSeparatorDropdown">
                                  <div class="separator-grid">
                                  </div>
                              </div>
                          </div>
                      </div>
                  </div>
              </div>
          </div>
          <div style="display: flex; justify-content: flex-end; margin-top: 24px;">
              <button id="doneNowPlayingSettings" class="main-buttons-button main-button-primary" style="padding: 8px 18px; border-radius: 20px; border: none; cursor: pointer; background-color: #1ED760; color: black; font-weight: 550; font-size: 13px; text-transform: uppercase;">Done</button>
          </div>
      </div>
    `;
    
    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);

    const dataTypeSelect = modalContainer.querySelector("#npDataType");
    const dataPositionSelect = modalContainer.querySelector("#npDataPosition");
    const doneButton = modalContainer.querySelector("#doneNowPlayingSettings");
    
    const releaseDateSettings = modalContainer.querySelector("#np-release-date-settings");
    const dateFormatSelect = modalContainer.querySelector("#npDateFormatSelect");
    const playCountSettings = modalContainer.querySelector("#np-play-count-settings");
    const playCountFormatSelect = modalContainer.querySelector("#npPlayCountFormatSelect");
    const popularitySettings = modalContainer.querySelector("#np-popularity-settings");
    const popularityFormatSelect = modalContainer.querySelector("#npPopularityFormatSelect");
    const tempoSettings = modalContainer.querySelector("#np-tempo-settings");
    const tempoFormatSelect = modalContainer.querySelector("#npTempoFormatSelect");
    const energySettings = modalContainer.querySelector("#np-energy-settings");
    const energyFormatSelect = modalContainer.querySelector("#npEnergyFormatSelect");
    const energyWaveSettingsBtn = modalContainer.querySelector("#energyWaveSettingsBtn");
    const danceabilitySettings = modalContainer.querySelector("#np-danceability-settings");
    const danceabilityFormatSelect = modalContainer.querySelector("#npDanceabilityFormatSelect");
    const valenceSettings = modalContainer.querySelector("#np-valence-settings");
    const valenceFormatSelect = modalContainer.querySelector("#npValenceFormatSelect");
    const keySettings = modalContainer.querySelector("#np-key-settings");
    const keyFormatSelect = modalContainer.querySelector("#npKeyFormatSelect");
    const separatorTrigger = modalContainer.querySelector("#npSeparatorTrigger");
    const separatorDisplay = modalContainer.querySelector("#npSeparatorDisplay");
    const separatorDropdown = modalContainer.querySelector("#npSeparatorDropdown");
    const separatorGrid = modalContainer.querySelector(".separator-grid");

    const separatorOptions = [
        { value: 'â€¢', text: 'â€¢' }, { value: 'â—', text: 'â—' }, { value: 'â–ª', text: 'â–ª' }, { value: 'â– ', text: 'â– ' },
        { value: 'â–¢', text: 'â–¢' }, { value: '|', text: '|' }, { value: 'âš', text: 'âš' }, { value: '-', text: '-' },
        { value: 'â€“', text: 'â€“' }, { value: 'â€”', text: 'â€”' }, { value: '/', text: '/' }, { value: '//', text: '//' },
        { value: 'ã€¢', text: 'ã€¢' }, { value: '::', text: '::' }, { value: 'â‰¡', text: 'â‰¡' }, { value: 'â–º', text: 'â–º' },
        { value: 'â–¸', text: 'â–¸' }, { value: 'âž”', text: 'âž”' }, { value: 'â—†', text: 'â—†' }, { value: 'âœ¦', text: 'âœ¦' },
        { value: 'â˜…', text: 'â˜…' }, { value: 'âœ¶', text: 'âœ¶' }, { value: 'âœµ', text: 'âœµ' }, { value: 'âœ³', text: 'âœ³' },
        { value: 'â™ª', text: 'â™ª' }, { value: 'âœ•', text: 'âœ•' }, { value: 'â•³', text: 'â•³' }, { value: ' ', text: 'ã…¤' }
    ];

    const initialOption = separatorOptions.find(opt => opt.value === selectedNowPlayingSeparator);
    separatorDisplay.textContent = initialOption ? initialOption.text : selectedNowPlayingSeparator;

    separatorOptions.forEach(option => {
        const optionButton = document.createElement('button');
        optionButton.className = 'separator-option';
        optionButton.textContent = option.text;
        optionButton.dataset.value = option.value;
        if (option.value === selectedNowPlayingSeparator) {
            optionButton.classList.add('selected');
        }
        optionButton.addEventListener('click', (e) => {
            e.stopPropagation();
            selectedNowPlayingSeparator = option.value;
            separatorDisplay.textContent = option.text;
            
            separatorGrid.querySelectorAll('.separator-option').forEach(btn => btn.classList.remove('selected'));
            optionButton.classList.add('selected');
            
            saveSettings();
            displayNowPlayingData();
        });
        separatorGrid.appendChild(optionButton);
    });

    separatorTrigger.addEventListener('click', (e) => {
        e.stopPropagation();
        const isOpen = separatorDropdown.style.display === 'block';
        separatorDropdown.style.display = isOpen ? 'none' : 'block';
        separatorTrigger.classList.toggle('open', !isOpen);
    });

    const closeDropdownHandler = (e) => {
        if (!separatorDropdown.contains(e.target) && e.target !== separatorTrigger && !separatorTrigger.contains(e.target)) {
            separatorDropdown.style.display = 'none';
            separatorTrigger.classList.remove('open');
        }
    };
    document.addEventListener('click', closeDropdownHandler, true);

    const closeModal = () => {
        document.removeEventListener('click', closeDropdownHandler, true);
        overlay.remove();
    };

    function updateDynamicSettingsVisibility() {
        const selectedType = dataTypeSelect.value;
        releaseDateSettings.style.display = selectedType === 'releaseDate' ? 'block' : 'none';
        playCountSettings.style.display = selectedType === 'playCount' ? 'block' : 'none';
        popularitySettings.style.display = selectedType === 'popularity' ? 'block' : 'none';
        tempoSettings.style.display = selectedType === 'tempo' ? 'block' : 'none';
        energySettings.style.display = selectedType === 'energy' ? 'block' : 'none';
        danceabilitySettings.style.display = selectedType === 'danceability' ? 'block' : 'none';
        valenceSettings.style.display = selectedType === 'valence' ? 'block' : 'none';
        keySettings.style.display = selectedType === 'key' ? 'block' : 'none';
    }

    dataTypeSelect.addEventListener("change", () => {
        selectedNowPlayingDataType = dataTypeSelect.value;
        const mainSettingsSelect = document.querySelector("#nowPlayingDataTypeSelect");
        if (mainSettingsSelect) mainSettingsSelect.value = selectedNowPlayingDataType;
        saveSettings();
        displayNowPlayingData();
        updateDynamicSettingsVisibility();
    });

    dataPositionSelect.addEventListener("change", () => {
        selectedNowPlayingDataPosition = dataPositionSelect.value;
        saveSettings();
        displayNowPlayingData();
    });

    dateFormatSelect.value = selectedNowPlayingDateFormat;
    dateFormatSelect.addEventListener("change", () => {
        selectedNowPlayingDateFormat = dateFormatSelect.value;
        saveSettings();
        displayNowPlayingData();
    });

    playCountFormatSelect.value = selectedNowPlayingPlayCountFormat;
    playCountFormatSelect.addEventListener("change", () => {
        selectedNowPlayingPlayCountFormat = playCountFormatSelect.value;
        saveSettings();
        displayNowPlayingData();
    });

    popularityFormatSelect.value = selectedNowPlayingPopularityFormat;
    popularityFormatSelect.addEventListener("change", () => {
        selectedNowPlayingPopularityFormat = popularityFormatSelect.value;
        saveSettings();
        displayNowPlayingData();
    });

    tempoFormatSelect.value = selectedNowPlayingTempoFormat;
    tempoFormatSelect.addEventListener("change", () => {
        selectedNowPlayingTempoFormat = tempoFormatSelect.value;
        saveSettings();
        displayNowPlayingData();
    });

    energyFormatSelect.value = selectedNowPlayingEnergyFormat;
    energyFormatSelect.addEventListener("change", () => {
        selectedNowPlayingEnergyFormat = energyFormatSelect.value;
        saveSettings();
        displayNowPlayingData();
    });

    danceabilityFormatSelect.value = selectedNowPlayingDanceabilityFormat;
    danceabilityFormatSelect.addEventListener("change", () => {
        selectedNowPlayingDanceabilityFormat = danceabilityFormatSelect.value;
        saveSettings();
        displayNowPlayingData();
    });

    valenceFormatSelect.value = selectedNowPlayingValenceFormat;
    valenceFormatSelect.addEventListener("change", () => {
        selectedNowPlayingValenceFormat = valenceFormatSelect.value;
        saveSettings();
        displayNowPlayingData();
    });

    keyFormatSelect.value = selectedNowPlayingKeyFormat;
    keyFormatSelect.addEventListener("change", () => {
        selectedNowPlayingKeyFormat = keyFormatSelect.value;
        saveSettings();
        displayNowPlayingData();
    });

    doneButton.addEventListener("click", closeModal);
    overlay.addEventListener("click", (e) => { if (e.target === overlay) closeModal(); });

    updateDynamicSettingsVisibility();
  }

  function showSupportModal() {
    const overlay = document.createElement("div");
    overlay.id = "sort-play-support-overlay";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 2002;
        display: flex; justify-content: center; align-items: center;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container sort-play-font-scope";
    modalContainer.style.cssText = `
        z-index: 2003;
        width: 500px !important;
        display: flex;
        flex-direction: column;
    `;

    const wallets = [
        { name: 'USDT (TRC20) / TRON', address: 'TU3tiVV3NLmFetXrsAZnuE9qu8JVSHDuAH' },
        { name: 'TON', address: 'UQAFHn9aGKqTn1Vku5xSuPCkkvVbnfnN20B1RwijthZ8a2OE' },
        { name: 'Bitcoin (BTC)', address: 'bc1q0vvhyffnk8s0g9hnf4k2c7z6ys3r2d7x6fjnvv' },
    ];

    let walletsHtml = wallets.map(wallet => `
        <div class="wallet-entry">
            <label class="wallet-label">${wallet.name}</label>
            <div class="wallet-address-container">
                <input type="text" class="wallet-address" value="${wallet.address}" readonly>
                <button class="copy-button" data-address="${wallet.address}" title="Copy Address">
                    ${copyIconSVG}
                </button>
            </div>
        </div>
    `).join('');

    modalContainer.innerHTML = `
      <style>
        .support-modal-content { display: flex; flex-direction: column; gap: 16px; }
        .wallet-entry { display: flex; flex-direction: column; gap: 6px; }
        .wallet-label { color: #c1c1c1; font-size: 14px; font-weight: 500; }
        .wallet-address-container { display: flex; align-items: center; gap: 8px; }
        .wallet-address { 
            flex-grow: 1; 
            background-color: #121212; 
            border: 1px solid #333; 
            border-radius: 4px; 
            padding: 8px 12px; 
            color: #fff; 
            font-family: monospace; 
            font-size: 11px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .copy-button { 
            flex-shrink: 0;
            background-color: #333; 
            border: 1px solid #555;
            color: #fff; 
            padding: 6px 6px; 
            border-radius: 4px; 
            cursor: pointer; 
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
            width: 32px;
            height: 32px;
        }
        .copy-button:hover { background-color: #444; }
        .copy-button.copied {
            background-color: #1ED760;
            color: black;
        }
        .copy-button.copied:hover {
            background-color: #1ED760;
        }
        .copy-button svg { width: 16px; height: 16px; }
      </style>
      <div class="main-trackCreditsModal-header">
          <h1 class="main-trackCreditsModal-title"><span style='font-size: 25px;'>Support Sort-Play</span></h1>
      </div>
      <div class="main-trackCreditsModal-mainSection" style="padding: 22px 47px 20px !important; max-height: 60vh; flex-grow: 1;">
        <p style="color: #c1c1c1; font-size: 16px; margin-bottom: 25px;">If you enjoy using Sort-Play, please consider supporting its development. Thank you!</p>
        <div class="support-modal-content">
            ${walletsHtml}
        </div>
      </div>
      <div class="main-trackCreditsModal-originalCredits" style="padding: 15px 24px !important; border-top: 1px solid #282828; flex-shrink: 0;">
        <div style="display: flex; justify-content: flex-end;">
            <button id="closeSupportModal" class="main-buttons-button main-button-primary" 
                    style="background-color: #1ED760; color: black; padding: 8px 18px; border-radius: 20px; font-weight: 550; font-size: 13px; text-transform: uppercase; border: none; cursor: pointer;">
                Done
            </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);

    modalContainer.querySelectorAll('.copy-button').forEach(button => {
        button.addEventListener('click', () => {
            const address = button.dataset.address;
            navigator.clipboard.writeText(address).then(() => {
                showNotification('Address copied to clipboard!');
                button.classList.add('copied');
                setTimeout(() => {
                    button.classList.remove('copied');
                }, 1000);
            }, (err) => {
                showNotification('Failed to copy address.', true);
                console.error('Could not copy text: ', err);
            });
        });
    });

    const closeModal = () => overlay.remove();
    
    const doneButton = modalContainer.querySelector("#closeSupportModal");
    if (doneButton) {
        doneButton.addEventListener("click", closeModal);
        
        doneButton.addEventListener("mouseenter", () => {
            doneButton.style.backgroundColor = "#3BE377";
        });
        doneButton.addEventListener("mouseleave", () => {
            doneButton.style.backgroundColor = "#1ED760";
        });
    }

    overlay.addEventListener("click", (e) => {
        if (e.target === overlay) {
            closeModal();
        }
    });
  }

  function showCreatePlaylistModal() {
    const overlay = document.createElement("div");
    overlay.id = "sort-play-create-playlist-overlay";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        z-index: 2002;
        display: flex; justify-content: center; align-items: center;
        opacity: 0;
        transition: opacity 0.2s ease;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container sort-play-font-scope";
    modalContainer.style.cssText = `
        z-index: 2003;
        width: 1100px !important;
        max-width: 62vw;
        height: auto;
        max-height: 80vh;
        background-color: #121212 !important;
        border: 1px solid #333;
        display: flex;
        flex-direction: column;
        border-radius: 30px;
        box-shadow: 0 20px 50px rgba(0,0,0,0.6);
    `;

    const shadowRoot = modalContainer.attachShadow({ mode: 'open' });
    modalContainer.querySelector = (sel) => shadowRoot.querySelector(sel);
    modalContainer.querySelectorAll = (sel) => shadowRoot.querySelectorAll(sel);

    const cachedCounts = JSON.parse(localStorage.getItem(STORAGE_KEY_GLOBAL_PLAYLIST_COUNTS) || '{}');
    let dedicatedPlaylistBehavior = JSON.parse(localStorage.getItem(STORAGE_KEY_DEDICATED_PLAYLIST_BEHAVIOR) || '{}');
    const jobs = getDedicatedJobs();
    
    jobs.forEach(job => {
        if (job.dedicatedType && dedicatedJobRunners[job.dedicatedType]) {
            dedicatedPlaylistBehavior[job.dedicatedType] = 'autoUpdate';
        }
    });

    const getScheduleBadgeText = (schedule) => {
        if (!schedule) return "AUTO";
        const map = {
            10800000: "3H", 21600000: "6H", 43200000: "12H", 86400000: "DAILY",
            172800000: "2 DAYS", 604800000: "WEEKLY", 2592000000: "MONTHLY",
            'release-weekly': "WEEKLY (FRI)",
            'release-every-two-weeks': "BI-WEEKLY (FRI)",
            'release-monthly': "MONTHLY (FRI)"
        };
        if (map[schedule]) return map[schedule];
        if (typeof schedule === 'number') {
            if (schedule < 3600000) {
                const minutes = Math.round(schedule / 60000);
                return `EVERY ${minutes}MIN`;
            }
            const hours = schedule / 3600000;
            if (hours < 24) return `EVERY ${Math.round(hours)}H`;
            const days = hours / 24;
            return `EVERY ${Math.round(days)}D`;
        }
        return "AUTO";
    };

    const getBadgeHtml = (mode, cardId) => {
        if (mode === 'replace') return `<span class="mode-badge replace">REPLACE</span>`;
        if (mode === 'autoUpdate') {
            const currentJobs = getDedicatedJobs();
            const job = currentJobs.find(j => j.dedicatedType === cardId);
            const text = job ? getScheduleBadgeText(job.schedule) : "AUTO";
            return `<span class="mode-badge auto">${text}</span>`;
        }
        return ''; 
    };

    const generateCardsHtml = (cards, category) => {
        let rgbColor = '0, 0, 0';
        if (category === 'discovery') {
            rgbColor = '143, 70, 215';
        } else if (category === 'newReleases') {
            rgbColor = '55, 152, 165';
        } else if (category === 'topTracks') {
            rgbColor = '36, 191, 112';
        } else if (category === 'lastFm') {
            rgbColor = '209, 23, 14';
        }       

        return cards.map(card => {
            const isBroken = !!card.broken;
            const behavior = dedicatedPlaylistBehavior[card.id] || 'createOnce';
            const badgeHtml = getBadgeHtml(behavior, card.id);
            const allowSettings = card.id !== 'genreTreeExplorer' && !isBroken;

            const autoBtnContent = behavior === 'autoUpdate' 
                ? `Auto ${settingsSvg.replace('<svg', '<svg width="12" height="12" fill="currentColor" style="margin-left: 4px; opacity: 0.8;"')}` 
                : `Auto`;

            const cachedCount = cachedCounts[card.id];
            const hasCached = cachedCount !== undefined && cachedCount !== null;
            const opacityStyle = hasCached ? '1' : '0';
            const countText = hasCached ? cachedCount.toLocaleString() : '';

            return `
                <div class="slim-card ${isBroken ? 'broken-card' : ''}" data-id="${card.id}" data-name="${card.name}" style="--overlay-color: ${rgbColor};">
                    <div class="card-bg" style="background-image: url('${card.thumbnailUrl}');"></div>
                    <div class="card-overlay"></div>
                    ${isBroken ? `<div class="broken-overlay"><span>Unavailable</span></div>` : ''}
                    
                    <div class="card-content-wrapper" style="padding-bottom: 14px;">
                        <div class="card-text">
                            <div class="card-title-row">
                                <span class="card-title">${card.name}</span>
                                ${card.version ? `<span class="card-version-tag">${card.version}</span>` : ''}
                                <span class="badge-container">${badgeHtml}</span>
                            </div>
                            <span class="card-desc">${card.description}</span>
                        </div>
                    </div>

                    <div class="global-stats" data-id="${card.id}" style="position: absolute; bottom: 6px; left: 12px; z-index: 3; display: flex; align-items: center; gap: 4px; opacity: ${opacityStyle}; transition: opacity 0.5s ease;">
                        <svg width="10" height="10" viewBox="0 0 24 24" fill="#1ed760"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
                        <span class="stats-count" style="font-size: 10px; font-weight: 700; color: #1ed760; letter-spacing: 0.5px; font-variant-numeric: tabular-nums;">${countText}</span>
                        <span style="font-size: 10px; color: #888;">global creations</span>
                    </div>

                    ${allowSettings ? `
                    <button class="settings-trigger" title="Configure">
                        ${settingsSvg.replace('<svg', '<svg fill="#fff" width="14" height="14"')}
                    </button>
                    <div class="settings-overlay-panel">
                        <div class="settings-options">
                            <button class="mode-btn ${behavior === 'createOnce' ? 'active' : ''}" data-val="createOnce">Once</button>
                            <button class="mode-btn ${behavior === 'replace' ? 'active' : ''}" data-val="replace">Replace</button>
                            <button class="mode-btn ${behavior === 'autoUpdate' ? 'active' : ''}" data-val="autoUpdate">${autoBtnContent}</button>
                        </div>
                        <button class="close-settings">Ã—</button>
                    </div>
                    ` : ''}
                </div>
            `;
        }).join('');
    };

    const newReleasesData = playlistCardsData.find(s => s.title === 'New Releases');
    const discoveryData = playlistCardsData.find(s => s.title === 'Discovery');
    const topTracksData = playlistCardsData.find(s => s.title === 'My Top Tracks');
    const lastFmData = playlistCardsData.find(s => s.title === 'Last.fm');

    let contentHtml = `<div class="columns-container">`;
    
    contentHtml += `<div class="category-column">`;
    
    if (newReleasesData) {
        contentHtml += `
            <div class="category-section">
                <div class="category-header">${newReleasesData.title}</div>
                <div class="cards-stack">
                    ${generateCardsHtml(newReleasesData.cards, 'newReleases')}
                </div>
            </div>
        `;
    }

    if (topTracksData) {
        contentHtml += `
            <div class="category-section">
                <div class="category-header">${topTracksData.title}</div>
                <div class="cards-stack">
                    ${generateCardsHtml(topTracksData.cards, 'topTracks')}
                </div>
            </div>
        `;
    }
    
    contentHtml += `</div>`;

    contentHtml += `<div class="category-column">`;
    
    if (discoveryData) {
        contentHtml += `
            <div class="category-section">
                <div class="category-header">${discoveryData.title}</div>
                <div class="cards-stack">
                    ${generateCardsHtml(discoveryData.cards, 'discovery')}
                </div>
            </div>
        `;
    }
    
    contentHtml += `</div>`;

    contentHtml += `<div class="category-column">`;

    if (lastFmData) {
        contentHtml += `
            <div class="category-section">
                <div class="category-header">Last.fm Engine</div>
                <div class="cards-stack">
                    ${generateCardsHtml(lastFmData.cards, 'lastFm')}
                </div>
            </div>
        `;
    }
    
    contentHtml += `</div>`;
    
    contentHtml += `</div>`;

    shadowRoot.innerHTML = `
      <style>
        :host {
            font-family: 'SpotifyMixUI', sans-serif !important;
            color: #fff;
        }
        *, button, input, select, textarea { box-sizing: border-box; font-family: 'SpotifyMixUI', sans-serif !important; }
        h1 { margin: 0; line-height: normal; }
        .create-playlist-modal-body {
            flex-grow: 1;
            overflow-y: auto; 
            padding: 30px 30px;
            display: flex;
            flex-direction: column;
        }

        .columns-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 25px;
            height: 100%;
        }

        .category-column {
            display: flex;
            flex-direction: column;
            gap: 66px;
            min-width: 0;
            overflow-y: auto;
            scrollbar-width: none;
        }

        .category-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .category-header {
            font-size: 13px;
            font-weight: 700;
            color: #b3b3b3;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }

        .cards-stack {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .slim-card {
            position: relative;
            height: 85px;
            background-color: #252525;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            border: 1px solid transparent;
            user-select: none;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            transform: translateZ(0);
            transition: border-color 0.1s;
        }

        .slim-card:hover {
            z-index: 2;
        }
        
        .slim-card:has(.settings-overlay-panel.active) {
            border-color: transparent;
            z-index: 2;
        }

        .card-bg {
            position: absolute;
            top: 0; left: -4px; width: 102%; height: 102%;
            background-size: 100% auto;
            background-position: top center;
            filter: grayscale(0.2) brightness(0.7);
            
            transition: transform 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            will-change: transform;
            transform-origin: center center;
        }

        .slim-card:hover .card-bg, .slim-card:has(.settings-overlay-panel.active) .card-bg {
            transform: scale(1.03);
        }

        .card-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        
        .card-overlay::before,
        .card-overlay::after {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            transition: opacity 0.25s ease;
        }

        .card-overlay::before {
            background: linear-gradient(90deg, rgba(var(--overlay-color), 0.07) 0%, rgba(0,0,0,0.2) 100%);
            opacity: 1;
        }

        .card-overlay::after {
            background: linear-gradient(90deg, rgba(var(--overlay-color), 0.18) 0%, rgba(var(--overlay-color), 0.03) 100%);
            opacity: 0;
        }

        .slim-card:hover .card-overlay::before,
        .slim-card:has(.settings-overlay-panel.active) .card-overlay::before {
            opacity: 0;
        }

        .slim-card:hover .card-overlay::after,
        .slim-card:has(.settings-overlay-panel.active) .card-overlay::after {
            opacity: 1;
        }

        .card-content-wrapper {
            position: relative;
            z-index: 2;
            height: 100%;
            display: flex;
            align-items: center;
            padding: 0 40px 0 12px;
        }

        .card-text {
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 100%;
        }

        .card-title-row {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .card-title {
            color: #fff;
            font-weight: 700;
            font-size: 15px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        }

        .card-version-tag {
            font-size: 9px;
            font-weight: 700;
            color: #b3b3b3;
            background-color: rgb(255 255 255 / 9%);
            padding: 1px 4px;
            border-radius: 4px;
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .badge-container {
            display: flex;
            align-items: center;
            transition: opacity 0.2s ease;
        }

        .mode-badge {
            font-size: 10px;
            font-weight: 800;
            padding: 2px 5px;
            border-radius: 3px;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            display: inline-block;
            line-height: 1.1;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .mode-badge.replace {
            background-color: #3e2a0f; 
            color: #ffaa00; 
            border: 1px solid #5e431d;
        }
        
        .mode-badge.auto {
            background-color: #0f3318; 
            color: #1ed760;
            border: 1px solid #184f25;
        }

        .card-desc {
            color: #ddd;
            font-size: 12px;
            opacity: 0.8;
            margin-top: 3px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            white-space: normal;
            line-height: 1.2;
        }

        .settings-trigger {
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            width: 30px;
            z-index: 10;
            background: transparent;
            border: none;
            border-left: 1px solid transparent;
            display: flex; 
            align-items: center; 
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s, background-color 0.2s, border-color 0.2s;
            cursor: pointer;
        }
        .slim-card:hover .settings-trigger {
            opacity: 1;
        }
        .settings-trigger:hover {
            background-color: rgba(255,255,255,0.1);
            border-left-color: rgba(255,255,255,0.1);
        }

        .settings-overlay-panel {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgb(255 255 255 / 10%);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 30px 0 10px;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }
        .settings-overlay-panel.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .settings-options {
            display: flex;
            gap: 4px;
            background: #181818;
            padding: 3px;
            border-radius: 4px;
        }

        .mode-btn {
            background: transparent;
            border: none;
            color: #888;
            font-size: 11px;
            font-weight: 600;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .mode-btn:hover { color: #fff; background: #333; }
        .mode-btn.active {
            background: #1ED760;
            color: #000;
        }
        .mode-btn.active[data-val="autoUpdate"]:hover {
            background-color: #3BE377;
        }
        
        .close-settings {
            position: absolute;
            right: 0; top: 0; height: 100%; width: 30px;
            background: transparent; border: none;
            color: #888; font-size: 18px; cursor: pointer;
        }
        .close-settings:hover, .close-settings.hover { color: #fff; background: rgba(255,255,255,0.1); }

        .main-trackCreditsModal-closeBtn { background: transparent; border: 0; padding: 0; color: #b3b3b3; cursor: pointer; transition: color 0.2s ease; }

        .broken-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(12, 12, 12, 0.85);
            z-index: 15;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            backdrop-filter: blur(1px);
            opacity: 1;
        }

        .broken-overlay span {
            color: #ff5c5c;
            font-weight: 800;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            padding: 6px 14px;
            border-radius: 5px;
            background: rgba(255, 92, 92, 0.1);
            border: 1px solid rgba(255, 92, 92, 0.25);
            box-shadow: 0 0 15px rgba(255, 92, 92, 0.1);
            transition: all 0.2s ease;
        }

        .slim-card.broken-card {
            cursor: not-allowed;
            border-color: transparent !important;
            box-shadow: none !important;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .slim-card.broken-card:hover {
            transform: none !important;
            opacity: 1;
            z-index: 1 !important;
        }
        
        .slim-card.broken-card .card-bg {
            filter: grayscale(100%) contrast(120%) brightness(40%) !important;
            transform: none !important;
        }
        
        .slim-card.broken-card .card-overlay::before, 
        .slim-card.broken-card .card-overlay::after {
            display: none !important;
        }
        
        .main-trackCreditsModal-closeBtn:hover { color: #ffffff; }
      </style>

      <div class="main-trackCreditsModal-header" style="border-bottom: 1px solid #282828; display: flex; justify-content: space-between; align-items: center; padding: 29px 32px 19px 32px;">
          <h1 class="main-trackCreditsModal-title"><span style='font-size: 26px; font-weight: 700; color: white;'>Dedicated Playlist Creation</span></h1>
          <button id="closeCreatePlaylistModal" aria-label="Close" class="main-trackCreditsModal-closeBtn">
            <svg width="20" height="20" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M31.098 29.794L16.955 15.65 31.097 1.51 29.683.093 15.54 14.237 1.4.094-.016 1.508 14.126 15.65-.016 29.795l1.414 1.414L15.54 17.065l14.144 14.143" fill="currentColor" fill-rule="evenodd"></path></svg>
          </button>
      </div>
      <div class="create-playlist-modal-body">
        ${contentHtml}
      </div>
    `;
    
    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);

    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            overlay.style.opacity = "1";
        });
    });

    const animateValue = (obj, start, end, duration) => {
        if (start === end) return;
        let startTimestamp = null;
        const step = (timestamp) => {
            if (!startTimestamp) startTimestamp = timestamp;
            const progress = Math.min((timestamp - startTimestamp) / duration, 1);
            const ease = progress === 1 ? 1 : 1 - Math.pow(2, -10 * progress);
            
            const current = Math.floor(ease * (end - start) + start);
            obj.textContent = current.toLocaleString();

            if (progress < 1) {
                window.requestAnimationFrame(step);
            } else {
                obj.textContent = end.toLocaleString();
            }
        };
        window.requestAnimationFrame(step);
    };

    fetch(`${STATS_URL}/counts`)
        .then(res => res.json())
        .then(data => {
            localStorage.setItem(STORAGE_KEY_GLOBAL_PLAYLIST_COUNTS, JSON.stringify(data));
            Object.entries(data).forEach(([key, count]) => {
                const statEl = modalContainer.querySelector(`.global-stats[data-id="${key}"]`);
                if (statEl) {
                    const countEl = statEl.querySelector('.stats-count');
                    const currentValStr = countEl.textContent.replace(/,/g, '');
                    const currentVal = currentValStr ? parseInt(currentValStr, 10) : 0;
                    
                    if (statEl.style.opacity === '0' || statEl.style.opacity === '') {
                        countEl.textContent = count.toLocaleString();
                        statEl.style.opacity = '1';
                    } else if (currentVal !== count) {
                        animateValue(countEl, currentVal, count, 1000);
                    }
                }
            });
        })
        .catch(() => {});

    const closeModal = () => {
        overlay.style.opacity = "0";
        setTimeout(() => overlay.remove(), 200);
    };

    modalContainer.querySelectorAll('.slim-card').forEach(card => {
        card.addEventListener('click', async (e) => {
            if (card.classList.contains('broken-card')) {
                e.stopPropagation();
                return;
            }
            if (e.target.closest('.settings-trigger') || e.target.closest('.settings-overlay-panel')) return;
            if (e.target === card) return;

            const cardId = card.getAttribute('data-id');
            const behavior = dedicatedPlaylistBehavior[cardId] || 'createOnce';
            
            if (behavior === 'autoUpdate') {
                const jobs = getDedicatedJobs();
                const job = jobs.find(j => j.dedicatedType === cardId);
                if (job) {
                    job.lastRun = Date.now();
                    updateDedicatedJob(job);
                }
            }

            if (cardId === 'neighborsMix') {
                const hasUsername = loadLastFmUsername();
                if (!hasUsername) {
                    const result = await showConfirmationModal({
                        title: "Last.fm Account Required",
                        description: "The Neighbors Mix requires a Last.fm username to find listeners with similar taste. Do you have an active Last.fm account linked to your Spotify?",
                        confirmText: "I have one",
                        cancelText: "I don't have one"
                    });

                    if (result === 'confirm') {
                        showLastFmUsernameModal(() => {
                            closeModal(); 
                            generateNeighborsMix();
                        });
                    }
                    return;
                }
            }

            closeModal();
            if (cardId === 'genreTreeExplorer') {
                showGenreTreeExplorerModal();
            } else if (cardId === 'randomGenreExplorer') {
                generateRandomGenrePlaylist();
            } else if (cardId === 'neighborsMix') {
                generateNeighborsMix();
            } else if (cardId === 'infiniteVibe') {
                generateInfiniteVibe();
            } else {
                handleSortAndCreatePlaylist(cardId);
            }
        });
    });

    modalContainer.querySelectorAll('.settings-trigger').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const card = btn.closest('.slim-card');
            const panel = card.querySelector('.settings-overlay-panel');
            const closeBtn = panel.querySelector('.close-settings');
            
            modalContainer.querySelectorAll('.settings-overlay-panel.active').forEach(p => p.classList.remove('active'));
            panel.classList.add('active');
            
            closeBtn.classList.add('hover');
            closeBtn.addEventListener('mouseleave', () => {
                closeBtn.classList.remove('hover');
            }, { once: true });
        });
    });

    modalContainer.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const newVal = btn.dataset.val;
            const card = btn.closest('.slim-card');
            const cardId = card.dataset.id;
            const cardName = card.dataset.name;
            const oldBehavior = dedicatedPlaylistBehavior[cardId] || 'createOnce';
            const badgeContainer = card.querySelector('.badge-container');

            const updateUI = (val) => {
                card.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b.dataset.val === val));
                
                dedicatedPlaylistBehavior[cardId] = val;
                localStorage.setItem(STORAGE_KEY_DEDICATED_PLAYLIST_BEHAVIOR, JSON.stringify(dedicatedPlaylistBehavior));
                
                const autoBtn = card.querySelector('.mode-btn[data-val="autoUpdate"]');
                if (autoBtn) {
                    if (val === 'autoUpdate') {
                        autoBtn.innerHTML = `Auto ${settingsSvg.replace('<svg', '<svg width="12" height="12" fill="currentColor" style="margin-left: 4px; opacity: 0.8;"')}`;
                    } else {
                        setTimeout(() => {
                            if (dedicatedPlaylistBehavior[cardId] !== 'autoUpdate') {
                                autoBtn.innerHTML = `Auto`;
                            }
                        }, 550);
                    }
                }

                setTimeout(() => {
                    badgeContainer.style.opacity = '0';
                    setTimeout(() => {
                        badgeContainer.innerHTML = getBadgeHtml(val, cardId);
                        badgeContainer.style.opacity = '1';
                    }, 200);
                }, 550);

                setTimeout(() => {
                    const panel = card.querySelector('.settings-overlay-panel');
                    if (panel) panel.classList.remove('active');
                }, 300);
            };

            if (newVal === 'autoUpdate') {
                if (oldBehavior === 'autoUpdate') {
                     const newScheduleText = await showDedicatedScheduleModal(cardId, cardName);
                     if (newScheduleText) {
                         badgeContainer.style.opacity = '0';
                         setTimeout(() => {
                             badgeContainer.innerHTML = getBadgeHtml('autoUpdate', cardId);
                             badgeContainer.style.opacity = '1';
                         }, 200);
                         updateUI('autoUpdate');
                     }
                } else {
                    const newScheduleText = await showDedicatedScheduleModal(cardId, cardName);
                    if (newScheduleText) {
                        updateUI('autoUpdate');
                    }
                }
            } else {
                if (oldBehavior === 'autoUpdate') {
                    const jobs = getDedicatedJobs();
                    const job = jobs.find(j => j.dedicatedType === cardId);
                    if (job) deleteDedicatedJob(job.id);
                }
                updateUI(newVal);
            }
        });
    });

    modalContainer.querySelectorAll('.close-settings').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            btn.closest('.settings-overlay-panel').classList.remove('active');
        });
    });

    modalContainer.querySelector("#closeCreatePlaylistModal").addEventListener("click", closeModal);
    overlay.addEventListener("click", (e) => { if (e.target === overlay) closeModal(); });
  }

  function showDedicatedScheduleModal(cardId, cardName) {
    return new Promise((resolve) => {
        const overlay = document.createElement("div");
        overlay.id = "sort-play-dedicated-schedule-overlay";
        overlay.className = "sort-play-font-scope";
        overlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); z-index: 2004;
            display: flex; justify-content: center; align-items: center;
        `;

        const modalContainer = document.createElement("div");
        modalContainer.className = "main-embedWidgetGenerator-container";
        modalContainer.style.zIndex = "2005";
        modalContainer.style.width = "500px";
        modalContainer.style.borderRadius = "20px";
        
        
        const scheduleToShortTextMap = {
            'release-every-two-weeks': 'Every 2 Weeks (Fri)',
            'release-monthly': 'Monthly (Fri)'
        };
        
        const jobs = getDedicatedJobs();
        const job = jobs.find(j => j.dedicatedType === cardId);
        const currentSchedule = job ? job.schedule : '86400000';

        const customSchedules = getCustomSchedules();
        const customScheduleOptions = customSchedules.map(s => `<option value="${s.value}" ${String(currentSchedule) === String(s.value) ? 'selected' : ''}>${s.text}</option>`).join('');

        let clearAndSeparatorHtml = '';
        if (customSchedules.length > 0) {
            clearAndSeparatorHtml = `
                <option value="clear-custom" style="color: #f15e6c; font-style: italic;">Clear Custom Schedules...</option>
            `;
        }

        modalContainer.innerHTML = `
          <style>
            .form-select {
                width: 100%; background: #282828; color: white; border: 1px solid #666;
                border-radius: 15px; padding: 8px 12px; padding-right: 32px; font-size: 13px; cursor: pointer;
                -webkit-appearance: none; -moz-appearance: none; appearance: none;
                background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
                background-repeat: no-repeat; background-position: right 12px center; background-size: 16px;
            }
            .custom-schedule-container { display: none; align-items: center; gap: 8px; margin-top: 16px; padding: 10px; background-color: #3e3e3e; border-radius: 8px; }
            .custom-schedule-container.visible { display: flex; }
            .custom-schedule-container input[type="number"] { width: 60px; padding: 6px; border-radius: 4px; border: 1px solid #666; background-color: #282828; color: white; text-align: center; }
            .custom-schedule-container label { font-size: 12px; color: #b3b3b3; }
            .custom-schedule-ok-btn { padding: 6px 12px; border-radius: 15px; border: none; background-color: #1ed760; color: black; font-weight: bold; cursor: pointer; }
            .main-buttons-button.main-button-primary { background-color: #1ED760; color: black; transition: background-color 0.1s ease;}
            .main-buttons-button.main-button-primary:hover { background-color: #3BE377; }
            .main-buttons-button.main-button-secondary { background-color: #333333; color: white; transition: background-color 0.1s ease; }
            .main-buttons-button.main-button-secondary:hover { background-color: #444444; }
          </style>
          <div class="main-trackCreditsModal-header">
              <h1 class="main-trackCreditsModal-title"><span style='font-size: 25px;'>Auto-Update Schedule</span></h1>
          </div>
          <div class="main-trackCreditsModal-originalCredits" style="padding: 20px 32px !important;">
              <p style="color: #c1c1c1; font-size: 16px; margin-bottom: 20px;">Set the update frequency for "${cardName}":</p>
              <select id="dedicated-schedule-select" class="form-select" style="width: 100%; margin-bottom: 10px;">
                  <option value="10800000" ${String(currentSchedule) === '10800000' ? 'selected' : ''}>Every 3 Hours</option>
                  <option value="21600000" ${String(currentSchedule) === '21600000' ? 'selected' : ''}>Every 6 Hours</option>
                  <option value="43200000" ${String(currentSchedule) === '43200000' ? 'selected' : ''}>Every 12 Hours</option>
                  <option value="86400000" ${String(currentSchedule) === '86400000' ? 'selected' : ''}>Daily</option>
                  <option value="172800000" ${String(currentSchedule) === '172800000' ? 'selected' : ''}>Every 2 Days</option>
                  <option value="604800000" ${String(currentSchedule) === '604800000' ? 'selected' : ''}>Weekly</option>
                  <option value="2592000000" ${String(currentSchedule) === '2592000000' ? 'selected' : ''}>Monthly</option>
                  <option disabled>- Release Day Schedules -</option>
                  <option value="release-weekly" ${currentSchedule === 'release-weekly' ? 'selected' : ''}>Weekly (on Friday)</option>
                  <option value="release-every-two-weeks" ${currentSchedule === 'release-every-two-weeks' ? 'selected' : ''}>Every Two Weeks (on Friday)</option>
                  <option value="release-monthly" ${currentSchedule === 'release-monthly' ? 'selected' : ''}>Monthly (on a Friday)</option>
                  <option disabled>- Custom Schedules -</option>
                  ${customScheduleOptions}
                  <option value="custom">+ Custom</option>
                  ${clearAndSeparatorHtml}
              </select>
              <div id="custom-schedule-container" class="custom-schedule-container">
                  <input type="number" id="days" min="0" value="0"><label for="days">d</label>
                  <input type="number" id="hours" min="0" max="23" value="0"><label for="hours">h</label>
                  <input type="number" id="minutes" min="0" max="59" value="0"><label for="minutes">m</label>
                  <button id="set-custom-schedule-btn" class="custom-schedule-ok-btn">Set</button>
              </div>
              <div id="custom-schedule-error" style="color: #f15e6c; font-size: 12px; text-align: right; margin-top: 4px; display: none;"></div>
              <label id="custom-schedule-min-label" style="font-size: 12px; color: #b3b3b3; text-align: right; display: none; margin-top: 4px;">Minimum: ${SCHEDULER_INTERVAL_MINUTES} minutes</label>
              <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                  <button id="cancel-schedule" class="main-buttons-button main-button-secondary" style="padding: 8px 18px; border-radius: 20px; font-weight: 550; font-size: 13px; text-transform: uppercase; cursor: pointer; border: none;">Cancel</button>
                  <button id="save-schedule" class="main-buttons-button main-button-primary" style="padding: 8px 18px; border-radius: 20px; font-weight: 550; font-size: 13px; text-transform: uppercase; cursor: pointer; border: none;">Save</button>
              </div>
          </div>
        `;
        
        document.body.appendChild(overlay);
        overlay.appendChild(modalContainer);

        const closeModal = () => overlay.remove();

        const scheduleSelect = modalContainer.querySelector('#dedicated-schedule-select');
        const customScheduleContainer = modalContainer.querySelector('#custom-schedule-container');
        const minLabel = modalContainer.querySelector('#custom-schedule-min-label');
        let previousScheduleValue = scheduleSelect.value;

        scheduleSelect.addEventListener('change', async (e) => {
            const selectedValue = e.target.value;

            if (selectedValue === 'clear-custom') {
                e.target.value = previousScheduleValue;
                const confirmed = await showConfirmationModal({
                    title: "Clear Custom Schedules?",
                    description: "This will permanently remove all of your saved custom schedules. This action cannot be undone.",
                    confirmText: "Clear All",
                    cancelText: "Cancel",
                });
                if (confirmed === 'confirm') {
                    saveCustomSchedules([]);
                    showNotification("All custom schedules have been cleared.");
                    closeModal();
                    resolve(await showDedicatedScheduleModal(cardId, cardName));
                }
            } else {
                const isCustom = selectedValue === 'custom';
                customScheduleContainer.classList.toggle('visible', isCustom);
                minLabel.style.display = isCustom ? 'block' : 'none';
                if (!isCustom) {
                    previousScheduleValue = selectedValue;
                }
            }
        });

        modalContainer.querySelector('#set-custom-schedule-btn').addEventListener('click', () => {
            const days = parseInt(modalContainer.querySelector('#days').value) || 0;
            const hours = parseInt(modalContainer.querySelector('#hours').value) || 0;
            const minutes = parseInt(modalContainer.querySelector('#minutes').value) || 0;
            
            const totalMs = (days * 86400000) + (hours * 3600000) + (minutes * 60000);
            const minMs = SCHEDULER_INTERVAL_MINUTES * 60 * 1000;

            if (totalMs < minMs) {
                showNotification(`Schedule must be at least ${SCHEDULER_INTERVAL_MINUTES} minutes.`, true);
                return;
            }

            let text = 'Every ';
            if (days > 0) text += `${days}d `;
            if (hours > 0) text += `${hours}h `;
            if (minutes > 0) text += `${minutes}m`;
            text = text.trim();

            const customSchedules = getCustomSchedules();
            if (!customSchedules.some(s => s.value === totalMs)) {
                customSchedules.push({ value: totalMs, text });
                saveCustomSchedules(customSchedules);
            }

            const customOption = document.createElement('option');
            customOption.value = totalMs;
            customOption.textContent = text;
            scheduleSelect.insertBefore(customOption, scheduleSelect.querySelector('option[value="custom"]'));
            scheduleSelect.value = totalMs;
            previousScheduleValue = totalMs;
            customScheduleContainer.classList.remove('visible');
            minLabel.style.display = 'none';
        });

        document.getElementById("save-schedule").addEventListener("click", () => {
            if (scheduleSelect.value === 'custom') {
                showNotification("Please 'Set' your custom schedule or choose another option before saving.", true);
                return;
            }

            const newSchedule = scheduleSelect.value;
            const newScheduleValue = isNaN(parseInt(newSchedule)) ? newSchedule : parseInt(newSchedule);

            const jobs = getDedicatedJobs();
            let job = jobs.find(j => j.dedicatedType === cardId);

            if (job) {
                job.schedule = newScheduleValue;
                updateDedicatedJob(job);
            } else {
                const newJob = {
                    id: crypto.randomUUID(),
                    dedicatedType: cardId,
                    targetPlaylistName: cardName,
                    schedule: newScheduleValue,
                    createdAt: Date.now(),
                    lastRun: null,
                };
                addDedicatedJob(newJob);
            }
            
            showNotification("Auto-update schedule saved!");
            
            const fullScheduleText = scheduleSelect.options[scheduleSelect.selectedIndex].text;
            const shortScheduleText = scheduleToShortTextMap[newScheduleValue];
            const finalScheduleText = shortScheduleText || fullScheduleText;

            closeModal();
            resolve(`Update ${finalScheduleText}`);
        });

        document.getElementById("cancel-schedule").addEventListener("click", () => {
            closeModal();
            resolve(null);
        });

        overlay.addEventListener("click", (e) => { 
            if (e.target === overlay) {
                closeModal();
                resolve(null);
            }
        });
    });
  }

  async function showConfirmationModal({ title, description, confirmText, cancelText, neutralText }) {
    return new Promise((resolve) => {
      const overlay = document.createElement("div");
      overlay.id = "sort-play-confirmation-overlay";
      overlay.style.cssText = `
          position: fixed; top: 0; left: 0; width: 100%; height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          z-index: 2002;
          display: flex; justify-content: center; align-items: center;
      `;

      const modalContainer = document.createElement("div");
      modalContainer.className = "main-embedWidgetGenerator-container sort-play-font-scope";
      modalContainer.style.cssText = `
          z-index: 2003;
          width: 420px !important;
          background-color: #181818 !important;
          border: 1px solid #282828;
          display: flex;
          flex-direction: column;
          border-radius: 30px;
      `;
      
      const neutralButtonHtml = neutralText
        ? `<button id="neutralAction" class="sp-confirm-btn sp-confirm-btn-secondary">${neutralText}</button>`
        : '';

      modalContainer.innerHTML = `
        <style>
            .sp-confirm-btn {
                width: auto;
                padding: 8px 18px;
                border-radius: 20px;
                border: none;
                cursor: pointer;
                font-weight: 550;
                font-size: 13px;
                text-transform: uppercase;
                transition: background-color 0.2s ease;
            }
            .sp-confirm-btn-primary {
                background-color: #1ED760;
                color: black;
            }
            .sp-confirm-btn-primary:hover {
                background-color: #3BE377;
            }
            .sp-confirm-btn-secondary {
                background-color: #333333;
                color: white;
                 padding: 8px 16px;
            }
            .sp-confirm-btn-secondary:hover {
                background-color: #444444;
            }
        </style>
        <div class="main-trackCreditsModal-header" style="padding: 27px 32px 12px !important;">
            <h1 class="main-trackCreditsModal-title"><span style='font-size: 25px;'>${title}</span></h1>
        </div>
        <div class="main-trackCreditsModal-mainSection" style="padding: 16px 32px 9px 32px;">
            <p style="color: #c1c1c1; font-size: 16px; margin-bottom: 25px; line-height: 1.5;">${description}</p>
        </div>
        <div class="main-trackCreditsModal-originalCredits" style="padding: 15px 24px !important; border-top: 1px solid #282828; flex-shrink: 0;">
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button id="cancelConfirm" class="sp-confirm-btn sp-confirm-btn-secondary">${cancelText}</button>
                ${neutralButtonHtml}
                <button id="confirmAction" class="sp-confirm-btn sp-confirm-btn-primary">${confirmText}</button>
            </div>
        </div>
      `;

      document.body.appendChild(overlay);
      overlay.appendChild(modalContainer);

      const closeModal = (result) => {
          overlay.remove();
          resolve(result);
      };

      modalContainer.querySelector("#confirmAction").addEventListener("click", () => closeModal('confirm'));
      modalContainer.querySelector("#cancelConfirm").addEventListener("click", () => closeModal('cancel'));
      if (neutralText) {
        modalContainer.querySelector("#neutralAction").addEventListener("click", () => closeModal('neutral'));
      }
      overlay.addEventListener("click", (e) => {
          if (e.target === overlay) {
              e.preventDefault();
              e.stopPropagation();
          }
      });
    });
  }
  
  function showDetailedError(error, context) {
    let location = "unknown location";
    if (error.stack) {
        const stackLines = error.stack.split('\n');
        if (stackLines.length > 1) {
            location = stackLines[1].trim();
        }
    }
    const errorMessage = `${context}: ${error.message}\n${location}`;
    showNotification(errorMessage, true, 8000);
    console.error(`[Sort-Play] ${context}:`, error);
  }

  function formatPlayCount(count, format) {
    if (count === null || count === undefined || isNaN(count) || count === "N/A" || count === "_" || count === "â€•" || Number(count) === 0) {
        return 'N/A';
    }

    const num = Number(count);

    if (format === 'abbreviated') {
        if (num >= 1_000_000_000) {
            return (num / 1_000_000_000).toFixed(1).replace(/\.0$/, '') + 'B';
        }
        if (num >= 1_000_000) {
            return (num / 1_000_000).toFixed(1).replace(/\.0$/, '') + 'M';
        }
        if (num >= 1_000) {
            return (num / 1_000).toFixed(1).replace(/\.0$/, '') + 'K';
        }
        return num.toString();
    } else if (format === 'rounded_abbreviated') {
        if (num >= 1_000_000_000) {
            return Math.round(num / 1_000_000_000) + 'B';
        }
        if (num >= 1_000_000) {
            return Math.round(num / 1_000_000) + 'M';
        }
        if (num >= 1_000) {
            return Math.round(num / 1_000) + 'K';
        }
        return num.toString();
    }

    return new Intl.NumberFormat('en-US').format(num);
  }

  function formatTempo(value, format) {
    if (value === null || isNaN(value)) return 'â€•';
    const rounded = Math.round(value);
    if (format === 'raw') {
        return rounded.toString();
    }
    return `${rounded} BPM`;
  }

  function formatAudioFeature(value, format, unitName = '') {
    if (value === null || isNaN(value)) return 'â€•';
    
    const roundedValue = Math.round(value);

    if (format === 'raw') {
        return roundedValue.toString();
    } else if (format === 'decimal') {
        return (value / 100).toFixed(2);
    } else if (format === 'tier') {
        if (value <= 20) return 'Very Low';
        if (value <= 40) return 'Low';
        if (value <= 60) return 'Medium';
        if (value <= 80) return 'High';
        return 'Very High';
    } else if (format === 'with_unit') {
        return `${roundedValue} ${unitName}`;
    }
    return `${roundedValue}%`;
  }

  function formatKey(key, mode, format) {
    if (key === null || key === -1 || isNaN(key) || mode === null || isNaN(mode)) return 'â€•';

    const pitchClasses = ["C", "Câ™¯/Dâ™­", "D", "Dâ™¯/Eâ™­", "E", "F", "Fâ™¯/Gâ™­", "G", "Gâ™¯/Aâ™­", "A", "Aâ™¯/Bâ™­", "B"];
    
    const camelotMap = [
        { major: '8B', minor: '5A' }, { major: '3B', minor: '12A' }, { major: '10B', minor: '7A' },
        { major: '5B', minor: '2A' }, { major: '12B', minor: '9A' }, { major: '7B', minor: '4A' },
        { major: '2B', minor: '11A' }, { major: '9B', minor: '6A' }, { major: '4B', minor: '1A' },
        { major: '11B', minor: '8A' }, { major: '6B', minor: '3A' }, { major: '1B', minor: '10A' }
    ];

    const openKeyMap = [
        { major: '1d', minor: '10m' }, { major: '8d', minor: '5m' }, { major: '3d', minor: '12m' },
        { major: '10d', minor: '7m' }, { major: '5d', minor: '2m' }, { major: '12d', minor: '9m' },
        { major: '7d', minor: '4m' }, { major: '2d', minor: '11m' }, { major: '9d', minor: '6m' },
        { major: '4d', minor: '1m' }, { major: '11d', minor: '8m' }, { major: '6d', minor: '3m' }
    ];

    switch (format) {
        case 'camelot':
            return mode === 1 ? camelotMap[key].major : camelotMap[key].minor;
        case 'openkey':
            return mode === 1 ? openKeyMap[key].major : openKeyMap[key].minor;
        case 'full_name':
            return `${pitchClasses[key]} ${mode === 1 ? 'Major' : 'Minor'}`;
        case 'standard':
        default:
            return pitchClasses[key];
    }
  }

  function formatPopularity(value, format) {
    if (value === null || isNaN(value)) return 'â€•';
    const num = Math.round(value);

    switch (format) {
        case 'with_label':
            return `Pop: ${num}`;
        case 'percentage':
            return `${num}%`;
        case 'tier':
            if (num >= 90) return 'Global Hit';
            if (num >= 75) return 'Major Hit';
            if (num >= 55) return 'Popular';
            if (num >= 30) return 'Niche';
            return 'Underground';
        case 'raw':
        default:
            return num.toString();
    }
  }
  
  function showGenreDetailsModal(genreMap, trackName, artistName) {
      const existing = document.getElementById("sort-play-genre-details-overlay");
      if (existing) existing.remove();

      const overlay = document.createElement("div");
      overlay.id = "sort-play-genre-details-overlay";
      overlay.style.cssText = `
          position: fixed; top: 0; left: 0; width: 100%; height: 100%;
          background-color: transparent; z-index: 2002;
          display: flex; justify-content: center; align-items: center;
          pointer-events: none;
      `;

      const modalContainer = document.createElement("div");
      modalContainer.className = "main-embedWidgetGenerator-container sort-play-font-scope";
      modalContainer.style.cssText = `
          z-index: 2003;
          width: 550px !important;
          max-height: 80vh;
          display: flex;
          flex-direction: column;
          background-color: #181818;
          border: 1px solid #333;
          border-radius: 8px;
          box-shadow: 0 8px 24px rgba(0,0,0,0.8);
          overflow: hidden;
          pointer-events: auto;
      `;

      const categoryMap = new Map();
      const order = ['Spotify (Artist)', 'Last.fm (Track)', 'Last.fm (Artist)', 'Deezer (Album)', 'Other'];
      
      order.forEach(c => categoryMap.set(c, []));

      genreMap.forEach(item => {
          item.sources.forEach(source => {
              let category = 'Other';
              if (source.startsWith("Spotify")) category = 'Spotify (Artist)';
              else if (source.startsWith("Last.fm Track")) category = 'Last.fm (Track)';
              else if (source.startsWith("Last.fm Artist")) category = 'Last.fm (Artist)';
              else if (source.startsWith("Deezer")) category = 'Deezer (Album)';

              if (!categoryMap.has(category)) categoryMap.set(category, []);
              
              const list = categoryMap.get(category);
              let entry = list.find(e => e.name === item.name);
              if (!entry) {
                  entry = { name: item.name, sources: [] };
                  list.push(entry);
              }
              entry.sources.push(source);
          });
      });

      let contentHtml = '';
      let hasGenres = false;

      const smallCopyIcon = copyIconSVG.replace('width="16px"', 'width="12px"').replace('height="16px"', 'height="12px"');

      categoryMap.forEach((genres, category) => {
          if (genres.length > 0) {
              hasGenres = true;
              genres.sort((a, b) => a.name.localeCompare(b.name));

              contentHtml += `
                  <div style="margin-bottom: 24px;">
                      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 6px;">
                          <div style="color: #fff; font-size: 13px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;">
                              ${category}
                          </div>
                      </div>
                      <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                          ${genres.map(g => {
                              const titleCase = g.name.replace(/\b\w/g, l => l.toUpperCase());
                              const uniqueSources = [...new Set(g.sources)];
                              const tooltip = uniqueSources.join(' & ');
                              return `
                                <div class="genre-detail-tag" data-genre="${g.name}" title="Source: ${tooltip}" style="background: #2a2a2a; color: #eee; padding: 4px 6px 4px 12px; border-radius: 4px; font-size: 13px; cursor: pointer; transition: all 0.2s ease; border: 1px solid transparent; user-select: none; display: flex; align-items: center; gap: 8px;">
                                    <span class="genre-text">${titleCase}</span>
                                    <button class="genre-copy-btn" title="Copy" style="background: transparent; border: none; color: #b3b3b3; cursor: pointer; padding: 2px; display: flex; align-items: center; justify-content: center; border-radius: 3px; transition: all 0.2s;">
                                        ${smallCopyIcon}
                                    </button>
                                </div>`;
                          }).join('')}
                      </div>
                  </div>
              `;
          }
      });

      if (!hasGenres) {
          contentHtml = '<div style="color: #b3b3b3; text-align: center; padding: 40px 20px;">No genres found for this track.</div>';
      }

      modalContainer.innerHTML = `
          <div class="main-trackCreditsModal-header" style="padding: 18px 24px; border-bottom: 1px solid #282828; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; background-color: #181818;">
              <div style="display: flex; flex-direction: column; gap: 2px; overflow: hidden; padding-right: 16px;">
                  <h1 style="font-size: 18px; font-weight: 700; margin: 0; color: white; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">All Genres</h1>
                  <span style="font-size: 13px; color: #b3b3b3; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${trackName} â€¢ ${artistName}">${trackName} â€¢ ${artistName}</span>
              </div>
              <button class="close-details-btn" style="background: none; border: none; color: #b3b3b3; cursor: pointer; display: flex; padding: 4px; transition: color 0.2s; flex-shrink: 0;">
                  <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor"><path d="M1.47 1.47a.75.75 0 0 1 1.06 0L8 6.94l5.47-5.47a.75.75 0 1 1 1.06 1.06L9.06 8l5.47 5.47a.75.75 0 1 1-1.06 1.06L8 9.06l-5.47 5.47a.75.75 0 0 1-1.06-1.06L6.94 8 1.47 2.53a.75.75 0 0 1 0-1.06z"/></svg>
              </button>
          </div>
          <div class="main-trackCreditsModal-mainSection" style="padding: 24px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #555 transparent; background-color: #181818;">
              ${contentHtml}
          </div>
      `;

      document.body.appendChild(overlay);
      overlay.appendChild(modalContainer);

      const closeModal = () => overlay.remove();
      
      const closeBtn = modalContainer.querySelector('.close-details-btn');
      closeBtn.addEventListener('click', closeModal);
      closeBtn.addEventListener('mouseenter', () => closeBtn.style.color = '#fff');
      closeBtn.addEventListener('mouseleave', () => closeBtn.style.color = '#b3b3b3');

      overlay.addEventListener('mousedown', (e) => {
          if (e.target === overlay) closeModal();
      });

      modalContainer.querySelectorAll('.genre-detail-tag').forEach(tag => {
          tag.addEventListener('mouseenter', () => {
              tag.style.background = '#3e3e3e';
              tag.style.borderColor = '#555';
          });
          tag.addEventListener('mouseleave', () => {
              tag.style.background = '#2a2a2a';
              tag.style.borderColor = 'transparent';
          });
          
          tag.addEventListener('click', (e) => {
              if (e.target.closest('.genre-copy-btn')) return;

              const genreName = tag.dataset.genre;
              let path;
              if (useGenrePlaylistDatabase && genrePlaylistsCache) {
                  const normalized = normalizeGenre(genreName);
                  const matched = genrePlaylistsCache.find(p => normalizeGenre(p.genre) === normalized);
                  if (matched) {
                      try {
                          const uriObj = Spicetify.URI.fromString(matched.uri);
                          path = uriObj.toURLPath(true);
                      } catch(err) {
                          const id = matched.uri.split(":").pop();
                          path = `/playlist/${id}`;
                      }
                  }
              }
              if (!path) {
                  path = `/search/${encodeURIComponent(genreName)}/playlists`;
              }
              Spicetify.Platform.History.push(path);
              closeModal();
          });
      });

      modalContainer.querySelectorAll('.genre-copy-btn').forEach(btn => {
          btn.addEventListener('mouseenter', () => {
              btn.style.backgroundColor = 'rgba(255,255,255,0.2)';
              btn.style.color = '#fff';
          });
          btn.addEventListener('mouseleave', () => {
              btn.style.backgroundColor = 'transparent';
              btn.style.color = '#b3b3b3';
          });

          btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const tag = btn.closest('.genre-detail-tag');
              const genreName = tag.dataset.genre;
              
              navigator.clipboard.writeText(genreName).then(() => {
                  const originalHtml = btn.innerHTML;
                  btn.style.color = '#1ED760';
                  setTimeout(() => {
                      btn.style.color = '#b3b3b3';
                  }, 1000);
              });
          });
      });
  }

  async function getGenreMapping() {
      const cached = await idb.get('staticData', 'genre_playlist_map');
      if (cached) {
          genrePlaylistsCache = cached;
          return cached;
      }

      try {
          const response = await fetch(GENRE_PLAYLISTS_URL);
          if (!response.ok) throw new Error("Failed to fetch genre map");
          const data = await response.json();
          
          await idb.set('staticData', 'genre_playlist_map', data);
          genrePlaylistsCache = data;
          return data;
      } catch (e) {
          console.error("[Sort-Play] Failed to load genre playlist map:", e);
          return [];
      }
  }

  function normalizeGenre(genre) {
      return genre
          .toLowerCase()
          .trim()
          .replace(/-/g, ' ')
          .replace(/&/g, 'and')
          .replace(/\s+/g, ' ');
  }

  function isCountryOnly(tag) {
      if (!tag) return false;
      const lowerTag = tag.toLowerCase().trim();
      const mainCountries = Object.keys(COUNTRY_MAPPINGS);
      if (mainCountries.includes(lowerTag)) return true;
      for (const variants of Object.values(COUNTRY_MAPPINGS)) {
          if (variants.includes(lowerTag)) return true;
      }
      return false;
  }

  function isWhitelistedGenre(tag, genreMap) {
      if (!tag) return false;
      const normalizedTag = normalizeGenre(tag);
      
      const isMapped = Object.keys(GENRE_MAPPINGS).some(g => normalizeGenre(g) === normalizedTag) || 
                      Object.values(GENRE_MAPPINGS).some(variants => 
                          variants.some(v => normalizeGenre(v) === normalizedTag)
                      );
      
      const isInJson = genreMap ? genreMap.some(p => normalizeGenre(p.genre) === normalizedTag) : false;
      
      return isMapped || isInJson;
  }

  async function fetchDisplayGenres(track) {
      if (!track || !track.uri) return new Map();
      
      if (nowPlayingGenreCache.has(track.uri)) {
          return nowPlayingGenreCache.get(track.uri);
      }
      
      if (pendingGenreFetches.has(track.uri)) {
          return await pendingGenreFetches.get(track.uri);
      }
      
      const fetchPromise = (async () => {
          try {
              const trackId = track.uri.split(":")[2];
              const genreSourcesMap = new Map();
              const genreMap = await getGenreMapping();

              const addGenres = (list, sourceLabel) => {
                  if (!list || !Array.isArray(list) || list.length === 0) return;
                  list.forEach(g => {
                      const lower = g.toLowerCase();
                      if (!genreSourcesMap.has(lower)) {
                          genreSourcesMap.set(lower, { name: g, sources: new Set() });
                      }
                      genreSourcesMap.get(lower).sources.add(sourceLabel);
                  });
              };

              const promises = [];

              const artistsToFetch = track.artists ? track.artists.filter(a => a.id || (a.uri && a.uri.split(':')[2])) : [];
              
              if (genreSourcesNpSpotify && artistsToFetch.length > 0) {
                  const idsToFetch = [];
                  
                  artistsToFetch.forEach(artist => {
                      const id = artist.id || artist.uri.split(':')[2];
                      if (artistGenreCache.has(id)) {
                          addGenres(artistGenreCache.get(id), `Spotify Artist (${artist.name})`);
                      } else {
                          idsToFetch.push({ id, name: artist.name });
                      }
                  });

                  if (idsToFetch.length > 0) {
                      promises.push((async () => {
                          const fetchArtistGenres = async (artistId) => {
                              try {
                                  const fetchWithClientToken = async () => {
                                      const token = await get_S_Client_Token();
                                      if (!token) throw new Error("No client token");
                                      const res = await fetch(`https://api.spotify.com/v1/artists/${artistId}`, {
                                          headers: { "Authorization": `Bearer ${token}` }
                                      });
                                      if (!res.ok) throw new Error(`HTTP ${res.status}`);
                                      const data = await res.json();
                                      return data.genres || [];
                                  };

                                  if (isFallbackActive()) {
                                      return await fetchWithClientToken();
                                  } else {
                                      try {
                                          const res = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists/${artistId}`);
                                          return res?.genres || [];
                                      } catch (e) {
                                          if (registerWebApiFailure()) {
                                              return await fetchWithClientToken();
                                          }
                                          throw e;
                                      }
                                  }
                              } catch (e) { return []; }
                          };

                          await Promise.all(idsToFetch.map(async (artist) => {
                              const genres = await fetchArtistGenres(artist.id);
                              if (genres && genres.length > 0) {
                                  artistGenreCache.set(artist.id, genres);
                                  addGenres(genres, `Spotify Artist (${artist.name})`);
                              } else {
                                  artistGenreCache.set(artist.id, []);
                              }
                          }));
                      })());
                  }
              }

              const artistName = track.artists?.[0]?.name || "";
              const trackName = track.name || "";

              if (genreSourcesNpLastfm && artistName && trackName) {
                  if (lastfmArtistTagsCache.has(artistName)) {
                      const validTags = lastfmArtistTagsCache.get(artistName);
                      if (validTags.length > 0) addGenres(validTags, 'Last.fm Artist');
                  } else {
                      promises.push((async () => {
                          try {
                              const params = new URLSearchParams({ method: 'artist.getInfo', artist: artistName, format: 'json' });
                              const res = await fetchLfmWithGateway(params);
                              if (res.ok) {
                                  const data = await res.json();
                                  if (data?.artist?.tags?.tag) {
                                      const tags = data.artist.tags.tag
                                          .map(t => t.name.toLowerCase())
                                          .filter(g => !/^\d+$/.test(g));
                                      
                                      const validTags = tags.filter(tag => !isCountryOnly(tag) && isWhitelistedGenre(tag, genreMap));
                                      lastfmArtistTagsCache.set(artistName, validTags);
                                      
                                      if (validTags.length > 0) {
                                          addGenres(validTags, 'Last.fm Artist');
                                      }
                                  } else {
                                      lastfmArtistTagsCache.set(artistName, []);
                                  }
                              }
                          } catch (e) { console.warn("LFM Artist fetch failed", e); }
                      })());
                  }

                  const trackCacheKey = `${artistName}|${trackName}`;
                  if (lastfmTrackTagsCache.has(trackCacheKey)) {
                      const validTags = lastfmTrackTagsCache.get(trackCacheKey);
                      if (validTags.length > 0) addGenres(validTags, 'Last.fm Track');
                  } else {
                      promises.push((async () => {
                          try {
                              const params = new URLSearchParams({ method: 'track.getInfo', artist: artistName, track: trackName, format: 'json' });
                              const res = await fetchLfmWithGateway(params);
                              if (res.ok) {
                                  const data = await res.json();
                                  if (data?.track?.toptags?.tag) {
                                      const tags = data.track.toptags.tag
                                          .map(t => t.name.toLowerCase())
                                          .filter(g => !/^\d+$/.test(g));
                                      
                                      const validTags = tags.filter(tag => !isCountryOnly(tag) && isWhitelistedGenre(tag, genreMap));
                                      lastfmTrackTagsCache.set(trackCacheKey, validTags);
                                      
                                      if (validTags.length > 0) {
                                          addGenres(validTags, 'Last.fm Track');
                                      }
                                  } else {
                                      lastfmTrackTagsCache.set(trackCacheKey, []);
                                  }
                              } else {
                                  lastfmTrackTagsCache.set(trackCacheKey, []);
                              }
                          } catch (e) {
                              lastfmTrackTagsCache.set(trackCacheKey, []);
                          }
                      })());
                  }
              }

              if (genreSourcesNpDeezer) {
                  promises.push((async () => {
                      let isrc = null;
                      if (track.metadata && track.metadata.isrc) {
                          isrc = track.metadata.isrc;
                      } else if (track.external_ids && track.external_ids.isrc) {
                          isrc = track.external_ids.isrc;
                      } else {
                          try {
                              if (isFallbackActive()) {
                                  const meta = await fetchInternalTrackMetadata(trackId);
                                  isrc = meta?.external_ids?.isrc;
                              } else {
                                  const data = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks/${trackId}`);
                                  isrc = data?.external_ids?.isrc;
                              }
                          } catch(e) {}
                      }

                      if (isrc) {
                          try {
                              const deezerGenres = await getDeezerGenres(isrc);
                              if (deezerGenres && deezerGenres.length > 0) {
                                  addGenres(deezerGenres, 'Deezer Album');
                              }
                          } catch (e) {}
                      }
                  })());
              }

              await Promise.all(promises);

              nowPlayingGenreCache.set(track.uri, genreSourcesMap);
              return genreSourcesMap;
          } finally {
              pendingGenreFetches.delete(track.uri);
          }
      })();
      
      pendingGenreFetches.set(track.uri, fetchPromise);
      return await fetchPromise;
  }

  
  async function prefetchNextTrackData() {
      if (!Spicetify.Platform?.PlayerAPI?.getQueue) return;

      try {
          await new Promise(resolve => setTimeout(resolve, 500));

          const queueData = await Spicetify.Platform.PlayerAPI.getQueue();
          const allUpcoming = [...(queueData.queued || []), ...(queueData.nextUp || [])];
          
          if (allUpcoming.length === 0) return;
          const nextTrack = allUpcoming[0];
          
          if (!nextTrack || !nextTrack.uri || Spicetify.URI.isLocal(nextTrack.uri)) return;

          const trackId = nextTrack.uri.split(":")[2];
          let albumId = nextTrack.album?.uri?.split(":")[2];
          
          if (!albumId && nextTrack.metadata?.album_uri) {
              albumId = nextTrack.metadata.album_uri.split(":")[2];
          }

          const mockTrackObj = {
              uri: nextTrack.uri,
              name: nextTrack.name,
              artists: nextTrack.artists || [],
              albumUri: albumId ? `spotify:album:${albumId}` : null,
              albumId: albumId,
              track: {
                  id: trackId,
                  album: { id: albumId }
              }
          };

          if (showGenreTags && showGenreTagsNowPlaying) {
              fetchDisplayGenres(mockTrackObj).catch(() => {});
          }

          if (showNowPlayingData) {
              if (selectedNowPlayingDataType === 'releaseDate') {
                  getTrackDetailsWithReleaseDate(mockTrackObj).catch(() => {});
              } else if (selectedNowPlayingDataType === 'playCount' && albumId) {
                  getTrackDetailsWithPlayCount(mockTrackObj).catch(() => {});
              } else if (selectedNowPlayingDataType === 'popularity') {
                  if (isFallbackActive()) {
                      fetchInternalTrackMetadata(trackId).catch(() => {});
                  } else {
                      Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks/${trackId}`).catch(() => {});
                  }
              } else {
                  const audioFeatureTypes = ['tempo', 'energy', 'danceability', 'valence', 'key'];
                  if (audioFeatureTypes.includes(selectedNowPlayingDataType)) {
                      getBatchTrackStats([trackId]).catch(() => {});
                  }
              }
          }
      } catch (e) {
      }
  }

  async function displayGenreTags() {
    if (!showGenreTags || !showGenreTagsNowPlaying) {
        document.querySelectorAll('.sort-play-genre-container').forEach(el => el.remove());
        return;
    }

    const MAX_RETRIES = 10;
    let retryDelay = 200;

    for (let i = 0; i < MAX_RETRIES; i++) {
        const track = Spicetify.Player.data?.item;
        
        if (!track || !track.uri) {
            await new Promise(resolve => setTimeout(resolve, retryDelay));
            retryDelay = Math.min(retryDelay * 1.5, 3000);
            continue;
        }

        if (Spicetify.URI.isLocalTrack(track.uri)) {
            document.querySelectorAll('.sort-play-genre-container').forEach(el => el.remove());
            return;
        }

        const currentUriAtStart = track.uri;

        const targetContainer = document.querySelector(".main-nowPlayingWidget-trackInfo");
        if (!targetContainer) {
            await new Promise(resolve => setTimeout(resolve, retryDelay));
            retryDelay = Math.min(retryDelay * 1.5, 3000);
            continue;
        }

        const computedStyle = window.getComputedStyle(targetContainer);
        const gridTemplate = computedStyle.getPropertyValue("grid-template");
        
        if (gridTemplate) {
            const parts = gridTemplate.split("/");
            if (parts.length >= 2) {
                let rows = parts[0].trim();
                const cols = parts.slice(1).join("/").trim(); 
                const genreRow = '"genres genres"';
                if (!rows.includes(genreRow)) {
                    rows = rows.replace(/;$/, '').trim(); 
                    const newTemplate = `${rows} ${genreRow} / ${cols}`;
                    targetContainer.style.setProperty("grid-template", newTemplate);
                }
            }
        }

        let genreContainer = targetContainer.querySelector('.sort-play-genre-container');
        if (!genreContainer) {
            genreContainer = document.createElement("div");
            genreContainer.className = "sort-play-genre-container ellipsis-one-line";
            genreContainer.style.fontSize = "12px";
            genreContainer.style.color = "var(--spice-subtext)";
            genreContainer.style.setProperty("grid-area", "genres");
            genreContainer.style.overflow = "hidden";
            genreContainer.style.textOverflow = "ellipsis";
            genreContainer.style.whiteSpace = "nowrap";
            targetContainer.appendChild(genreContainer);

            genreContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (genreContainer._genreMap && genreContainer._genreMap.size > 0) {
                    showGenreDetailsModal(genreContainer._genreMap, genreContainer._trackName, genreContainer._artistName);
                }
            });
        }
        
        if (genreContainer.dataset.uri !== currentUriAtStart) {
           genreContainer.innerHTML = "ã…¤";
           genreContainer.dataset.uri = currentUriAtStart;
        }

        const genreSourcesMap = await fetchDisplayGenres(track);
        genreContainer._genreMap = genreSourcesMap;
        genreContainer._trackName = track.metadata?.title || track.name || "Unknown Track";
        genreContainer._artistName = track.metadata?.artist_name || (track.artists && track.artists.map(a => a.name).join(", ")) || "Unknown Artist";
        
        const liveTrack = Spicetify.Player.data?.item;
        if (!liveTrack || liveTrack.uri !== currentUriAtStart) {
            return;
        }

        if (genreSourcesMap.size === 0) {
            genreContainer.innerHTML = "";
            return;
        }

        const genreMap = await getGenreMapping();
        
        const genreItems = Array.from(genreSourcesMap.values());

        const hasSpotify = (sources) => {
            for (const s of sources) if (s.startsWith('Spotify Artist')) return true;
            return false;
        };
        
        const hasLastFm = (sources) => {
            for (const s of sources) if (s.startsWith('Last.fm')) return true;
            return false;
        };

        genreItems.sort((a, b) => {
            const aSize = a.sources.size;
            const bSize = b.sources.size;
            
            if (aSize > 1 && bSize <= 1) return -1;
            if (bSize > 1 && aSize <= 1) return 1;
            
            if (aSize > 1 && bSize > 1) {
                return bSize - aSize;
            }

            const aSpotify = hasSpotify(a.sources);
            const bSpotify = hasSpotify(b.sources);
            
            if (aSpotify && !bSpotify) return -1;
            if (!aSpotify && bSpotify) return 1;

            const aLfm = hasLastFm(a.sources);
            const bLfm = hasLastFm(b.sources);
            
            if (aLfm && !bLfm) return -1;
            if (!aLfm && bLfm) return 1;

            return 0;
        });
        
        const genreLinks = genreItems.map(item => {
            const rawName = item.name;
            const sources = Array.from(item.sources).join(' & ');
            
            const titleCaseGenre = rawName.replace(/\b\w/g, l => l.toUpperCase());
            
            const matchedPlaylist = useGenrePlaylistDatabase ? genreMap.find(p => 
                normalizeGenre(p.genre) === normalizeGenre(rawName)
            ) : null;
            
            let href = "#";
            let style = "color: var(--spice-subtext); text-decoration: none; cursor: pointer;";
            let clickAction = "";

            if (matchedPlaylist) {
                try {
                    const uriObj = Spicetify.URI.fromString(matchedPlaylist.uri);
                    const path = uriObj.toURLPath(true);
                    href = path;
                    clickAction = `Spicetify.Platform.History.push('${path}')`;
                } catch (e) {
                    href = matchedPlaylist.uri;
                    const id = matchedPlaylist.uri.split(":").pop();
                    clickAction = `Spicetify.Platform.History.push('/playlist/${id}')`;
                }
            } else {
                href = `/search/${encodeURIComponent(rawName)}/playlists`;
                clickAction = `Spicetify.Platform.History.push('${href}')`;
            }

            return `<a href="${href}" 
                    title="Source: ${sources}"
                    style="${style}" 
                    onmouseover="this.style.color='var(--spice-text)'" 
                    onmouseout="this.style.color='var(--spice-subtext)'"
                    data-uri="${href}"
                    onclick="event.preventDefault(); event.stopPropagation(); ${clickAction}"
                    >${titleCaseGenre}</a>`;
        }).join("<span>, </span>");

        genreContainer.innerHTML = genreLinks;
        return;
    }
}

  async function updateArtistPageGenres() {
      if (!showGenreTags || !showGenreTagsArtistPage) {
          const existing = document.querySelector('.sort-play-artist-genres');
          if (existing) existing.remove();
          return;
      }

      const currentUri = getCurrentUri();
      const isArtist = currentUri && (
          (Spicetify.URI && Spicetify.URI.isArtist(currentUri)) || 
          currentUri.startsWith('spotify:artist:')
      );

      if (!isArtist) return;

      const artistId = currentUri.split(':')[2];
      
      const header = document.querySelector("div.main-entityHeader-headerText");
      if (!header) return;

      let container = header.querySelector('.sort-play-artist-genres');
      
      if (!container) {
          container = document.createElement("div");
          container.className = "main-entityHeader-detailsText sort-play-artist-genres";
          container.style.display = "block";
          
          container.dataset.artistId = artistId;
          container.dataset.status = 'loading';
          container.innerHTML = `<span>Artist Genres : </span><span style="opacity: 0.6;">Loading...</span>`;
          
          const details = header.querySelector("span.main-entityHeader-detailsText");
          if (details) {
              header.insertBefore(container, details);
          } else {
              header.appendChild(container);
          }
      }

      if (container.dataset.artistId !== artistId) {
          container.dataset.artistId = artistId;
          container.dataset.status = 'loading';
          container.innerHTML = `<span>Artist Genres : </span><span style="opacity: 0.6;">Loading...</span>`;
      }
      
      if (container.dataset.status === 'loaded') {
          return;
      }

      if (pendingArtistPageFetches.has(artistId)) {
          return;
      }

      pendingArtistPageFetches.set(artistId, true);

      try {
          let genreSourcesMap;
          const genreMap = await getGenreMapping();

          if (artistPageGenreCache.has(artistId)) {
              genreSourcesMap = artistPageGenreCache.get(artistId);
          } else {
              genreSourcesMap = new Map();
              
              let domArtistName = "";
              const artistNameElement = header.querySelector("h1");
              if (artistNameElement) domArtistName = artistNameElement.innerText.trim();

              const addGenres = (list, sourceLabel) => {
                  if (!list || !Array.isArray(list)) return;
                  list.forEach(g => {
                      const lower = g.toLowerCase();
                      if (!genreSourcesMap.has(lower)) {
                          genreSourcesMap.set(lower, { name: g, sources: new Set() });
                      }
                      genreSourcesMap.get(lower).sources.add(sourceLabel);
                  });
              };

              const promises = [];

              let spotifyFetchPromise;
              if (genreSourcesApSpotify) {
                  spotifyFetchPromise = (async () => {
                      const fetchWithClientToken = async () => {
                          const token = await get_S_Client_Token();
                          if (!token) throw new Error("No client token");
                          const res = await fetch(`https://api.spotify.com/v1/artists/${artistId}`, {
                              headers: { "Authorization": `Bearer ${token}` }
                          });
                          if (!res.ok) throw new Error(`HTTP ${res.status}`);
                          return await res.json();
                      };

                      try {
                          let data;
                          if (isFallbackActive()) {
                              data = await fetchWithClientToken();
                          } else {
                              try {
                                  data = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists/${artistId}`);
                              } catch (e) {
                                  if (registerWebApiFailure()) {
                                      data = await fetchWithClientToken();
                                  }
                              }
                          }
                          if (data) {
                              addGenres(data.genres, `Spotify Artist (${data.name})`);
                              return data.name;
                          }
                      } catch (e) {}
                      return null;
                  })();
                  promises.push(spotifyFetchPromise);
              } else {
                  spotifyFetchPromise = Promise.resolve(null);
              }

              if (genreSourcesApLastfm) {
                  promises.push((async () => {
                      let nameToUse = domArtistName;
                      
                      if (!nameToUse && genreSourcesApSpotify) {
                          nameToUse = await spotifyFetchPromise;
                      }

                      if (nameToUse) {
                          try {
                              const params = new URLSearchParams({ method: 'artist.getInfo', artist: nameToUse, format: 'json' });
                              const res = await fetchLfmWithGateway(params);
                              if (res.ok) {
                                  const data = await res.json();
                                  if (data?.artist?.tags?.tag) {
                                      const tags = data.artist.tags.tag.map(t => t.name.toLowerCase());
                                      const validTags = tags.filter(tag => !isCountryOnly(tag) && isWhitelistedGenre(tag, genreMap));
                                      if (validTags.length > 0) {
                                          addGenres(validTags, 'Last.fm Artist');
                                      }
                                  }
                              }
                          } catch(e) {
                              console.warn("[Sort-Play] Last.fm artist genre fetch failed:", e);
                          }
                      }
                  })());
              }

              await Promise.all(promises);
              
              artistPageGenreCache.set(artistId, genreSourcesMap);
          }

          const currentUriNow = getCurrentUri();
          if (!currentUriNow || !currentUriNow.includes(artistId)) {
              return;
          }
          
          container = header.querySelector('.sort-play-artist-genres');
          if (!container) return;

          if (genreSourcesMap.size === 0) {
              container.innerHTML = `<span>Artist Genres : </span><span style="opacity: 0.6;">No genres found</span>`;
              container.dataset.status = 'loaded';
              return;
          }

          const genreItems = Array.from(genreSourcesMap.values());

          const hasSpotify = (sources) => {
              for (const s of sources) {
                  if (s.startsWith('Spotify Artist')) return true;
              }
              return false;
          };

          genreItems.sort((a, b) => {
              const aSize = a.sources.size;
              const bSize = b.sources.size;
              
              if (aSize > 1 && bSize <= 1) return -1;
              if (bSize > 1 && aSize <= 1) return 1;
              if (aSize > 1 && bSize > 1) return bSize - aSize;

              const aHasSpotify = hasSpotify(a.sources);
              const bHasSpotify = hasSpotify(b.sources);
              
              if (aHasSpotify && !bHasSpotify) return -1;
              if (!aHasSpotify && bHasSpotify) return 1;

              return 0;
          });
          
          const genreLinks = genreItems.map(item => {
              const rawName = item.name;
              const sources = Array.from(item.sources).join(' & ');
              const titleCaseGenre = rawName.replace(/\b\w/g, l => l.toUpperCase());
              
              const matchedPlaylist = useGenrePlaylistDatabase ? genreMap.find(p => 
                  normalizeGenre(p.genre) === normalizeGenre(rawName)
              ) : null;
              
              let href = "#";
              let clickAction = "";
              
              if (matchedPlaylist) {
                  try {
                      const uriObj = Spicetify.URI.fromString(matchedPlaylist.uri);
                      const path = uriObj.toURLPath(true);
                      href = path;
                      clickAction = `Spicetify.Platform.History.push('${path}')`;
                  } catch (e) {
                      href = matchedPlaylist.uri;
                      const id = matchedPlaylist.uri.split(":").pop();
                      clickAction = `Spicetify.Platform.History.push('/playlist/${id}')`;
                  }
              } else {
                  href = `/search/${encodeURIComponent(rawName)}/playlists`;
                  clickAction = `Spicetify.Platform.History.push('${href}')`;
              }

              return `<a class="main-entityHeader-genreLink"
                      href="${href}"
                      title="Source: ${sources}"
                      style="color: var(--spice-subtext); font-size: 1rem; text-decoration: none; transition: color 0.2s;" 
                      onmouseover="this.style.color='var(--spice-text)'" 
                      onmouseout="this.style.color='var(--spice-subtext)'"
                      onclick="event.preventDefault(); event.stopPropagation(); ${clickAction}"
                      >${titleCaseGenre}</a>`;
          }).join("<span>, </span>");

          container.innerHTML = `<span>Artist Genres : </span>${genreLinks}`;
          
          container.dataset.status = 'loaded';

      } finally {
          pendingArtistPageFetches.delete(artistId);
      }
  }

  async function displayNowPlayingData() {
    const MAX_RETRIES = 10;
    let retryDelay = 250;

    const existingElement = document.getElementById('sort-play-now-playing-data');
    if (existingElement) {
        const parent = existingElement.parentElement;
        if (parent) {
            parent.style.display = '';
            parent.style.alignItems = '';
        }
        existingElement.remove();
    }

    if (!showNowPlayingData) {
        return;
    }

    await new Promise(resolve => setTimeout(resolve, 50));

    for (let i = 0; i < MAX_RETRIES; i++) {
        const track = Spicetify.Player.data?.item;
        if (!track?.uri) {
            return;
        }

        if (Spicetify.URI.isLocalTrack(track.uri)) {
            return;
        }

        const targetContainer = document.querySelector(selectedNowPlayingDataPosition);
        if (!targetContainer) {
            await new Promise(resolve => setTimeout(resolve, retryDelay));
            retryDelay = Math.min(retryDelay * 2, 3000);
            continue;
        }

        try {
            const trackId = track.uri.split(":")[2];
            let dataValue;

            if (selectedNowPlayingDataType === 'releaseDate') {
                const releaseDateData = await getTrackDetailsWithReleaseDate({
                    uri: track.uri,
                    albumUri: track.album.uri,
                    name: track.name
                });
                dataValue = releaseDateData ? formatReleaseDate(releaseDateData.releaseDate, selectedNowPlayingDateFormat) : 'â€•';
            } else if (selectedNowPlayingDataType === 'popularity') {
                let rawPopularity = null;
                if (isFallbackActive()) {
                    const meta = await fetchInternalTrackMetadata(trackId);
                    if (meta) rawPopularity = meta.popularity;
                } else {
                    try {
                        const trackDetails = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks/${trackId}`);
                        rawPopularity = trackDetails.popularity !== null ? trackDetails.popularity : null;
                    } catch (e) {
                        if (registerWebApiFailure()) {
                            const meta = await fetchInternalTrackMetadata(trackId);
                            if (meta) rawPopularity = meta.popularity;
                        }
                    }
                }
                dataValue = formatPopularity(rawPopularity, selectedNowPlayingPopularityFormat);
            } else if (selectedNowPlayingDataType === 'playCount') {
                const playCountData = await getTrackDetailsWithPlayCount({
                    track: {
                        id: trackId,
                        album: { id: track.album.uri.split(":")[2] }
                    },
                    name: track.name
                });
                const rawPlayCount = (playCountData && playCountData.playCount !== "N/A") ? playCountData.playCount : 'â€•';
                dataValue = formatPlayCount(rawPlayCount, selectedNowPlayingPlayCountFormat);
            } else {
                const audioFeatureTypes = ['tempo', 'energy', 'danceability', 'valence', 'key'];
                if (audioFeatureTypes.includes(selectedNowPlayingDataType)) {
                    const allStats = await getBatchTrackStats([trackId]);
                    const stats = allStats[trackId];
                    let value = stats ? stats[selectedNowPlayingDataType] : null;

                    if (value !== null && value !== "Undefined") {
                        switch (selectedNowPlayingDataType) {
                            case 'tempo':
                                dataValue = formatTempo(value, selectedNowPlayingTempoFormat);
                                break;
                            case 'energy':
                                dataValue = formatAudioFeature(value, selectedNowPlayingEnergyFormat, 'Energy');
                                break;
                            case 'danceability':
                                dataValue = formatAudioFeature(value, selectedNowPlayingDanceabilityFormat, 'Dance');
                                break;
                            case 'valence':
                                dataValue = formatAudioFeature(value, selectedNowPlayingValenceFormat, 'Valence');
                                break;
                            case 'key':
                                dataValue = formatKey(stats.key_raw, stats.mode, selectedNowPlayingKeyFormat);
                                break;
                            default:
                                dataValue = String(value);
                        }
                    } else {
                        dataValue = 'â€•';
                    }
                }
            }

            if (dataValue === '_' || dataValue === 'â€•') return;

            const duplicateCheck = document.getElementById('sort-play-now-playing-data');
            if (duplicateCheck) {
                duplicateCheck.remove();
            }

            let overlayElement = null;
            let checkAttempts = 0;
            const maxCheckAttempts = 20;
            
            while (checkAttempts < maxCheckAttempts) {
                overlayElement = targetContainer.querySelector('.main-trackInfo-overlay');
                
                if (overlayElement) {
                    const textElement = overlayElement.querySelector('[data-encore-id="text"]');
                    const linkElement = overlayElement.querySelector('a');
                    
                    if (textElement && linkElement && linkElement.textContent.trim() !== '') {
                        break;
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 50));
                checkAttempts++;
            }
            
            if (!overlayElement || checkAttempts >= maxCheckAttempts) {
                await new Promise(resolve => setTimeout(resolve, retryDelay));
                retryDelay = Math.min(retryDelay * 2, 3000);
                continue;
            }

            targetContainer.style.display = 'flex';
            targetContainer.style.alignItems = 'center';

            const dataElement = document.createElement("div");
            dataElement.id = 'sort-play-now-playing-data';
            dataElement.style.display = 'flex';
            dataElement.style.alignItems = 'center';
            dataElement.style.flexShrink = '0';
            dataElement.style.whiteSpace = 'nowrap';
            dataElement.dataset.renderedForUri = track.uri;
            dataElement.dataset.renderedValue = dataValue;

            dataElement.addEventListener('click', (event) => {
                event.stopPropagation();
                event.preventDefault();
                showNowPlayingSettingsModal(false);
            });

            const separatorElement = document.createElement("p");
            separatorElement.textContent = selectedNowPlayingSeparator;
            separatorElement.style.color = "var(--text-subdued)";
            separatorElement.style.margin = selectedNowPlayingSeparator === ' ' ? "0" : "0 4px";

            const valueElement = document.createElement("p");
            valueElement.className = 'sort-play-np-value';
            valueElement.textContent = dataValue;
            valueElement.style.color = "var(--text-subdued)";
            valueElement.style.margin = "0";
            valueElement.style.marginLeft = "5px";

            const nativeTextElement = targetContainer.querySelector('[data-encore-id="text"]');
            if (nativeTextElement) {
                const styles = window.getComputedStyle(nativeTextElement);
                const fontStyles = {
                    fontSize: styles.fontSize,
                    fontWeight: styles.fontWeight,
                    lineHeight: styles.lineHeight,
                    letterSpacing: styles.letterSpacing,
                    textTransform: styles.textTransform,
                };
                Object.assign(valueElement.style, fontStyles);
                Object.assign(separatorElement.style, fontStyles);
            }

            dataElement.appendChild(separatorElement);
            dataElement.appendChild(valueElement);

            if (overlayElement.nextSibling) {
                targetContainer.insertBefore(dataElement, overlayElement.nextSibling);
            } else {
                targetContainer.appendChild(dataElement);
            }
            
            return;

        } catch (error) {
            console.error('[Sort-Play] Error displaying Now Playing data:', error);
            return;
        }
    }

    console.error(`[Sort-Play] Failed to mount Now Playing data after ${MAX_RETRIES} retries.`);
  }

  function preventDragCloseModal() {
    let mouseDownInsideModal = false;
    let dragStarted = false;
    
    const modal = document.querySelector('.GenericModal');
    const modalOverlay = document.querySelector('.GenericModal__overlay');
    
    if (!modal || !modalOverlay) return;
    
    document.addEventListener('mousedown', (e) => {
      if (modal.contains(e.target)) {
        mouseDownInsideModal = true;
      } else {
        mouseDownInsideModal = false;
      }
    }, true);
    
    document.addEventListener('mousemove', (e) => {
      if (mouseDownInsideModal) {
        dragStarted = true;
      }
    }, true);
    
    modalOverlay.addEventListener('mouseup', (e) => {
      if (mouseDownInsideModal || dragStarted) {
        e.stopImmediatePropagation();
        e.preventDefault();
        setTimeout(() => { dragStarted = false; }, 10);
        return false;
      }
    }, true);
    
    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay && (mouseDownInsideModal || dragStarted)) {
        e.stopImmediatePropagation();
        e.preventDefault();
        return false;
      }
      if (e.target === modalOverlay && !mouseDownInsideModal && !dragStarted) {
        Spicetify.PopupModal.hide();
      }
    }, true);
    
    document.addEventListener('mouseup', (e) => {
      setTimeout(() => {
        mouseDownInsideModal = false;
        setTimeout(() => { dragStarted = false; }, 10);
      }, 0);
    }, true);
    
    const closeButton = document.querySelector('.main-trackCreditsModal-closeBtn');
    if (closeButton) {
      closeButton.addEventListener('click', (e) => {
        Spicetify.PopupModal.hide();
      });
    }
  }

  async function setQueueFromTracks(tracks, contextUri, source = 'default') {
    const { PlayerAPI } = Spicetify.Platform;

    if (!PlayerAPI || !PlayerAPI._queue || !PlayerAPI._queue._client || !PlayerAPI._state || !Spicetify.Player) {
        showNotification("Player API components missing for queue operation.", true);
        console.error("Player API components missing for queue operation.");
        return;
    }

    const currentTrackUri = PlayerAPI._state?.item?.uri;
    let tracksToPlay = [...tracks];

    if (source === 'shuffle') {
        if (currentTrackUri && tracksToPlay.length > 1 && tracksToPlay[0].uri === currentTrackUri) {
            const currentTrack = tracksToPlay.shift();
            tracksToPlay.push(currentTrack);
        }
    } else {
        if (currentTrackUri) {
            tracksToPlay = tracksToPlay.filter(t => t.uri !== currentTrackUri);
        }
    }

    if (!tracksToPlay || !tracksToPlay.length) {
        showNotification("No tracks to add to the queue.", false, 3000);
        return;
    }

    try {
        const expectedNextUri = tracksToPlay[0]?.uri;
        const trackUris = tracksToPlay.map(t => t.uri);
        trackUris.push("spotify:delimiter");

        const { _queue, _client } = PlayerAPI._queue;
        const { queueRevision } = _queue;

        const nextTracks = trackUris.map((uri) => ({
            contextTrack: { uri, uid: "", metadata: { is_queued: "false" } },
            removed: [], blocked: [], provider: "context",
        }));

        const setQueuePromise = _client.setQueue({ nextTracks, prevTracks: [], queueRevision });
        const updateContextPromise = (contextUri && PlayerAPI._state?.sessionId)
            ? PlayerAPI.updateContext(PlayerAPI._state.sessionId, { uri: contextUri, url: "context://" + contextUri })
            : Promise.resolve();

        await Promise.all([setQueuePromise, updateContextPromise]);

        const waitForQueueUpdate = async (expectedUri, timeout = 15000) => {
            const startTime = Date.now();
            while (Date.now() - startTime < timeout) {
                const currentFirstTrack = PlayerAPI._queue?._queue?.nextTracks?.[0];
                if (currentFirstTrack?.contextTrack?.uri === expectedUri) return true;
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return false;
        };

        const queueUpdated = await waitForQueueUpdate(expectedNextUri);
        if (!queueUpdated) {
            console.warn("[Sort-Play] Timed out waiting for queue to update. Playback may not start automatically.");
        }

        Spicetify.Player.next();

        const count = tracksToPlay.length;
        const trackWord = count === 1 ? 'track' : 'tracks';
        const message = source === 'shuffle' 
            ? `Shuffled ${count} ${trackWord} and added to queue.`
            : `Sorted tracks added to queue.`;
        showNotification(message);

    } catch (error) {
        console.error("Error setting queue with internal method:", error);
        showNotification("Failed to set the playback queue.", true);
        throw error;
    }
  }


  function isDirectSortType(sortType) {
      const directSortTypes = [
          "playCount",
          "popularity",
          "releaseDate",
          "scrobbles",
          "personalScrobbles",
          "lastScrobbled",
          "shuffle",
          "averageColor",
          "deduplicateOnly",
          "filterLiked",
          "keepLiked",
          "sortByLiked",
          "filterSingles",
          "filterAlbums",
          "energyWave",
          "tempo",
          "energy",
          "danceability",
          "valence",
          "acousticness",
          "instrumentalness"
      ];
      return directSortTypes.includes(sortType);
  }

  async function showAiPickModal(tracks, currentUri) {
    const modalContainer = document.createElement("div");
    modalContainer.className = "ai-pick-modal";
    modalContainer.innerHTML = `
      <style>
        .main-popupModal-container .main-embedWidgetGenerator-container,
        .ai-pick-modal .main-embedWidgetGenerator-container,
        div.main-embedWidgetGenerator-container {
          width: 620px !important;
          max-width: 620px !important;
          border-radius: 30px;
          overflow: hidden; 
          background-color: #181818 !important;
          border: 2px solid #282828;
        }
        .GenericModal > .main-embedWidgetGenerator-container {
          height: auto !important;
        }        
        .GenericModal__overlay .GenericModal {
          border-radius: 30px;
          overflow: hidden;
        }
        .main-trackCreditsModal-mainSection {
          overflow-y: hidden !important;
          padding: 16px 32px 9px 32px;
        }
        .main-trackCreditsModal-header {
          padding: 27px 32px 12px !important;
        }
        .main-trackCreditsModal-originalCredits{
          padding-bottom: 20px !important;
        }
        .ai-pick-modal .setting-row::after {
          content: "";
          display: table;
          clear: both;
        }
        .ai-pick-modal .setting-row {
          display: flex;
          padding: 5px 0;
          align-items: center;
        }
        .ai-pick-modal .setting-row .col.description {
          float: left;
          padding-right: 15px;
          width: auto;
          color: white;
        }
        .ai-pick-modal .setting-row .col.action {
          display: flex;
          align-items: center;
          justify-content: flex-end;
          text-align: right;
        }
        .ai-pick-modal .main-popupModal-content {
          overflow-y: auto;
        }
        .ai-pick-modal textarea {
          width: 100%;
          height: 150px;
          border-radius: 4px;
          border: 1px solid #282828;
          background: #282828;
          color: white;
        }
        .ai-pick-modal button {
          padding: 8px 18px;
          border-radius: 20px;
          border: none;
          cursor: pointer;
          background-color: #1ED760;
          color: black;
          font-weight: 600;
          font-size: 14px;
          transition: all 0.04s ease;
        }

        .ai-pick-modal .secondary-button {
          background-color: #282828;
          color: white;
          padding: 7px 35px;
          border: 1px solid #666;
          font-weight: 500;
          white-space: nowrap;
          min-width: 160px;
          text-align: center;
        }

        .ai-pick-modal .secondary-button:hover {
          border: 1px solid #939393;
        }

        .ai-pick-modal .secondary-button:disabled {
          color: #666;
          border-color: #666;
          cursor: not-allowed;
        }
        
        .ai-pick-modal .secondary-button:disabled:hover {
          border-color: #666;
        }
        .ai-pick-modal .switch {
          position: relative;
          display: inline-block;
          width: 40px;
          height: 24px;
        }
        .ai-pick-modal .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }
        .ai-pick-modal .sliderx {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #484848;
          border-radius: 24px;
          transition: .2s;
        }
        .ai-pick-modal .sliderx:before {
          position: absolute;
          content: "";
          height: 18px;
          width: 18px;
          left: 3px;
          bottom: 3px;
          background-color: white;
          border-radius: 50%;
          transition: .2s;
        }
        .ai-pick-modal input:checked + .sliderx {
          background-color: #1DB954;
        }
        .ai-pick-modal input:checked + .sliderx:before {
          transform: translateX(16px);
        }
        .ai-pick-modal select {
          padding: 8px;
          border-radius: 4px;
          border: 1px solid #666;
          background: #282828;
          color: white;
          width: 217px;
          cursor: pointer;
        }
        .ai-pick-modal select:hover {
          border: 1px solid #939393;
        }
        .ai-pick-modal select:focus {
          outline: none;
          border-color: #c7c7c7;
        }
        .ai-pick-modal .model-row {
          margin-bottom: 5px;
        }
        .ai-pick-modal .system-instruction {
          display: none;
        }
        .ai-pick-modal .system-instruction.visible {
          display: block;
        }
        .ai-pick-modal .system-instruction textarea {
          height: 150px; 
          font-size: 14px;  
          white-space: pre-wrap;
          word-wrap: break-word;
          overflow-wrap: break-word;
          max-width: 100%;
          padding: 15px;
          border-radius: 20px;
        }
        .ai-pick-modal .system-instruction textarea:focus {
          background: #323232;
        }
        .ai-pick-modal .button-row {
          display: flex;
          gap: 10px;
          margin-top: 16px;
        }
        .loader {
          border: 2px solid #f3f3f3;
          border-top: 2px solid #3498db;
          border-radius: 50%;
          width: 20px;
          height: 20px;
          animation: spin 1s linear infinite;
          margin: 0 auto;
        }
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        .ai-pick-modal .system-instruction textarea.fixed {
          background-color: #1a1a1a;
          color: #888;
          cursor: not-allowed;
          height: 87px; 
          font-size: 13px; 
        }
        
        .ai-pick-modal .system-instruction .instruction-label {
          color: white;
          display: block;
          margin-bottom: 12px;
          margin-top: 15px;
          font-weight: bold;
        }
        .ai-pick-modal .prompt-wrapper {
          display: flex;
          align-items: flex-start;
          border: 1px solid #282828;
          border-radius: 40px;
          padding: 5px;
          margin-bottom: 0px;
          background-color: #282828;
          align-items: center;
        }
        .ai-pick-modal .prompt-wrapper .textarea-container {
          flex-grow: 1;
          margin-right: 6px; 
          padding: 3px;
          display: flex;
          align-items: center; 
        }
        .ai-pick-modal .prompt-wrapper textarea {
          width: 100%;
          height: 20px;
          max-height: 136px;
          overflow-y: hidden;
          padding-left: 10px;   
          padding-top: 0px;   
          padding-bottom: 0px; 
          padding-right: 10px;
          line-height: 20px;
          border-radius: 20px;
          resize: none;
          font-size: 15px;
          background-color: #282828;
          color: white;
          display: flex;
          align-items: center;
          border: none;
          margin-bottom: 0px;
        }

        .ai-pick-modal .prompt-wrapper textarea:focus {
          outline: none;
          background-color: #323232;
        }
        
        .ai-pick-modal .prompt-wrapper:has(textarea:focus) {
          background-color: #323232;
        }

        .ai-pick-modal .prompt-wrapper .button-container {
          white-space: nowrap;  
          padding: 5px;
        }
        .ai-pick-modal .prompt-wrapper button {
        }
        .ai-pick-modal .prompt-wrapper textarea:focus {
          outline: none;
        }
        .ai-pick-modal .prompt-wrapper textarea::-webkit-scrollbar {
          width: 6px;
        }
        .ai-pick-modal .prompt-wrapper textarea::-webkit-scrollbar-track {
          background: #282828;
          border-radius: 20px;
        }
        .ai-pick-modal .prompt-wrapper textarea::-webkit-scrollbar-thumb {
          background-color: #1DB954;
          border-radius: 20px;
          border: 2px solid #282828;
        }

        .ai-pick-modal .settings-container {
          display: flex;
          gap: 15px; 
          flex-direction: row-reverse;
        }
      
        .ai-pick-modal .settings-right-wrapper,
        .ai-pick-modal .settings-left-wrapper {
          flex: 1;
          background-color: #282828;
          border-radius: 20px;
          padding: 25px;
          height: 170px;
        }
      
        .ai-pick-modal .settings-right-wrapper {
          display: flex;
          flex-direction: column;
          gap: 16px;
        }
      
        .ai-pick-modal .settings-left-wrapper {
          display: flex;
          flex-direction: column;
          gap: 0px;
        }
      
        .ai-pick-modal .settings-title {
          color: white;
          font-weight: bold;
          font-size: 14px;
          margin-bottom: 3px;
        }

        .ai-pick-modal .setting-row {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 5px 0;
          width: auto; 
        }
      
        .ai-pick-modal .setting-row .description {
          color: white;
          width: auto;
          flex-grow: 1; 
          font-size: 15px;
        }
      
        .ai-pick-modal .setting-row .action {
          flex-shrink: 0;
        }
        .modal-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0, 0, 0, 0.25);
          backdrop-filter: blur(5px);
          -webkit-backdrop-filter: blur(5px);
          z-index: 999;
        }

        .GenericModal {
          position: relative;
          z-index: 1000;
        }
        .tooltip-container {
          position: relative; 
          display: inline-block;
        }
        .custom-tooltip {
          visibility: hidden;
          position: absolute;
          z-index: 1;
          background-color: #373737;
          color: white;
          padding: 8px 12px;
          border-radius: 4px;
          font-size: 14px;
          max-width: 240px;
          width: max-content;
          bottom: 100%;   
          left: 50%;       
          transform: translateX(-50%);  
          margin-bottom: 5px;   
          box-shadow: 0 2px 4px rgba(0,0,0,0.2);
          line-height: 1.4;
          word-wrap: break-word;
      }
      .custom-tooltip::after {
          content: "";
          position: absolute;
          top: 100%;
          left: 50%;
          margin-left: -5px;
          border-width: 5px;
          border-style: solid;
          border-color: #373737 transparent transparent transparent;
      }
      
      .tooltip-container:hover .custom-tooltip {
          visibility: visible;
      }
      </style>

      <div style="display: flex; flex-direction: column; gap: 15px;">
        <div style="color: white; font-weight: 500; font-size: 16px;">
          Ask AI to pick tracks from this playlist
        </div>
        
        <div class="prompt-wrapper">
          <div class="textarea-container">
              <textarea id="aiPrompt" class="sort-play-ai-prompt" placeholder="Enter your request for the AI..."></textarea>
          </div>
          <div class="button-container">
            <button id="sendAiRequest">Send</button>
          </div>
        </div>
      
        <div class="settings-container">
          <div class="settings-right-wrapper">
            <div class="settings-title">Include in AI Analysis:</div>
            <div class="setting-row" id="includeSongStats">
            <label class="description">
            Song Statistics
            <span class="tooltip-container">
                ${infoIconSvg}
                <span class="custom-tooltip">Includes popularity, play count, release date, danceability, energy, valence, tempo, key, loudness, speechiness, acousticness, liveness, and instrumentalness.</span>
            </span>
        </label>
              <div class="action">
                <label class="switch">
                  <input type="checkbox" ${includeSongStats ? 'checked' : ''}>
                  <span class="sliderx"></span>
                </label>
              </div>
            </div>
            
            <div class="setting-row" id="includeLyrics">
              <label class="description">Song Lyrics</label>
              <div class="action">
                <label class="switch">
                  <input type="checkbox" ${includeLyrics ? 'checked' : ''}>
                  <span class="sliderx"></span>
                </label>
              </div>
            </div>
          </div>
      
          <div class="settings-left-wrapper">
            <div class="model-row">
              <label style="color: white; display: block; margin-bottom: 9px; font-weight: bold; font-size: 14px;">AI Model:</label>
              <select id="aiModel">
                <option value="gemini-2.5-pro" ${selectedAiModel === "gemini-2.5-pro" ? "selected" : ""}>Gemini 2.5 Pro</option>
                <option value="gemini-flash-latest" ${selectedAiModel === "gemini-flash-latest" ? "selected" : ""}>Gemini 2.5 Flash</option>
                <option value="gemini-flash-lite-latest" ${selectedAiModel === "gemini-flash-lite-latest" ? "selected" : ""}>Gemini 2.5 Flash-Lite</option>
              </select>
            </div>
            <div class="button-row">
              <button id="editSystemInstruction" class="secondary-button">Edit System Instruction</button>
            </div>
          </div>
        
        <div class="system-instruction" id="systemInstructionEditor">
          <label class="instruction-label">User System Instruction:</label>
          <textarea id="systemInstructionText">${userSystemInstruction}</textarea>
          
          <label class="instruction-label">Fixed System Instruction (Not Editable):</label>
          <textarea class="fixed" readonly>${FIXED_SYSTEM_INSTRUCTION}</textarea>
          
          <div class="button-row">
            <button id="saveSystemInstruction">Save</button>
            <button id="resetSystemInstruction" class="secondary-button">Reset to Default</button>
            <button id="cancelSystemInstruction" class="secondary-button">Cancel</button>
          </div>
        </div>
      </div>
    `;
  
    Spicetify.PopupModal.display({
      title: "<span style='font-size: 30px;'>AI Pick</span>",
      content: modalContainer,
      isLarge: true,
    });

    tagActiveModalWithFontScope();

    const overlay = document.createElement("div");
    overlay.className = "modal-overlay";
  
    const genericModalOverlay = document.querySelector(".GenericModal__overlay");
  
    if (genericModalOverlay) {
      genericModalOverlay.appendChild(overlay);
    }
  
    if (overlay) {
      overlay.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
      });
    }
  
    const modalContainerElement = document.querySelector(".main-popupModal-container");
    if (modalContainerElement) {
      modalContainerElement.style.zIndex = "2000";
    }

    preventDragCloseModal();


    const songStatsToggle = modalContainer.querySelector("#includeSongStats input");
    const lyricsToggle = modalContainer.querySelector("#includeLyrics input");
    const modelSelect = modalContainer.querySelector("#aiModel");
    
    const editButton = modalContainer.querySelector("#editSystemInstruction");
    const resetButton = modalContainer.querySelector("#resetSystemInstruction");
    const saveButton = modalContainer.querySelector("#saveSystemInstruction");
    const cancelButton = modalContainer.querySelector("#cancelSystemInstruction");
    const editorDiv = modalContainer.querySelector("#systemInstructionEditor");
    const textArea = modalContainer.querySelector("#systemInstructionText");
  
    const aiPromptTextarea = modalContainer.querySelector("#aiPrompt");
    aiPromptTextarea.addEventListener("input", function() {
      this.style.height = '20px';
      
      const scrollHeight = this.scrollHeight;
      
      if (scrollHeight > 20) {
        const newHeight = Math.min(scrollHeight, 136);
        this.style.height = newHeight + 'px';
      }
      
      this.style.overflowY = scrollHeight > 136 ? 'auto' : 'hidden';
    });
    
    aiPromptTextarea.dispatchEvent(new Event('input'));

    songStatsToggle.addEventListener("change", () => {
      includeSongStats = songStatsToggle.checked;
      saveSettings();
    });
  
    lyricsToggle.addEventListener("change", () => {
      includeLyrics = lyricsToggle.checked;
      saveSettings();
    });
  
    modelSelect.addEventListener("change", () => {
      selectedAiModel = modelSelect.value;
      saveSettings();
    });
  
    editButton.addEventListener("click", () => {
      editorDiv.classList.add("visible");
      editButton.disabled = true;
    });
  
    resetButton.addEventListener("click", () => {
      if (confirm("Are you sure you want to reset the system instruction to default?")) {
        userSystemInstruction = DEFAULT_USER_SYSTEM_INSTRUCTION_v2;
        textArea.value = DEFAULT_USER_SYSTEM_INSTRUCTION_v2;
        saveSettings();
        showNotification("System instruction reset to default");
      }
    });
  
    saveButton.addEventListener("click", () => {
      const newInstruction = textArea.value.trim();
      if (!newInstruction) {
        showNotification("System instruction cannot be empty", true);
        return;
      }
      userSystemInstruction = newInstruction;
      saveSettings();
      editorDiv.classList.remove("visible");
      editButton.disabled = false;
    });
    
    cancelButton.addEventListener("click", () => {
      textArea.value = userSystemInstruction;
      editorDiv.classList.remove("visible");
      editButton.disabled = false;
    });
  
    const sendButton = document.getElementById("sendAiRequest");
sendButton.addEventListener("click", async () => {
      const userPrompt = document.getElementById("aiPrompt").value;
      if (!userPrompt) {
        showNotification("Please enter a request.", true);
        return;
      }
  
      Spicetify.PopupModal.hide();
  
      setButtonProcessing(true);
      mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
      mainButton.style.color = buttonStyles.main.disabledColor;
      mainButton.style.cursor = "default";
      svgElement.style.fill = buttonStyles.main.disabledColor;
      menuButtons.forEach((button) => (button.disabled = true));
  
      mainButton.innerHTML = '<div class="loader"></div>';
  
      try {
        const { convertedTracks, unconvertedCount } = await convertLocalTracksToSpotify(
            tracks, 
            (progress) => { mainButton.innerText = progress; }
        );
    
        if (unconvertedCount > 0) {
            const plural = unconvertedCount === 1 ? "track" : "tracks";
            showNotification(`${unconvertedCount} local ${plural} not found on Spotify and were skipped.`);
        }
        
        if (convertedTracks.length === 0) {
            throw new Error('No tracks found to analyze after conversion');
        }

        const userApiKey = localStorage.getItem("sort-play-gemini-api-key") || Ge_mini_Key();
  
        selectedAiModel = modelSelect.value; 
  
        const aiResponse = await queryGeminiWithPlaylistTracks(
          convertedTracks,
          userPrompt,
          userApiKey,
          undefined,
          undefined,
          includeSongStats,
          includeLyrics,
          selectedAiModel  
        );
  
        if (!aiResponse || aiResponse.length === 0) {
          showNotification("AI did not return any track URIs. Try a different prompt or model.", true);
          resetButtons();
          return;
        }

        mainButton.innerText = "Verifying...";
        const trackIds = aiResponse.map(uri => uri.split(':')[2]);
        const verifiedTracks = [];
        const batchSize = 50;

        for (let i = 0; i < trackIds.length; i += batchSize) {
            const batch = trackIds.slice(i, i + batchSize);
            try {
                let responseTracks = [];

                const fetchBatchInternal = async () => {
                    return await Promise.all(batch.map(id => fetchInternalTrackMetadata(id)));
                };

                if (isFallbackActive()) {
                    responseTracks = await fetchBatchInternal();
                } else {
                    try {
                        const response = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${batch.join(',')}`);
                        responseTracks = response?.tracks || [];
                    } catch (error) {
                        if (registerWebApiFailure()) {
                            responseTracks = await fetchBatchInternal();
                        } else {
                            throw error;
                        }
                    }
                }

                if (responseTracks) {
                    const availableTracks = await Promise.all(responseTracks.map(async track => {
                        if (track && await isTrackAvailable(track)) {
                            return track.uri;
                        }
                        return null;
                    }));
                    verifiedTracks.push(...availableTracks.filter(Boolean));
                }
            } catch (error) {
                console.warn("Sort-Play: Error during AI track verification batch.", error);
            }
        }

        if (verifiedTracks.length === 0) {
            showNotification("AI returned invalid or unavailable tracks. Please try again.", true);
            resetButtons();
            return;
        }
  
        const sourceUri = currentUri;
        const isArtistPage = URI.isArtist(sourceUri);
        const isAlbumPage = URI.isAlbum(sourceUri);
        let sourceName = "Source";
        const sourceId = sourceUri.split(":")[2];

        try {
            if (isArtistPage) {
                const fetchArtistFallback = async () => {
                    const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, { uri: sourceUri, locale: "en", includePrerelease: false });
                    return res.data.artistUnion.profile.name;
                };

                if (isFallbackActive()) {
                    sourceName = await fetchArtistFallback();
                } else {
                    try {
                        const artistData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists/${sourceId}`);
                        sourceName = artistData.name;
                    } catch (e) {
                        if (registerWebApiFailure()) {
                            sourceName = await fetchArtistFallback();
                        } else { throw e; }
                    }
                }
            } else if (isLikedSongsPage(sourceUri)) {
                sourceName = "Liked Songs";
            } else if (isAlbumPage) {
                const fetchAlbumFallback = async () => {
                    const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: sourceUri, locale: "en", offset: 0, limit: 1 });
                    return res.data.albumUnion.name;
                };

                if (isFallbackActive()) {
                    sourceName = await fetchAlbumFallback();
                } else {
                    try {
                        const albumData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${sourceId}`);
                        sourceName = albumData.name;
                    } catch (e) {
                        if (registerWebApiFailure()) {
                            sourceName = await fetchAlbumFallback();
                        } else { throw e; }
                    }
                }
            } else {
                const fetchPlaylistFallback = async () => {
                    const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(sourceUri);
                    return meta.name;
                };

                if (isFallbackActive()) {
                    sourceName = await fetchPlaylistFallback();
                } else {
                    try {
                        const playlistData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${sourceId}`);
                        sourceName = playlistData.name;
                    } catch (e) {
                        if (registerWebApiFailure()) {
                            sourceName = await fetchPlaylistFallback();
                        } else { throw e; }
                    }
                }
            }
        } catch (e) {
            console.warn("Failed to fetch source name for AI Pick playlist", e);
        }

        let suffixPattern = new RegExp(
          `\\s*(${possibleSuffixes.join("|")})\\s*`
        );
        while (suffixPattern.test(sourceName)) {
          sourceName = sourceName.replace(suffixPattern, "");
        }

        let playlistDescription;
        if (isArtistPage) {
          playlistDescription = `Tracks by ${sourceName}, picked by AI using Sort-Play for request: "${userPrompt}"`;
        } else if (isAlbumPage) {
            let artistName = "Unknown Artist";
            try {
                const fetchAlbumArtistFallback = async () => {
                    const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: sourceUri, locale: "en", offset: 0, limit: 1 });
                    return res.data.albumUnion.artists.items[0]?.profile?.name || "Unknown Artist";
                };

                if (isFallbackActive()) {
                    artistName = await fetchAlbumArtistFallback();
                } else {
                    try {
                        const albumDetails = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${sourceId}`);
                        artistName = albumDetails.artists[0].name;
                    } catch (e) {
                        if (registerWebApiFailure()) {
                            artistName = await fetchAlbumArtistFallback();
                        } else { throw e; }
                    }
                }
            } catch (e) {}
            
            playlistDescription = `Tracks from ${sourceName} by ${artistName}, picked by AI using Sort-Play for request: "${userPrompt}"`;
        } else {
          playlistDescription = `Tracks picked by AI using Sort-Play for request: "${userPrompt}"`;
        }

        const newPlaylist = await createPlaylist(
          `${sourceName} (AI Pick)`,
          playlistDescription 
        );

        await new Promise(resolve => setTimeout(resolve, 1250));
        await addTracksToPlaylist(newPlaylist.id, verifiedTracks);
        
        await addPlaylistToLibrary(newPlaylist.uri);

        showNotification(`AI Pick playlist created with ${verifiedTracks.length} tracks!`);
        
        await navigateToPlaylist(newPlaylist);

      } catch (error) {
        console.error("Error handling AI pick:", error);
        showNotification(
          "An error occurred while processing the AI request.",
          true
        );
      } finally {
        resetButtons();
      }
    });
  }

  const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

  async function processBatchWithRateLimit(items, batchSize, delayMs, processItem) {
    const results = [];
    
    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize);
      const batchResults = await Promise.all(
        batch.map(async (item) => {
          try {
            return await processItem(item);
          } catch (error) {
            console.warn(`Error processing item in batch: ${error.message}`);
            return null;
          }
        })
      );
      
      results.push(...batchResults.filter(result => result !== null));
      
      if (i + batchSize < items.length) {
        await delay(delayMs);
      }
    }
    
    return results;
  }

  async function fetchLyricsFromLrclib(track) {
    const trackName = track.songTitle || track.name || track.title;
    const artistName = track.artistName || track.artist;
    const albumName = track.albumName || track.track?.album?.name;
    const durationMs = track.durationMs || track.track?.duration_ms;

    if (!trackName || !artistName || !albumName || !durationMs) {
        console.warn("[Sort-Play] Missing required data for LRCLIB lookup:", { trackName, artistName, albumName, durationMs });
        return { error: "Missing track data for lyrics lookup" };
    }

    const durationSec = Math.round(durationMs / 1000);

    const params = new URLSearchParams({
        track_name: trackName,
        artist_name: artistName,
        album_name: albumName,
        duration: durationSec,
    });
    const url = `https://lrclib.net/api/get?${params.toString()}`;

    try {
        const gatewayUrl = `${LFM_GATEWAY_URL}${encodeURIComponent(url)}`;
        const response = await fetch(gatewayUrl);

        if (response.status === 404) {
            return { error: "No lyrics found on LRCLIB" };
        }

        if (!response.ok) {
            throw new Error(`LRCLIB API request failed with status ${response.status}`);
        }

        const data = await response.json();

        if (data && data.plainLyrics) {
            return {
                unsynced: data.plainLyrics.split('\n').map(line => ({ text: line })),
                provider: "LRCLIB",
            };
        } else {
            return { error: "No lyrics found in LRCLIB response" };
        }
    } catch (error) {
        console.error(`[Sort-Play] Error fetching lyrics from LRCLIB for "${trackName}":`, error);
        return { error: "LRCLIB request failed" };
    }
  }

  function pruneTracksForApiLimit(tracks, userSystemInstruction, userRequestPayload, maxSize) {
    const getPromptSize = (trackData) => {
        const payload = `Playlist Tracks:\n${JSON.stringify(trackData, null, 2)}`;
        return new Blob([userSystemInstruction, payload, userRequestPayload]).size;
    };

    let currentSize = getPromptSize(tracks);
    if (currentSize <= maxSize) {
        return { prunedTracks: tracks, notification: null };
    }

    console.warn(`[Sort-Play AI] Prompt size (${currentSize} bytes) exceeds limit. Pruning data...`);

    let lyricsRemovedCount = 0;
    let statsRemovedCount = 0;
    const prunedTracks = JSON.parse(JSON.stringify(tracks));

    const tracksWithLyricsIndices = prunedTracks.map((t, i) => (t.lyrics && t.lyrics !== "Not included") ? i : -1).filter(i => i !== -1);
    const shuffledLyricsIndices = shuffleArray(tracksWithLyricsIndices);

    for (const index of shuffledLyricsIndices) {
        delete prunedTracks[index].lyrics;
        lyricsRemovedCount++;
        currentSize = getPromptSize(prunedTracks);
        if (currentSize <= maxSize) break;
    }

    if (currentSize > maxSize) {
        const tracksWithStatsIndices = prunedTracks.map((t, i) => t.stats ? i : -1).filter(i => i !== -1);
        const shuffledStatsIndices = shuffleArray(tracksWithStatsIndices);

        for (const index of shuffledStatsIndices) {
            delete prunedTracks[index].stats;
            statsRemovedCount++;
            currentSize = getPromptSize(prunedTracks);
            if (currentSize <= maxSize) break;
        }
    }
    
    let messageParts = [];
    if (lyricsRemovedCount > 0) messageParts.push(`lyrics from ${lyricsRemovedCount} songs`);
    if (statsRemovedCount > 0) messageParts.push(`stats from ${statsRemovedCount} songs`);
    
    const notification = messageParts.length > 0 ? `Removed ${messageParts.join(' and ')} to fit API limits.` : null;

    if (currentSize > maxSize) {
        console.error("[Sort-Play AI] Could not reduce prompt size enough even after removing all lyrics and stats.");
        throw new Error("Playlist is too large to process, even after removing extra data.");
    }

    return { prunedTracks, notification };
  }

  async function queryGeminiWithPlaylistTracks(tracks, userPrompt, apiKey, maxRetries = 3, initialDelay = 1000, includeSongStats = true, includeLyrics = true, modelName) {
    let enrichedTracksCache = [];
    let tracksToProcess = [];
    let tracksNeedingLyrics = [];

    const trackIds = tracks.map(t => t.uri.split(":")[2]);
    const cacheKeys = trackIds.map(id => getCacheKey(id, includeSongStats, false, modelName));
    
    const bulkData = await idb.getMany('aiData', cacheKeys);

    for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];
        const key = cacheKeys[i];
        const cachedTrack = bulkData.get(key);
        
        if (cachedTrack) {
            if (includeLyrics && (!cachedTrack.lyrics || cachedTrack.lyrics === "Not included")) {
                tracksNeedingLyrics.push({ ...track, cachedData: cachedTrack });
            } else {
                enrichedTracksCache.push(cachedTrack);
            }
        } else {
            tracksToProcess.push(track);
        }
    }

    let fullPrompt;

    try {
        if (tracksToProcess.length > 0) {
            let allBatchStats = {};
            if (includeSongStats) {
                const trackIdsToFetch = tracksToProcess.map(t => t.uri.split(":")[2]);
                allBatchStats = await getBatchTrackStats(trackIdsToFetch);
            }

            const processedTracks = await processBatchWithRateLimit(
                tracksToProcess, 20, 700,
                async track => {
                    const trackId = track.uri.split(":")[2];
                    let stats = includeSongStats ? allBatchStats[trackId] : null;
                    stats = stats || { danceability: null, energy: null, key: "Undefined", loudness: null, speechiness: null, acousticness: null, instrumentalness: null, liveness: null, valence: null, tempo: null, popularity: null, releaseDate: null };
                    
                    let playCount = "N/A";
                    if (includeSongStats) {
                        try {
                            const albumId = track.albumId || track.track?.album?.id;
                            if (albumId) {
                                const albumTracksWithPlayCounts = await getPlayCountsForAlbum(albumId);
                                const foundTrack = albumTracksWithPlayCounts.find(t => t.uri === track.uri);
                                playCount = foundTrack ? foundTrack.playcount : "N/A";
                            }
                        } catch (error) { playCount = "N/A"; }
                    }
                    
                    let lyrics = "Not included";
                    if (includeLyrics) {
                        const lyricsData = await fetchLyricsFromLrclib(track);
                        lyrics = lyricsData?.unsynced ? lyricsData.unsynced.map(line => line.text).join('\n') : "Not included";
                    }
                    
                    const enrichedTrack = {
                        song_title: track.songTitle || track.name || track.title,
                        artist: track.artistName || track.artist,
                        album: track.albumName,
                        uri: track.uri
                    };
        
                    if (includeSongStats) {
                        enrichedTrack.stats = { popularity: stats.popularity, playCount: playCount, releaseDate: stats.releaseDate, danceability: stats.danceability, energy: stats.energy, valence: stats.valence, tempo: stats.tempo, key: stats.key, loudness: stats.loudness, speechiness: stats.speechiness, acousticness: stats.acousticness, liveness: stats.liveness, instrumentalness: stats.instrumentalness };
                    }
        
                    const trackDataForCache = { ...enrichedTrack };
                    if (includeLyrics) {
                        enrichedTrack.lyrics = lyrics;
                    }
                    
                    await setTrackCache(trackId, trackDataForCache, includeSongStats, false, modelName);
                    return enrichedTrack;
                }
            );
            enrichedTracksCache.push(...processedTracks);
        }

        if (tracksNeedingLyrics.length > 0) {
            const processedLyrics = await processBatchWithRateLimit(
                tracksNeedingLyrics, 20, 100,
                async track => {
                    const enrichedTrack = { ...track.cachedData };
                    const lyricsData = await fetchLyricsFromLrclib(track);
                    enrichedTrack.lyrics = lyricsData?.unsynced ? lyricsData.unsynced.map(line => line.text).join('\n') : "Not included";
                    return enrichedTrack;
                }
            );
            enrichedTracksCache.push(...processedLyrics);
        }

        const tracksWithStats = enrichedTracksCache.filter(track => track !== null);
        const userSystemInstruction = localStorage.getItem(STORAGE_KEY_USER_SYSTEM_INSTRUCTION_v2) || DEFAULT_USER_SYSTEM_INSTRUCTION_v2;
        const combinedSystemInstruction = `${userSystemInstruction}\n${FIXED_SYSTEM_INSTRUCTION}`;
        const userRequestPayload = `\n\nUser Request: ${userPrompt}\n\nGIVE PICKED TRACK URI's`;

        const maxPromptSizeBytes = modelName.includes('pro')
            ? 285 * 1024
            : 585 * 1024;

        const { prunedTracks, notification } = pruneTracksForApiLimit(tracksWithStats, combinedSystemInstruction, userRequestPayload, maxPromptSizeBytes);
        if (notification) {
            showNotification(notification, 'warning');
        }
        const trackDataPayload = `Playlist Tracks:\n${JSON.stringify(prunedTracks, null, 2)}`;
        fullPrompt = `${combinedSystemInstruction}\n\n${trackDataPayload}\n\n${userRequestPayload}`;

    } catch (dataPrepError) {
        console.error("A critical error occurred during the data preparation phase:", dataPrepError);
        throw dataPrepError;
    }

    let retries = 0;
    let delay = initialDelay;
    let currentApiKey = apiKey;
    const usedKeys = new Set([currentApiKey]);

    while (retries < maxRetries) {
        try {
            const GoogleGenAI = await loadGoogleAI();
            if (!GoogleGenAI) throw new Error('Failed to load Google AI SDK');
            const ai = new GoogleGenAI({ apiKey: currentApiKey });

            const result = await ai.models.generateContent({
                model: modelName,
                contents: fullPrompt,
                safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_CIVIC_INTEGRITY", threshold: "BLOCK_NONE" }
                ]
            });

            if (result?.promptFeedback?.blockReason) {
                throw new Error(`Blocked for ${result.promptFeedback.blockReason}`);
            }

            const responseText = result.text;
            const uriRegex = /spotify:track:[a-zA-Z0-9]{22}/g;
            let matches = responseText.match(uriRegex);

            if (!matches) {
                console.log("No Spotify track URIs found in AI response.");
                return [];
            }
            
            return [...new Set(matches)];

        } catch (error) {
            console.error(`Error during Gemini request (Attempt ${retries + 1}):`, error);

            if (error.toString().includes('429')) {
                console.log('[Sort-Play AI] Quota exceeded. Rotating to a new API key...');
                let newKey;
                if (usedKeys.size < Ge_mini_Key_Pool.length) {
                    do { newKey = Ge_mini_Key(); } while (usedKeys.has(newKey));
                } else {
                    console.warn('[Sort-Play AI] All keys in the pool have been tried. Re-using a random key.');
                    newKey = Ge_mini_Key(); 
                }
                currentApiKey = newKey;
                usedKeys.add(currentApiKey);
                console.log(`[Sort-Play AI] Retrying with new key: ...${currentApiKey.slice(-4)}`);
            }

            if (retries === maxRetries - 1) {
                throw new Error(`Failed to get a valid response from Gemini after ${maxRetries} retries.`);
            }
            retries++;
            await new Promise(resolve => setTimeout(resolve, delay));
            delay *= 2;
        }
    }
  }

  function showGeminiApiKeyModal() {
    const savedApiKey = localStorage.getItem("sort-play-gemini-api-key");

    const overlay = document.createElement("div");
    overlay.id = "sort-play-gemini-modal-overlay";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.7); z-index: 2005;
        display: flex; justify-content: center; align-items: center;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container sort-play-font-scope";
    modalContainer.style.cssText = `
        width: 420px !important;
        border-radius: 30px;
        overflow: hidden; 
        background-color: #181818 !important;
        border: 2px solid #282828;
        display: flex;
        flex-direction: column;
    `;

    modalContainer.innerHTML = `
      <div class="main-trackCreditsModal-header" style="padding: 27px 32px 12px !important;">
          <h1 class="main-trackCreditsModal-title"><span style='font-size: 25px;'>Gemini API Key</span></h1>
      </div>
      <div class="main-trackCreditsModal-originalCredits" style="padding: 25px 32px 20px 32px !important;">
          <div style="display: flex; flex-direction: column; gap: 15px;">
            <div style="display: flex; flex-direction: column; gap: 5px;">
              <input type="text" id="geminiApiKey" value="${savedApiKey || ""}" placeholder="Enter your API key (optional)"
                    style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #282828; background: #282828; color: white;">
              <a href="https://aistudio.google.com/api-keys" target="_blank" style="color: #1ED760; font-size: 14px; margin-left: 2px; margin-top: 4px; text-decoration: none;">Get the free API key from here</a>
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 5px;">
              <button id="cancelGeminiApi" class="main-buttons-button" 
                      style="width: 83px; padding: 8px 16px; border-radius: 20px; border: none; cursor: pointer; background-color: #333333; color: white; font-weight: 550; font-size: 13px; text-transform: uppercase; transition: all 0.04s ease;">
                Cancel
              </button>
              <button id="saveGeminiApi" class="main-buttons-button main-button-primary" 
                      style="padding: 8px 18px; border-radius: 20px; border: none; cursor: pointer; background-color: #1ED760; color: black; font-weight: 550; font-size: 13px; text-transform: uppercase; transition: all 0.04s ease;">
                Save
              </button>
            </div>
          </div>
      </div>
    `;

    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);
    
    const inputField = document.getElementById("geminiApiKey");
    inputField.focus();

    const closeModal = () => overlay.remove();

    const saveButton = document.getElementById("saveGeminiApi");
    const cancelButton = document.getElementById("cancelGeminiApi");

    saveButton.addEventListener("mouseenter", () => { saveButton.style.backgroundColor = "#3BE377"; });
    saveButton.addEventListener("mouseleave", () => { saveButton.style.backgroundColor = "#1ED760"; });
    cancelButton.addEventListener("mouseenter", () => { cancelButton.style.backgroundColor = "#444444"; });
    cancelButton.addEventListener("mouseleave", () => { cancelButton.style.backgroundColor = "#333333"; });

    saveButton.addEventListener("click", async () => {
      const apiKey = inputField.value.trim();

      saveButton.disabled = true;
      saveButton.style.backgroundColor = "#FFFFFFB3";
      saveButton.textContent = "Saving...";

      if (apiKey) {
        localStorage.setItem("sort-play-gemini-api-key", apiKey);
        showNotification("Gemini API key saved successfully!");
      } else {
        localStorage.removeItem("sort-play-gemini-api-key");
        showNotification("Gemini API key cleared.");
      }

      closeModal();
    });

    cancelButton.addEventListener("click", closeModal);
    overlay.addEventListener("click", (e) => { if (e.target === overlay) closeModal(); });
  }

  function rgbToHsl(r, g, b) {
    r /= 255, g /= 255, b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return { h: h * 360, s, l };
  }


  async function loadImageDirectly(imageUrl) {
      return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'Anonymous';
          img.onload = () => resolve(img);
          img.onerror = (err) => {
              const error = new Error(`Failed to load image directly from ${imageUrl}`);
              reject(error);
          };
          img.src = imageUrl;
      });
  }


  async function getPaletteAnalysis(imageUrl) {
      if (!colorThiefLib) {
          throw new Error("ColorThief library not loaded.");
      }

      try {
          const img = await loadImageDirectly(imageUrl);
          const colorThief = new colorThiefLib();
          const paletteRgb = colorThief.getPalette(img, 5);

          if (!paletteRgb || paletteRgb.length === 0) {
              throw new Error("ColorThief could not extract a palette.");
          }

          const paletteHsl = paletteRgb.map(rgb => rgbToHsl(...rgb));
          const dominantHsl = paletteHsl[0];

          const MONOCHROME_SATURATION_THRESHOLD = 0.10;
          const isMonochrome = paletteHsl.every(color => color.s < MONOCHROME_SATURATION_THRESHOLD);

          return {
              isMonochrome: isMonochrome,
              dominantHsl: dominantHsl
          };
      } catch (error) {
          console.error("Failed to get palette analysis:", error);
          throw error;
      }
  }

  async function getCachedPaletteAnalysis(albumId) {
      return await idb.get('palettes', albumId, CACHE_EXPIRE_PALETTE);
  }
  async function setCachedPaletteAnalysis(albumId, analysisData) {
      await idb.set('palettes', albumId, analysisData);
  }

  async function getAlbumColorAnalysis(albumId) {
      const cachedAnalysis = await getCachedPaletteAnalysis(albumId);
      if (cachedAnalysis) {
          return cachedAnalysis;
      }

      const fetchInternal = async () => {
          try {
              const hexId = spotifyHex(albumId);
              const token = Spicetify.Platform.Session.accessToken;
              const res = await fetch(`https://spclient.wg.spotify.com/metadata/4/album/${hexId}?market=from_token&alt=json`, {
                  headers: { "Authorization": `Bearer ${token}` }
              });
              
              if (res.ok) {
                  const body = await res.json();
                  if (body.cover_group && body.cover_group.image) {
                      const images = body.cover_group.image.map(img => ({
                          url: `https://i.scdn.co/image/${img.file_id}`,
                          width: img.width || 0,
                          height: img.height || 0
                      }));
                      images.sort((a, b) => b.width - a.width);
                      return { images: images };
                  }
              }
          } catch(e) {
          }

          const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, {
              uri: `spotify:album:${albumId}`,
              locale: "en",
              offset: 0,
              limit: 1
          });
          const u = res.data.albumUnion;
          if (u && u.coverArt && u.coverArt.sources && u.coverArt.sources.length > 0) {
              return { images: u.coverArt.sources };
          }
          throw new Error(`No images found for album ${albumId} via Internal APIs`);
      };

      try {
          let albumDetails;

          if (isFallbackActive()) {
              albumDetails = await fetchInternal();
          } else {
              try {
                  albumDetails = await withRetry(
                    () => Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${albumId}`),
                    CONFIG.spotify.retryAttempts,
                    CONFIG.spotify.retryDelay
                  );
              } catch (error) {
                  if (registerWebApiFailure()) {
                      albumDetails = await fetchInternal();
                  } else {
                      throw error;
                  }
              }
          }

          const images = albumDetails?.images;
          if (!images || images.length === 0) {
              throw new Error(`No images found for album ${albumId}`);
          }

          const imageUrl = images[images.length - 1].url;
          const analysisData = await getPaletteAnalysis(imageUrl);

          await setCachedPaletteAnalysis(albumId, analysisData);
          return analysisData;
      } catch (error) {
          console.warn(`Could not get palette analysis for album ${albumId}:`, error);
          await setCachedPaletteAnalysis(albumId, null);
          return null;
      }
  }

  async function getTrackDetailsWithPaletteAnalysis(track) {
      const albumId = track.albumId || track.track?.album?.id;
      if (!albumId) {
          console.warn(`Could not determine album ID for track ${track.songTitle}`);
          return { ...track, averageColor: null };
      }
      
      const analysisData = await getAlbumColorAnalysis(albumId);
      
      return { ...track, averageColor: analysisData };
  }

  async function getTrackDetailsWithReleaseDateForFilter(track) {
    const trackWithStandardReleaseDate = await getTrackDetailsWithReleaseDate(track);
    
    if (trackWithStandardReleaseDate.releaseDate) {
      return trackWithStandardReleaseDate;
    }

    let albumId;
    if (track.albumId) {
      albumId = track.albumId;
    } else if (track.albumUri) {
      albumId = track.albumUri.split(":")[2];
    } else {
      return trackWithStandardReleaseDate;
    }
    
    const trackId = track.uri.split(":")[2];

    try {
        let releaseDate = null;

        if (isFallbackActive()) {
            const meta = await fetchInternalTrackMetadata(trackId);
            if (meta && meta.album && meta.album.release_date) {
                releaseDate = meta.album.release_date;
            }
        } else {
            try {
                const result = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks/${trackId}`);
                if (result && result.album && result.album.release_date) {
                    releaseDate = result.album.release_date;
                }
            } catch (e) {
                if (registerWebApiFailure()) {
                    const meta = await fetchInternalTrackMetadata(trackId);
                    if (meta && meta.album && meta.album.release_date) {
                        releaseDate = meta.album.release_date;
                    }
                }
            }
        }

        if (!releaseDate) {
             try {
                 const albumResult = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${albumId}`);
                 if (albumResult && albumResult.release_date) {
                     releaseDate = albumResult.release_date;
                 }
             } catch(e) {}
        }
      
      if (releaseDate) {
        return {
          ...trackWithStandardReleaseDate,
          releaseDate: releaseDate
        };
      }
      
      return trackWithStandardReleaseDate;
      
    } catch (error) {
      return trackWithStandardReleaseDate;
    }
  }
  
  async function processArtistPageTracks(tracks, isHeadless = false) {
    if (!isHeadless) mainButton.innerText = "Correcting...";
    
    const refreshedTracks = await refreshTrackAlbumInfo(
        tracks, 
        (progress) => { if (!isHeadless) mainButton.innerText = `${Math.floor(progress * 0.30)}%`; }
    );

    if (!isHeadless) mainButton.innerText = "Enriching...";
    
    const tracksWithPlayCounts = await enrichTracksWithPlayCounts(
        refreshedTracks, 
        (progress) => { if (!isHeadless) mainButton.innerText = `${30 + Math.floor(progress * 0.60)}%`; }
    );

    const { unique } = await deduplicateTracks(
        tracksWithPlayCounts, 
        true, 
        true,
        (progress) => { if (!isHeadless) mainButton.innerText = `Dedup ${progress}%`; }
    );
    
    if (!isHeadless) mainButton.innerText = "Ready";
    return unique;
  }

  async function handleCustomFilter() {
    menuButtons.forEach((btn) => {
      if (btn.tagName.toLowerCase() === 'button' && !btn.disabled) {
        btn.style.backgroundColor = "transparent";
      }
    });
    setButtonProcessing(true);
    mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
    mainButton.style.color = buttonStyles.main.disabledColor;
    mainButton.style.cursor = "default";
    svgElement.style.fill = buttonStyles.main.disabledColor;
    menuButtons.forEach((button) => (button.disabled = true));
    
    toggleMenu();
    closeAllMenus();

    try {
        const currentUri = getCurrentUri();
        if (!currentUri) {
            resetButtons();
            showNotification("Please select a playlist or artist first");
            return;
        }

        let tracks;
        let isArtistPage = false;

        if (URI.isPlaylistV1OrV2(currentUri)) {
            const playlistId = currentUri.split(":")[2];
            tracks = await getPlaylistTracks(playlistId);
        } else if (URI.isArtist(currentUri)) {
            tracks = await getArtistTracks(currentUri);
            isArtistPage = true;
        } else if (isLikedSongsPage(currentUri)) {
            tracks = await getLikedSongs();
        } else if (URI.isAlbum(currentUri)) {
            const albumId = currentUri.split(":")[2];
            tracks = await getAlbumTracks(albumId);
        } else {
            throw new Error('Invalid playlist or artist page');
        }

        if (!tracks || tracks.length === 0) {
            throw new Error('No tracks found');
        }

        if (isArtistPage) {
            tracks = await processArtistPageTracks(tracks);
        }

        const { convertedTracks, unconvertedCount } = await convertLocalTracksToSpotify(
            tracks, 
            (progress) => { mainButton.innerText = progress; }
        );
    
        if (unconvertedCount > 0) {
            const plural = unconvertedCount === 1 ? "track" : "tracks";
            showNotification(`${unconvertedCount} local ${plural} not found on Spotify and were skipped.`);
        }
        
        if (convertedTracks.length === 0) {
            throw new Error('No tracks found');
        }
        tracks = convertedTracks;
        mainButton.innerText = "0%";

        const tracksWithPlayCounts = await enrichTracksWithPlayCounts(
            tracks,
            (progress) => {
                mainButton.innerText = `${Math.floor(progress * 0.25)}%`;
            }
        );

        const tracksWithIds = await processBatchesWithDelay(
          tracksWithPlayCounts,
          50,
          500,
          (progress) => {
            mainButton.innerText = `${25 + Math.floor(progress * 0.25)}%`; 
          },
          collectTrackIdsForPopularity 
        );
        const tracksWithPopularity = await fetchPopularityForMultipleTracks(
            tracksWithIds,
            (progress) => {
              mainButton.innerText = `${50 + Math.floor(progress * 0.25)}%`; 
            }
        );
        const tracksWithReleaseDates = await processBatchesWithDelay(
            tracksWithPopularity,
            50,
            500,
            (progress) => {
                mainButton.innerText = `${75 + Math.floor(progress * 0.25)}%`;
            },
            getTrackDetailsWithReleaseDateForFilter 
        );

        mainButton.innerText = "Analyzing...";
        const trackMap = new Map(tracksWithReleaseDates.map(t => [t.uri.split(":")[2], t]));

        const trackIdsToFetch = [];
        for (const track of tracksWithReleaseDates) {
            const trackId = track.uri.split(":")[2];
            const cached = await getTrackCache(trackId, true, false, selectedAiModel);
            if (!cached) trackIdsToFetch.push(trackId);
        }

        if (trackIdsToFetch.length > 0) {
            const batchStats = await getBatchTrackStats(trackIdsToFetch);
            for (const [trackId, stats] of Object.entries(batchStats)) {
                const originalTrack = trackMap.get(trackId);
                if (originalTrack) {
                    const cacheData = {
                        song_title: originalTrack.songTitle || originalTrack.name,
                        artist: originalTrack.allArtists || originalTrack.artistName,
                        album: originalTrack.albumName,
                        uri: originalTrack.uri,
                        stats: stats
                    };
                    await setTrackCache(trackId, cacheData, true, false, selectedAiModel);
                }
            }
        }

        const aiCacheKeys = tracksWithReleaseDates.map(t => {
            return getCacheKey(t.uri.split(":")[2], true, false, selectedAiModel);
        });
        
        const bulkAiData = await idb.getMany('aiData', aiCacheKeys);

        const tracksWithFeatures = tracksWithReleaseDates.map(track => {
            const trackId = track.uri.split(":")[2];
            const cacheKey = getCacheKey(trackId, true, false, selectedAiModel);
            const cachedData = bulkAiData.get(cacheKey);
            return { ...track, features: cachedData ? cachedData.stats : {} };
        });
        
        showCustomFilterModal(tracksWithFeatures, currentUri);

    } catch (error) {
        console.error("Error in custom filter:", error);
        showNotification(
            "An error occurred while preparing the custom filter.",
            true
        );
    } finally {
        resetButtons();
    }
  }

  async function convertLocalTracksToSpotify(tracks, updateProgress = () => {}) {
    const localTracks = tracks.filter(track => Spicetify.URI.isLocal(track.uri));
    const spotifyTracks = tracks.filter(track => !Spicetify.URI.isLocal(track.uri));
    
    if (localTracks.length === 0) {
        return { convertedTracks: spotifyTracks, unconvertedCount: 0 };
    }

    updateProgress("Converting...");

    const foundSpotifyTracks = [];
    let unconvertedLocalCount = 0;
    const BATCH_SIZE = 20;
    const DELAY_BETWEEN_BATCHES = 2000;
    const MAX_RETRIES = 3;
    const RETRY_DELAYS = [1000, 2000, 4000];
    
    async function retryOperation(operation, context = "", maxRetries = MAX_RETRIES) {
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                if (attempt === maxRetries) throw error;
                let delay = RETRY_DELAYS[attempt] || RETRY_DELAYS[RETRY_DELAYS.length - 1];
                console.warn(`[Sort-Play] Retry ${attempt + 1}/${maxRetries} for ${context} after ${delay}ms. Error:`, error.message);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    for (let i = 0; i < localTracks.length; i += BATCH_SIZE) {
        const batch = localTracks.slice(i, i + BATCH_SIZE);
        updateProgress(`${Math.min(i + BATCH_SIZE, localTracks.length)}/${localTracks.length}`);

        const searchPromises = batch.map(async (track, idx) => {
            const artistQuery = track.artistName || "";
            const uniqueArtists = [...new Set(artistQuery.split(/[;,]/).map(a => a.trim()).filter(Boolean))];
            const artistSearchTerm = uniqueArtists.join(' ');
            
            const lenientQuery = `${track.name} ${artistSearchTerm}`;
            const strictQuery = `track:"${track.name}" artist:"${artistSearchTerm}"`;

            try {
                let result = { tracks: { items: [] } };

                const getFirstWord = (title) => {
                    if (!title) return "";
                    return title.toLowerCase().replace(/^[^a-z0-9]+/, '').split(/\s+/)[0];
                };
                const localFirstWord = getFirstWord(track.name);
                const localArtistWords = (track.artistName || "").toLowerCase().split(/\s+/).filter(w => w.length > 1);

                const verifyTrack = (spotifyTrack) => {
                    if (!spotifyTrack || !spotifyTrack.name) return false;
                    if (localFirstWord !== getFirstWord(spotifyTrack.name)) return false;
                    const spotifyArtistString = spotifyTrack.artists.map(a => a.name).join(' ').toLowerCase();
                    return localArtistWords.some(word => spotifyArtistString.includes(word));
                };

                const lenientResult = await retryOperation(
                    () => Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(lenientQuery)}&type=track&limit=5`),
                    `track ${i + idx + 1} (lenient)`
                );

                let verifiedTrack = null;
                if (lenientResult.tracks && lenientResult.tracks.items.length > 0) {
                    verifiedTrack = lenientResult.tracks.items.find(verifyTrack);
                }

                if (!verifiedTrack) {
                    const strictResult = await retryOperation(
                        () => Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(strictQuery)}&type=track&limit=5`),
                        `track ${i + idx + 1} (strict)`
                    );
                    if (strictResult.tracks && strictResult.tracks.items.length > 0) {
                        verifiedTrack = strictResult.tracks.items.find(verifyTrack);
                    }
                }

                if (verifiedTrack) {
                    result = { tracks: { items: [verifiedTrack] } };
                }
                
                return { success: true, result, originalTrack: track };
            } catch (err) {
                return { success: false, error: err, originalTrack: track };
            }
        });

        const searchResults = await Promise.all(searchPromises);

        searchResults.forEach(res => {
            if (res.success && res.result.tracks && res.result.tracks.items.length > 0) {
                const spotifyTrack = res.result.tracks.items[0];
                foundSpotifyTracks.push({
                    uri: spotifyTrack.uri, uid: null, name: spotifyTrack.name,
                    albumUri: spotifyTrack.album.uri, albumName: spotifyTrack.album.name,
                    artistUris: spotifyTrack.artists.map(a => a.uri),
                    allArtists: spotifyTrack.artists.map(a => a.name).join(", "),
                    artistName: spotifyTrack.artists[0].name,
                    durationMilis: spotifyTrack.duration_ms,
                    playCount: "N/A", popularity: null, releaseDate: null,
                    track: {
                        album: { id: spotifyTrack.album.id, name: spotifyTrack.album.name },
                        name: spotifyTrack.name, duration_ms: spotifyTrack.duration_ms, id: spotifyTrack.id,
                    }
                });
            } else {
                unconvertedLocalCount++;
            }
        });

        if (i + BATCH_SIZE < localTracks.length) {
            await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_BATCHES));
        }
    }
    
    return {
        convertedTracks: [...spotifyTracks, ...foundSpotifyTracks],
        unconvertedCount: unconvertedLocalCount
    };
  }
  
  function debounce(func, delay) {
      let timeout;
      return function(...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), delay);
      };
  }

  function formatDuration(ms) {
    if (ms === null || ms === undefined || isNaN(ms)) {
        return "N/A";
    }
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${String(seconds).padStart(2, '0')}`;
  }

  const removeIconSVG = `<svg class="remove-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M982.032787 847.737705L637.901639 503.606557l327.344263-327.344262c33.57377-33.57377 33.57377-83.934426 0-117.508197s-83.934426-33.57377-117.508197 0L520.393443 386.098361 176.262295 50.360656C142.688525 16.786885 92.327869 16.786885 58.754098 50.360656 25.180328 83.934426 25.180328 134.295082 58.754098 167.868852l344.131148 335.737705-335.737705 335.737705c-33.57377 33.57377-33.57377 83.934426 0 117.508197 16.786885 16.786885 41.967213 25.180328 58.754098 25.180328s41.967213-8.393443 58.754099-25.180328l335.737705-335.737705 344.131147 344.131148c16.786885 16.786885 33.57377 25.180328 58.754099 25.180328 25.180328 0 41.967213-8.393443 58.754098-25.180328 33.57377-33.57377 33.57377-83.934426 0-117.508197z"/></svg>`;
  const restoreIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="5.9844 5.9844 36 36.0312" width="14px" height="14px" preserveAspectRatio="none" class="remove-icon"><path d="M 24 42 C 23.211 42 22.462 41.934 21.752 41.846 C 20.221 41.685 19.438 39.926 20.343 38.681 C 20.78 38.08 21.513 37.77 22.248 37.877 C 22.852 37.952 23.431 38 24 38 C 31.756 38 38 31.756 38 24 C 38 16.244 31.756 10 24 10 C 16.244 10 10 16.244 10 24 C 10 26.635 10.739 29.081 12 31.178 L 12 31 C 11.978 29.46 13.631 28.475 14.976 29.226 C 15.617 29.584 16.01 30.265 16 31 L 16 36.488 L 16 37 C 16 38.105 15.105 39 14 39 L 8 39 C 6.46 39.022 5.475 37.369 6.226 36.024 C 6.584 35.383 7.265 34.99 8 35 L 9.77 35 C 7.412 31.956 6 28.138 6 24 C 6 14.082 14.082 6 24 6 C 33.918 6 42 14.082 42 24 C 42 33.918 33.918 42 24 42 Z" style="transform-origin: 23.9844px 24px;" transform="matrix(0, 1, -1, 0, -0.000001907349, 0.00000100024)" id="object-0"/></svg>`;
  const saveIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" fill="#ffffff" viewBox="0 0 24 24"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>`;  const loadIconSVG = `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <g id="File / Folder">
  <path id="Vector" d="M3 6V16.8C3 17.9201 3 18.4798 3.21799 18.9076C3.40973 19.2839 3.71547 19.5905 4.0918 19.7822C4.5192 20 5.07899 20 6.19691 20H17.8031C18.921 20 19.48 20 19.9074 19.7822C20.2837 19.5905 20.5905 19.2841 20.7822 18.9078C21.0002 18.48 21.0002 17.9199 21.0002 16.7998L21.0002 9.19978C21.0002 8.07967 21.0002 7.51962 20.7822 7.0918C20.5905 6.71547 20.2839 6.40973 19.9076 6.21799C19.4798 6 18.9201 6 17.8 6H12M3 6H12M3 6C3 4.89543 3.89543 4 5 4H8.67452C9.1637 4 9.40886 4 9.63904 4.05526C9.84311 4.10425 10.0379 4.18526 10.2168 4.29492C10.4186 4.41857 10.5918 4.59182 10.9375 4.9375L12 6" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  </g>
  </svg>`;
  const clearIconSVG = `<svg viewBox="16 15 43 43" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" baseProfile="full" enable-background="new 0 0 76.00 76.00" xml:space="preserve">
    <path fill="#ffffff" fill-opacity="1" stroke-width="0.2" stroke-linejoin="round" d="M 18.0147,41.5355C 16.0621,39.5829 16.0621,36.4171 18.0147,34.4645L 26.9646,25.5149C 28.0683,24.4113 29,24 31,24L 52,24C 54.7614,24 57,26.2386 57,29L 57,47C 57,49.7614 54.7614,52 52,52L 31,52C 29,52 28.0683,51.589 26.9646,50.4854L 18.0147,41.5355 Z M 47.5281,42.9497L 42.5784,37.9999L 47.5281,33.0502L 44.9497,30.4717L 40,35.4215L 35.0502,30.4717L 32.4718,33.0502L 37.4215,37.9999L 32.4718,42.9497L 35.0502,45.5281L 40,40.5783L 44.9497,45.5281L 47.5281,42.9497 Z "/>
  </svg>`;

function createKeywordTag(keyword, container, keywordSet, onUpdateCallback = () => {}) {
        const tag = document.createElement("span");
        tag.className = "keyword-tag";
        tag.innerHTML = `
            ${keyword}
            <span class="keyword-tag-remove">Ã—</span>
        `;

        tag.querySelector(".keyword-tag-remove").addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            tag.remove();
            keywordSet.delete(keyword);
            onUpdateCallback();
        });

        tag.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        const tagsContainer = container.querySelector(".keyword-tags-container");
        tagsContainer.appendChild(tag);
        tagsContainer.scrollTop = tagsContainer.scrollHeight;
    }

    function setupKeywordInput(container, keywordSet, onUpdateCallback = () => {}) {
      if(!container) return;
      const input = container.querySelector(".keyword-input");
      const clearButton = container.querySelector(".keyword-remove-all-button");
      const saveButton = container.querySelector(".keyword-save-button");
      const loadButton = container.querySelector(".keyword-load-button");
      
      if(!input) return;

      input.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
      });

      input.addEventListener("keydown", (e) => {
          e.stopPropagation();
          if (e.key === "Enter" || e.key === ",") {
              e.preventDefault();
              const keyword = input.value.trim().toLowerCase();
              if (keyword && !keywordSet.has(keyword)) {
                  keywordSet.add(keyword);
                  createKeywordTag(keyword, container, keywordSet, onUpdateCallback);
                  input.value = "";
                  onUpdateCallback();
              }
          }
      });

      if (clearButton) {
        clearButton.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const tagsContainer = container.querySelector(".keyword-tags-container");
            tagsContainer.innerHTML = "";
            keywordSet.clear();
            onUpdateCallback();
        });
      }

      input.addEventListener("blur", () => {
          const keyword = input.value.trim().toLowerCase();
          if (keyword && !keywordSet.has(keyword)) {
              keywordSet.add(keyword);
              createKeywordTag(keyword, container, keywordSet, onUpdateCallback);
              input.value = "";
          }
          if (keyword) {
              onUpdateCallback();
          }
      });

      if (saveButton) {
        saveButton.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();

            if (keywordSet.size === 0) {
                showNotification("No keywords to save.");
                return;
            }

            const saveModal = document.createElement("div");
            saveModal.className = "save-keywords-modal";
            saveModal.innerHTML = `
                <style>
                .save-keywords-modal {
                    background-color: #282828;
                    border-radius: 8px;
                    padding: 16px;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    z-index: 1001;
                    width: 300px;
                }
                .save-keywords-title {
                    color: #fff;
                    font-size: 14px;
                    font-weight: bold;
                    margin-bottom: 12px;
                }
                .save-keywords-input {
                    width: 100%;
                    padding: 8px;
                    border-radius: 4px;
                    border: 1px solid #434343;
                    background: #121212;
                    color: white;
                    margin-bottom: 12px;
                    box-sizing: border-box;
                }
                .save-keywords-button {
                    background-color: #1db954;
                    border: none;
                    color: black;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-weight: bold;
                    cursor: pointer;
                    display: block;
                    width: auto;
                    margin: 0 auto;
                }

                .save-keywords-button:hover {
                    background-color: #1ed760;
                }

                .save-keywords-overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background-color: rgba(0, 0, 0, 0.5);
                    z-index: 1000;
                }
                </style>
                <div class="save-keywords-title">Enter Keywords Group Name</div>
                <input type="text" class="save-keywords-input" placeholder="Group Name">
                <button class="save-keywords-button">Save</button>
            `;
            const overlay = document.createElement("div");
            overlay.className = "save-keywords-overlay";

            document.body.appendChild(overlay);
            document.body.appendChild(saveModal);

            const saveInput = saveModal.querySelector(".save-keywords-input");
            const saveBtn = saveModal.querySelector(".save-keywords-button");

            const closeModal = () => {
                saveModal.remove();
                overlay.remove();
            };

            saveBtn.addEventListener("click", () => {
                const groupName = saveInput.value.trim();
                if (groupName) {
                    let savedKeywordGroups = JSON.parse(localStorage.getItem("sort-play-keyword-groups") || "{}");
                    savedKeywordGroups[groupName] = [...keywordSet];
                    localStorage.setItem("sort-play-keyword-groups", JSON.stringify(savedKeywordGroups));
                    showNotification(`Keywords saved as "${groupName}"`);
                    closeModal();
                } else {
                    showNotification("Please enter a group name.");
                }
            });
            overlay.addEventListener("click", closeModal);
        });
      }

      if (loadButton) {
        loadButton.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();

            let savedKeywordGroups = JSON.parse(localStorage.getItem("sort-play-keyword-groups") || "{}");
            const groupNames = Object.keys(savedKeywordGroups).reverse();

            if (groupNames.length === 0) {
                showNotification("No saved keyword groups.");
                return;
            }

            const dropdown = document.createElement("div");
            dropdown.className = "load-keywords-dropdown";
            dropdown.innerHTML = `
                <style>
                .load-keywords-dropdown {
                    background-color: #282828;
                    border-radius: 4px;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
                    position: absolute;
                    right: 0;
                    z-index: 1002;
                    min-width: 180px;
                    max-width: 250px;
                    max-height: 200px;
                    overflow-y: auto;
                }
                .load-keywords-option {
                    color: #fff;
                    padding-top: 8px;
                    padding-right: 5px;
                    padding-bottom: 8px;
                    padding-left: 12px;
                    cursor: pointer;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
                .load-keywords-option:hover {
                    background-color: #383838;
                }
                .load-keywords-option:active, .load-keywords-option.selected {
                    background-color: #1db954;
                    color: black;
                }
                .load-keywords-option .remove-button {
                    opacity: 0;
                    transition: opacity 0.2s;
                    cursor: pointer;
                    padding: 4px;
                    display: flex;
                    align-items: center;
                    max-width: 30px;
                }
                .load-keywords-option:hover .remove-button {
                    opacity: 1;
                }
                .remove-icon {
                    width: 12px;
                    height: 12px;
                    fill: currentColor;
                }
                .load-keywords-option-text {
                    flex-grow: 1;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    font-size: 14px;
                }
                .load-keywords-dropdown::-webkit-scrollbar {
                    width: 8px;
                }
                .load-keywords-dropdown::-webkit-scrollbar-track {
                    background: transparent;
                }
                .load-keywords-dropdown::-webkit-scrollbar-thumb {
                    background-color: #4d4d4d;
                    border-radius: 4px;
                }
                </style>
            `;

            let selectedOption = null;

            groupNames.forEach(groupName => {
                const option = document.createElement("div");
                option.className = "load-keywords-option";

                const optionContent = document.createElement("span");
                optionContent.className = "load-keywords-option-text";
                optionContent.textContent = groupName.length > 30 ? groupName.substring(0, 30) + "..." : groupName;
                optionContent.dataset.fullName = groupName;

                const removeButton = document.createElement("div");
                removeButton.className = "remove-button";
                removeButton.innerHTML = removeIconSVG;

                option.appendChild(optionContent);
                option.appendChild(removeButton);

                optionContent.addEventListener("click", (e) => {
                    const tagsContainer = container.querySelector(".keyword-tags-container");
                    tagsContainer.innerHTML = "";
                    keywordSet.clear();

                    savedKeywordGroups[groupName].forEach(keyword => {
                        keywordSet.add(keyword);
                        createKeywordTag(keyword, container, keywordSet, onUpdateCallback);
                    });

                    onUpdateCallback();
                    showNotification(`Keywords loaded from "${groupName}"`);

                    if (selectedOption) {
                        selectedOption.classList.remove("selected");
                    }
                    option.classList.add("selected");
                    selectedOption = option;

                    dropdown.remove();
                });

                removeButton.addEventListener("click", (e) => {
                    e.stopPropagation();

                    let savedKeywordGroups = JSON.parse(localStorage.getItem("sort-play-keyword-groups") || "{}");
                    delete savedKeywordGroups[groupName];
                    localStorage.setItem("sort-play-keyword-groups", JSON.stringify(savedKeywordGroups));

                    option.remove();
                    showNotification(`Removed keyword group "${groupName}"`);

                    if (Object.keys(savedKeywordGroups).length === 0) {
                        dropdown.remove();
                        showNotification("No more saved keyword groups.");
                    }
                });

                dropdown.appendChild(option);
            });

            loadButton.parentNode.appendChild(dropdown);

            const buttonRect = loadButton.getBoundingClientRect();
            dropdown.style.bottom = `${buttonRect.height + 4}px`;
            dropdown.style.right = `-50px`;

            const removeDropdown = (event) => {
                if (!dropdown.contains(event.target)) {
                    dropdown.remove();
                    document.removeEventListener('click', removeDropdown);
                }
            };
            setTimeout(() => {
                document.addEventListener('click', removeDropdown);
            }, 0);
        });
      }

      container.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
      });
  }

    function saveKeywords(titleAlbumKeywords, artistKeywords) {
        localStorage.setItem("sort-play-title-album-keywords", JSON.stringify([...titleAlbumKeywords]));
        localStorage.setItem("sort-play-artist-keywords", JSON.stringify([...artistKeywords]));
    }

     function loadKeywords() {
      const savedTitleAlbumKeywords = localStorage.getItem("sort-play-title-album-keywords");
      const savedArtistKeywords = localStorage.getItem("sort-play-artist-keywords");

      const titleAlbumKeywords = savedTitleAlbumKeywords ? new Set(JSON.parse(savedTitleAlbumKeywords)) : new Set();
      const artistKeywords = savedArtistKeywords ? new Set(JSON.parse(savedArtistKeywords)) : new Set();
    
      return { titleAlbumKeywords, artistKeywords };
    }

  async function showCustomFilterModal(tracks, currentUri) {
    const modalContainer = document.createElement("div");
    modalContainer.className = "custom-filter-modal";
    const originalTracks = [...tracks];
    let displayedTracks = [];
    let startIndex = 0;
    let pageSize;
    const paginationThreshold = 20;
    let isFirstLoad = true;
    let isLastLoad = false;
    let matchWholeWord = false;
    let activeRangeFilter = localStorage.getItem("sort-play-active-range-filter") || "releaseDate";
    let handleTrackMove = null;

    tracks.forEach(track => {
        track.isRemovedByRange = false;
        track.isRemovedByKeyword = false;
        track.isRemoved = false;
    });

    let tableHeaders = `
        <th class="sticky-col index-col" data-sort-key="index">#</th>
        <th class="sticky-col title-col" data-sort-key="songTitle">Title</th>
        <th class="sticky-col artist-col" data-sort-key="allArtists">Artist</th>
        <th data-sort-key="albumName">Album</th>
        <th data-sort-key="releaseDate">Rel-Date</th>
        <th data-sort-key="durationMs">Duration</th>
        <th data-sort-key="playCount">Plays</th>
        <th data-sort-key="popularity">Popularity</th>
        <th data-sort-key="features.energy">Energy</th>
        <th data-sort-key="features.danceability">Danceability</th>
        <th data-sort-key="features.valence">Valence</th>
        <th data-sort-key="features.tempo">Tempo</th>
        <th data-sort-key="features.key">Key</th>
        <th data-sort-key="features.loudness">Loudness</th>
        <th data-sort-key="features.acousticness">Acousticness</th>
        <th data-sort-key="features.instrumentalness">Instrumentalness</th>
        <th data-sort-key="features.liveness">Liveness</th>
        <th class="sticky-col actions-col">Filter</th>
    `;

    let observer = null;
    let titleAlbumKeywords = new Set();
    let artistKeywords = new Set();
    let keepMatchingMode = false;
    let filterModeRadios;
    let titleToggle;
    let albumToggle;
    let artistToggle;
    let matchWholeWordToggle;
    let maxRowsSelect;
    let rangeFilterTypeSelect;
    let rangeFilterToggle;
    let keywordFilterToggle;
    let settingsLeftWrapper;

    function calculateTotalDuration(trackList) {
        let totalDurationMs = 0;
        trackList.forEach(track => {
            totalDurationMs += track.durationMs;
        });
        return totalDurationMs;
    }

    function formatTotalDuration(totalMs) {
        const totalSeconds = Math.floor(totalMs / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        if(hours > 0)
            return `${hours}h ${minutes}m`;
        else
            return `${minutes}m ${seconds}s`;

    }


    function updatePlaylistStats() {
        if (!modalContainer) return;

        const totalTracks = tracks.length;
        const displayedTracksCount = tracks.filter(track => !track.isRemoved).length;
        const totalDuration = calculateTotalDuration(tracks);
        const displayedDuration = calculateTotalDuration(tracks.filter(track => !track.isRemoved));

        const statsContainer = modalContainer.querySelector(".playlist-stats-container");
        if (statsContainer) {
            statsContainer.innerHTML = `
                <span>${displayedTracksCount}/${totalTracks} tracks</span>
                <span>${formatTotalDuration(displayedDuration)}/${formatTotalDuration(totalDuration)}</span>
            `;
        }
    }

    function loadAlbumArt(track, imgElement, maxRetries = 3, baseDelay = 200) {
        if (imgElement.style.opacity === '1') {
            return;
        }
    
        let attempt = 0;
        let retryTimer;
    
        const clearRetryTimer = () => {
            if (retryTimer) {
                clearTimeout(retryTimer);
                retryTimer = null;
            }
        };
    
        const attemptLoad = async () => {
            try {
                const trackDetails = await Spicetify.GraphQL.Request(
                    Spicetify.GraphQL.Definitions.decorateContextTracks,
                    { uris: [track.uri] }
                );
    
                if (trackDetails?.data?.tracks?.[0]?.response?.status === 429) {
                    attempt++;
                    const waitTime = baseDelay * Math.pow(2, attempt - 1);
                    console.warn(`Rate limit hit for track ${track.uri}, retrying in ${waitTime}ms (attempt ${attempt}/${maxRetries})`);
                    retryTimer = setTimeout(attemptLoad, waitTime);
                    return;
                }
    
                const sources = trackDetails?.data?.tracks?.[0]?.albumOfTrack?.coverArt?.sources;
    
                if (sources?.length > 0) {
                    let bestSource = null;
                    for (const source of sources) {
                        if (source.width >= 40 && source.height >= 40) {
                            if (!bestSource || source.width < bestSource.width) {
                                bestSource = source;
                            }
                        }
                    }
                    const albumArtSrc = bestSource ? bestSource.url : sources[sources.length - 1].url;
    
                    const tempImage = new Image();
                    tempImage.onload = () => {
                        imgElement.src = albumArtSrc;
                        imgElement.style.opacity = '1';
                        clearRetryTimer();
                    };
                    tempImage.onerror = () => {
                        attempt++;
                        if (attempt <= maxRetries) {
                            console.warn(`Failed to load image for track ${track.uri}, retrying (${attempt}/${maxRetries})`);
                            const waitTime = baseDelay * Math.pow(2, attempt - 1);
                            retryTimer = setTimeout(attemptLoad, waitTime);
                        }
                    };
                    tempImage.src = albumArtSrc;
                } else {
                    console.warn(`No image sources found for track ${track.uri}`);
                }
            } catch (error) {
                attempt++;
                if (attempt <= maxRetries) {
                    const waitTime = baseDelay * Math.pow(2, attempt - 1);
                    retryTimer = setTimeout(attemptLoad, waitTime);
                }
            }
        };
    
        attemptLoad();
    }


    function generateTableRows(tracksToDisplay) {
        return tracksToDisplay.map((track, index) => {
            const displayedIndex = startIndex + index;
            const originalIndex = originalTracks.findIndex(t => t.uri === track.uri);

            let row = `
          <tr data-track-uri="${track.uri}" data-row-index="${originalIndex}" class="${track.isRemoved ? 'removed' : ''}">
              <td class="sticky-col index-col">${displayedIndex + 1}</td>
              <td class="sticky-col title-col">
                  <div class="song-info">
                      <div class="main-image-container">
                          <img
                              aria-hidden="false"
                              draggable="false"
                              loading="eager"
                              src="/api/placeholder/40/40"
                              alt=""
                              class="main-image-image2 main-trackList-rowImage"
                              width="40"
                              height="40"
                              style="border-radius: 4px; opacity: 0;"
                              data-track-uri="${track.uri}"
                          />
                      </div>
                      <span class="song-title text-overflow" title="${track.songTitle || track.name}">${track.songTitle || track.name}</span>
                  </div>
              </td>
              <td class="sticky-col artist-col">
                  <span class="text-overflow" title="${track.allArtists}">${track.allArtists}</span> 
              </td>
              <td>
                  <span class="text-overflow" title="${track.albumName}">${track.albumName}</span>
              </td>
              <td>${track.releaseDate ? new Date(track.releaseDate).toLocaleDateString() : "N/A"}</td>
              <td>${formatDuration(track.durationMs)}</td> 
              <td>${Number(track.playCount).toLocaleString()}</td>
              <td>${track.popularity !== null ? track.popularity : "N/A"}</td>
          `;

            row += `
                  <td>${track.features?.energy !== null ? track.features.energy : "N/A"}</td>
                  <td>${track.features?.danceability !== null ? track.features.danceability : "N/A"}</td>
                  <td>${track.features?.valence !== null ? track.features.valence : "N/A"}</td>
                  <td>${track.features?.tempo !== null ? track.features.tempo : "N/A"}</td>
                  <td>${track.features?.key !== null ? track.features.key : "N/A"}</td>
                  <td>${track.features?.loudness !== null ? track.features.loudness : "N/A"}</td>
                  <td>${track.features?.acousticness !== null ? track.features.acousticness : "N/A"}</td>
                  <td>${track.features?.instrumentalness !== null ? track.features.instrumentalness : "N/A"}</td>
                  <td>${track.features?.liveness !== null ? track.features.liveness : "N/A"}</td>
            `;
            row += `
          <td class="sticky-col actions-col">
              <button class="remove-button" data-track-uri="${track.uri}">
                  ${track.isRemoved ? restoreIconSVG : removeIconSVG}
              </button>
          </td>
          </tr>`;
            return row;
        }).join('');
    }


    function loadMore(direction) {
        if (direction === 'down' && !isLastLoad) {
            startIndex += pageSize;
            if (startIndex + pageSize >= tracks.length) {
                isLastLoad = true;
            }
            isFirstLoad = false;
        } else if (direction === 'up' && !isFirstLoad) {
            startIndex -= pageSize;
            if (startIndex <= 0) {
                startIndex = 0;
                isFirstLoad = true;
            }
            isLastLoad = false;
        }

        displayedTracks = tracks.slice(startIndex, startIndex + pageSize);

        if (tracks.length <= startIndex + pageSize + paginationThreshold) {
            isLastLoad = true;
            displayedTracks = tracks.slice(startIndex, tracks.length);
        }

        updateTable(displayedTracks);

        const playlistWrapper = modalContainer.querySelector(".playlist-wrapper");
        if (playlistWrapper) {
            if (direction === 'down') {
                playlistWrapper.scrollTop = 0;
            } else if (direction === 'up') {
                playlistWrapper.scrollTop = playlistWrapper.scrollHeight;
            }
        }
    }

    function generateLoadMoreRow(direction) {
        const row = document.createElement("tr");
        row.className = `load-more-row load-more-row-${direction}`;
        row.innerHTML = `<td colspan="100%" class="load-more-cell">. . . Load More . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Load More . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Load More . . .</td>`;

        row.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            loadMore(direction);
        });

        return row;
    }

    function sortTracks(tracksToSort, sortKey, direction) {
        let sortedTracks = [...tracksToSort];

        if (!sortKey || direction === 'none') return sortedTracks;

        sortedTracks.sort((a, b) => {
            let valueA = sortKey.includes('.') ? sortKey.split('.').reduce((o, k) => (o || {})[k], a) : a[sortKey];
            let valueB = sortKey.includes('.') ? sortKey.split('.').reduce((o, k) => (o || {})[k], b) : b[sortKey];

            if (valueA === null) valueA = -Infinity;
            if (valueB === null) valueB = -Infinity;

            if (valueA === "N/A") valueA = -Infinity;
            if (valueB === "N/A") valueB = -Infinity;

            if (sortKey === 'releaseDate') {
                const dateA = valueA ? new Date(valueA).getTime() : (direction === 'ascending' ? Infinity : -Infinity);
                const dateB = valueB ? new Date(valueB).getTime() : (direction === 'ascending' ? Infinity : -Infinity);
                
                if (dateA !== dateB) {
                    return direction === 'ascending' ? dateA - dateB : dateB - dateA;
                }
                
                const albumA = (a.albumName || "").toLowerCase();
                const albumB = (b.albumName || "").toLowerCase();
                const albumCompare = albumA.localeCompare(albumB);
                if (albumCompare !== 0) return albumCompare;

                return (a.trackNumber || 0) - (b.trackNumber || 0);
            }

            if (typeof valueA === 'string' && typeof valueB === 'string') {
                return direction === 'ascending' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
            }
            return direction === 'ascending' ? valueA - valueB : valueB - valueA;
        });
        return sortedTracks;
    }

    let tableBody;

    function setupIntersectionObserver() {
        if (observer) {
            observer.disconnect();
        }
    
        const observerCallback = (entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const row = entry.target;
                    const img = row.querySelector('img[data-track-uri]');
                    if (!img) return;
    
                    const trackUri = img.dataset.trackUri;
                    const track = originalTracks.find(t => t.uri === trackUri);
                    if (track) {
                        loadAlbumArt(track, img);
                    }
                }
            });
        };
    
        observer = new IntersectionObserver(observerCallback, {
            root: modalContainer.querySelector('.playlist-wrapper'),
            rootMargin: '1200px 0px',
            threshold: 0.1
        });
        
        if(tableBody) {
            const allRows = tableBody.querySelectorAll('tr[data-track-uri]');
            allRows.forEach(row => {
                observer.observe(row);
            });
            
            const visibleImages = tableBody.querySelectorAll('img[data-track-uri][style="opacity: 0;"]');
            visibleImages.forEach(img => {
                const trackUri = img.dataset.trackUri;
                const track = originalTracks.find(t => t.uri === trackUri);
                if (track) {
                    loadAlbumArt(track, img);
                }
            });
        }
    }

    function updateTable(updatedTracks) {
        if(!tableBody) return;
        tableBody.innerHTML = generateTableRows(updatedTracks);
        setupIntersectionObserver();

        const existingTopRow = document.querySelector(".load-more-row-up");
        const existingBottomRow = document.querySelector(".load-more-row-down");
        if (existingTopRow) existingTopRow.remove();
        if (existingBottomRow) existingBottomRow.remove();

        const styleElement = document.querySelector(".custom-filter-load-more-style") || document.createElement("style");
        styleElement.className = "custom-filter-load-more-style";

        if (!isFirstLoad) {
            const topLoadMoreRow = generateLoadMoreRow("up");
            const firstRow = tableBody.firstChild;
            if (firstRow) {
                tableBody.insertBefore(topLoadMoreRow, firstRow);
            } else {
                tableBody.appendChild(topLoadMoreRow);
            }
        }

        if (!isLastLoad) {
            const bottomLoadMoreRow = generateLoadMoreRow("down");
            tableBody.appendChild(bottomLoadMoreRow);
        }
      updatePlaylistStats();
    }

    function calculateMinMax(tracks, filterType) {
        if (tracks.length === 0) {
            return { min: 0, max: 0 };
        }
    
        let min, max;
    
        if (filterType === 'releaseDate') {
            const tracksWithDates = tracks.filter(track => track.releaseDate);
    
            if (tracksWithDates.length === 0) {
                const now = new Date();
                return {
                    min: new Date(now.getFullYear() - 5, 0, 1).getTime(),
                    max: now.getTime()
                };
            }
    
            const timestamps = tracksWithDates.map(track => {
                const date = new Date(track.releaseDate);
                return new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
            });
            min = Math.min(...timestamps);
            max = Math.max(...timestamps);
    
        } else if (filterType === 'durationMs') {
            min = Math.min(...tracks.map(track => track.durationMs));
            max = Math.max(...tracks.map(track => track.durationMs));
    
        } else {
            const values = tracks.map(track => {
                if (filterType === 'playCount') {
                    return (parseInt(track.playCount) || 0);
                } else if (filterType === 'popularity') {
                    return (track.popularity || 0);
                } else if (filterType === 'features.energy') { 
                    return (track.features?.energy ?? 0);
                }
                else if (filterType === 'features.danceability') {
                    return (track.features?.danceability ?? 0);
                }
                else if (filterType === 'features.valence') {
                    return (track.features?.valence ?? 0);
                }
                else if (filterType === 'features.tempo') {
                    return (track.features?.tempo ?? 0);
                }
                return 0;
            });
            min = Math.min(...values);
            max = Math.max(...values);
        }

        return { min, max };
    }

    function formatNumber(number, isMin, filterType) {
        if (isNaN(number)) {
            return "";
        }
    
        if (filterType === 'releaseDate') {
            const date = new Date(number);
            const month = date.getMonth() + 1; 
            const day = date.getDate().toString().padStart(2, '0');
            const year = date.getFullYear();
            return `${month}/${day}/${year}`;
        } else if (filterType === 'playCount') {
            if (number >= 1000000000) {
                return (isMin ? Math.floor(number / 10000000) / 100 : Math.ceil(number / 10000000) / 100) + "B";
            } else if (number >= 1000000) {
                return (isMin ? Math.floor(number / 10000) / 100 : Math.ceil(number / 10000) / 100) + "M";
            } else if (number >= 1000) {
                return (isMin ? Math.floor(number / 10) / 100 : Math.ceil(number / 10) / 100) + "k";
            }
            return number.toString();
        } else if (filterType === 'durationMs') {
            return formatDuration(number);
        }
        
        return number.toString(); 
    }
    

    function parseFormattedNumber(formattedNumber) {
        if (!formattedNumber) {
            return 0;
        }

        formattedNumber = formattedNumber.trim();

        const dateMatch = formattedNumber.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
        if (dateMatch) {
            const month = parseInt(dateMatch[1]) - 1;
            const day = parseInt(dateMatch[2]);
            const year = parseInt(dateMatch[3]);
            const date = new Date(year, month, day);
            if (isNaN(date.getTime())) {  
                return 0; 
            }
            return date.getTime();
        }

        const durationMatch = formattedNumber.match(/^(\d+):(\d+)$/);
        if (durationMatch) {
            const minutes = parseInt(durationMatch[1]);
            const seconds = parseInt(durationMatch[2]);
            return minutes * 60000 + seconds * 1000;
        }

        const match = formattedNumber.match(/^([0-9.]+)([BMK])?$/i);
        if (!match) return 0;

        const numberPart = parseFloat(match[1]);
        const suffix = match[2];

        if (isNaN(numberPart)) return 0;

        switch (suffix) {
            case "B":
                return numberPart * 1000000000;
            case "M":
                return numberPart * 1000000;
            case "K":
                return numberPart * 1000;
            default:
                return numberPart;
        }
    }

    function updateTrackFilters() {
        saveKeywords(titleAlbumKeywords, artistKeywords);
        const keywordFilterEnabled = keywordFilterToggle.checked;
        const keepMatching = keepMatchingMode;
        const filterTitle = titleToggle.checked;
        const filterAlbum = albumToggle.checked;
        const filterArtist = artistToggle.checked;
        const rangeFilterEnabled = rangeFilterToggle.checked;
    
        const minRange = parseFormattedNumber(modalContainer.querySelector("#rangeMin").value) || minRangeValue;
        const maxRange = parseFormattedNumber(modalContainer.querySelector("#rangeMax").value) || maxRangeValue;
    
        localStorage.setItem("sort-play-filter-title", filterTitle);
        localStorage.setItem("sort-play-filter-album", filterAlbum);
        localStorage.setItem("sort-play-filter-artist", filterArtist);
        localStorage.setItem("sort-play-match-whole-word", matchWholeWord);
        localStorage.setItem("sort-play-active-range-filter", activeRangeFilter);
    
        tracks.forEach((track) => {
            if (rangeFilterEnabled) {
                let trackValue;
    
                if (activeRangeFilter === 'releaseDate') {
                    if (!track.releaseDate) {
                        track.isRemovedByRange = true;
                    } else {
                        const trackDate = new Date(track.releaseDate);
                        const trackDateNormalized = new Date(
                            trackDate.getFullYear(),
                            trackDate.getMonth(),
                            trackDate.getDate()
                        ).getTime();
        
                        const minDate = new Date(minRange);
                        const maxDate = new Date(maxRange);
        
                        const minDateNormalized = new Date(
                            minDate.getFullYear(),
                            minDate.getMonth(),
                            minDate.getDate()
                        ).getTime();
        
                        const maxDateNormalized = new Date(
                            maxDate.getFullYear(),
                            maxDate.getMonth(),
                            maxDate.getDate(),
                            23, 59, 59, 999
                        ).getTime();
        
                        track.isRemovedByRange = trackDateNormalized < minDateNormalized || trackDateNormalized > maxDateNormalized;
                    }
                } else if (activeRangeFilter === 'durationMs') {
                    trackValue = track.durationMs;
                    track.isRemovedByRange = trackValue < minRange || trackValue > maxRange;
                } else if (activeRangeFilter === 'playCount') {
                    trackValue = parseInt(track.playCount, 10) || 0;
                    track.isRemovedByRange = trackValue < minRange || trackValue > maxRange;
                } else if (activeRangeFilter === 'popularity') {
                    trackValue = track.popularity || 0;
                    track.isRemovedByRange = trackValue < minRange || trackValue > maxRange;
                } else if (activeRangeFilter.startsWith("features.")) {
                    if (activeRangeFilter === 'features.energy') {
                        trackValue = track.features?.energy ?? 0;
                    } else if (activeRangeFilter === 'features.danceability') {
                        trackValue = track.features?.danceability ?? 0;
                    } else if (activeRangeFilter === 'features.valence') {
                        trackValue = track.features?.valence ?? 0;
                    } else if (activeRangeFilter === 'features.tempo') {
                        trackValue = track.features?.tempo ?? 0;
                    }
                    track.isRemovedByRange = trackValue < minRange || trackValue > maxRange;
                }
            } else {
                track.isRemovedByRange = false;
            }
    
            if (keywordFilterEnabled && !track.isRemovedByRange) {
                if (titleAlbumKeywords.size === 0 && artistKeywords.size === 0) {
                    track.isRemovedByKeyword = false;
                } else {
                    const titleAlbumMatch =
                        titleAlbumKeywords.size === 0
                            ? null
                            : [...titleAlbumKeywords].some((keyword) => {
                                const regex = matchWholeWord
                                    ? new RegExp(`\\b${keyword}\\b`, "i")
                                    : new RegExp(keyword, "i");
                                return (
                                    (filterTitle && regex.test(track.songTitle)) ||
                                    (filterAlbum && regex.test(track.albumName))
                                );
                            });
    
                    const artistMatch =
                        artistKeywords.size === 0
                            ? null
                            : [...artistKeywords].some((keyword) => {
                                const regex = matchWholeWord
                                    ? new RegExp(`\\b${keyword}\\b`, "i")
                                    : new RegExp(keyword, "i");
                                return filterArtist && regex.test(track.allArtists);
                            });
    
                    if (keepMatching) {
                        track.isRemovedByKeyword = !(
                            (titleAlbumMatch === true || titleAlbumMatch === null) &&
                            (artistMatch === true || artistMatch === null)
                        );
                    } else {
                        track.isRemovedByKeyword =
                            titleAlbumMatch === true || artistMatch === true;
                    }
                }
            } else {
                track.isRemovedByKeyword = false;
            }
    
            const shouldRemove = track.isRemovedByRange || track.isRemovedByKeyword;
    
            if (track.isRemoved !== shouldRemove) {
                track.isRemoved = shouldRemove;
            }
        });
    
        startIndex = 0;
        isFirstLoad = true;
        isLastLoad = tracks.length <= pageSize + paginationThreshold;
        displayedTracks = tracks.slice(startIndex, isLastLoad ? tracks.length : pageSize);
        updateTable(displayedTracks);
        updatePlaylistStats();
    }

    function setupDualRangesliderx(sliderxContainerId, minInputId, maxInputId) {
        const sliderxContainer = modalContainer.querySelector(`#${sliderxContainerId}`);
        const sliderx1 = sliderxContainer.querySelector(`#${sliderxContainerId}-1`);
        const sliderx2 = sliderxContainer.querySelector(`#${sliderxContainerId}-2`);
        const minInput = modalContainer.querySelector(`#${minInputId}`);
        const maxInput = modalContainer.querySelector(`#${maxInputId}`);
        const sliderxTrack = sliderxContainer.querySelector(".sliderx-track");

        if(!sliderxContainer         || !sliderx1 || !sliderx2 || !minInput || !maxInput || !sliderxTrack) return;

        let minGap = 0;
        let isDragging = false;

        function slideOne() {
            if (parseInt(sliderx2.value) - parseInt(sliderx1.value) <= minGap) {
                sliderx1.value = parseInt(sliderx2.value) - minGap;
            }
            updateInputs();
            fillColor();
            debouncedUpdateTrackFilters();
        }

        function slideTwo() {
            if (parseInt(sliderx2.value) - parseInt(sliderx1.value) <= minGap) {
                sliderx2.value = parseInt(sliderx1.value) + minGap;
            }
            updateInputs();
            fillColor();
            debouncedUpdateTrackFilters(); 
        }

        function fillColor() {
            const sliderxMaxValue = parseInt(sliderx1.max);
            const sliderxMinValue = parseInt(sliderx1.min);
            const totalRange = sliderxMaxValue - sliderxMinValue;
    
            const value1 = parseInt(sliderx1.value);
            const value2 = parseInt(sliderx2.value);
    
            const percent1 = totalRange === 0 ? 0 : ((value1 - sliderxMinValue) / totalRange) * 100;
            const percent2 = totalRange === 0 ? 100 : ((value2 - sliderxMinValue) / totalRange) * 100;
    
    
            sliderxTrack.style.background = `linear-gradient(to right, #4d4d4d ${percent1}% , #1ed760 ${percent1}% , #1ed760 ${percent2}%, #4d4d4d ${percent2}%)`;
        }

        function updateInputs() {
            minInput.value = formatNumber(parseInt(sliderx1.value), true, activeRangeFilter);
            maxInput.value = formatNumber(parseInt(sliderx2.value), false, activeRangeFilter);
        }

        const debouncedUpdatesliderxs = debounce(updatesliderxs, 800);

        function updatesliderxs() {
            let minValue = parseFormattedNumber(minInput.value);
            let maxValue = parseFormattedNumber(maxInput.value);

            if (minValue === 0) minValue = parseInt(sliderx1.value);
            if (maxValue === 0) maxValue = parseInt(sliderx2.value);

            minValue = Math.max(minRangeValue, Math.min(minValue, maxRangeValue));
            maxValue = Math.max(minRangeValue, Math.min(maxRangeValue, maxValue));

            maxValue = Math.max(minValue, maxValue);

            minInput.value = formatNumber(minValue, true, activeRangeFilter);
            maxInput.value = formatNumber(maxValue, false, activeRangeFilter);

            sliderx1.value = minValue;
            sliderx2.value = maxValue;

            fillColor();
        }

        function handleTrackClick(event) {
            const rect = sliderxTrack.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const trackWidth = rect.width;
            const percent = clickX / trackWidth;
            const range = maxRangeValue - minRangeValue;
            const newValue = minRangeValue + (percent * range);

            const diff1 = Math.abs(newValue - parseInt(sliderx1.value));
            const diff2 = Math.abs(newValue - parseInt(sliderx2.value));

            if (diff1 <= diff2) {
                sliderx1.value = newValue;
                slideOne();
            } else {
                sliderx2.value = newValue;
                slideTwo();
            }
        }

        handleTrackMove = function(event) {
            if (!isDragging) {
                return;
            }
            handleTrackClick(event);
        }

        sliderx1.addEventListener("input", slideOne);
        sliderx2.addEventListener("input", slideTwo);
        minInput.addEventListener("input", debouncedUpdatesliderxs);
        maxInput.addEventListener("input", debouncedUpdatesliderxs);
        minInput.addEventListener("blur", updatesliderxs);
        maxInput.addEventListener("blur", updatesliderxs);

        sliderxTrack.addEventListener("mousedown", (e) => {
            isDragging = true;
            handleTrackClick(e);
        });
        document.addEventListener("mousemove", handleTrackMove);

        document.addEventListener("mouseup", () => {
            isDragging = false;
        });

        updateInputs();
        fillColor();

        sliderx1.addEventListener("input", debouncedUpdateTrackFilters);
        sliderx2.addEventListener("input", debouncedUpdateTrackFilters);
        minInput.addEventListener("input", debouncedUpdateTrackFilters);
        maxInput.addEventListener("input", debouncedUpdateTrackFilters);
    }

    function updateRangeUI(filterType) {
        if(!modalContainer) return;

        if (filterType === "features.energy") {
            minRangeValue = 0;
            maxRangeValue = 1;
        }
        else if (filterType === "features.danceability") {
            minRangeValue = 0;
            maxRangeValue = 1;
        }
        else if (filterType === "features.valence") {
            minRangeValue = 0;
            maxRangeValue = 1;
        }

        const range = calculateMinMax(tracks, filterType);
        minRangeValue = range.min;
        maxRangeValue = range.max;

        const sliderx1 = modalContainer.querySelector("#rangesliderx-1");
        const sliderx2 = modalContainer.querySelector("#rangesliderx-2");
        const minInput = modalContainer.querySelector("#rangeMin");
        const maxInput = modalContainer.querySelector("#rangeMax");
        if(!sliderx1 || !sliderx2 || !minInput || !maxInput) return;

        sliderx1.min = minRangeValue;
        sliderx1.max = maxRangeValue;
        sliderx1.value = minRangeValue;
        sliderx2.min = minRangeValue;
        sliderx2.max = maxRangeValue;
        sliderx2.value = maxRangeValue;

        minInput.value = formatNumber(minRangeValue, true, filterType);
        maxInput.value = formatNumber(maxRangeValue, false, filterType);
        
        if (filterType === "releaseDate") {
            minInput.placeholder = "From Date";
            maxInput.placeholder = "To Date";
            minInput.type = "text"; 
            maxInput.type = "text";
        } else {
            minInput.type = "text";
            maxInput.type = "text";
            minInput.placeholder = filterType === "playCount" ? "Min Plays" : 
                                  filterType === "popularity" ? "Min" : "Min Duration";
            maxInput.placeholder = filterType === "playCount" ? "Max Plays" : 
                                  filterType === "popularity" ? "Max" : "Max Duration";
        }

        const sliderxTrack = modalContainer.querySelector(".sliderx-track");
        if (sliderxTrack) {
            const sliderxMaxValue = parseInt(sliderx1.max);
            const sliderxMinValue = parseInt(sliderx1.min);
            const totalRange = sliderxMaxValue - sliderxMinValue;

            const value1 = parseInt(sliderx1.value);
            const value2 = parseInt(sliderx2.value);

            let percent1 = totalRange === 0 ? 0 : ((value1 - sliderxMinValue) / totalRange) * 100;
            let percent2 = totalRange === 0 ? 100 : ((value2 - sliderxMinValue) / totalRange) * 100;

            percent1 = Math.max(0, Math.min(100, percent1));
            percent2 = Math.max(0, Math.min(100, percent2));
            sliderxTrack.style.background = `linear-gradient(to right, #4d4d4d ${percent1}% , #1ed760 ${percent1}% , #1ed760 ${percent2}%, #4d4d4d ${percent2}%)`;
        }
    }

    const debouncedUpdateTrackFilters = debounce(() => {
        updateTrackFilters();
        setTimeout(() => {
            setupIntersectionObserver();
        }, 100);
        updatePlaylistStats();
    }, 800);



    let initialRange = calculateMinMax(tracks, activeRangeFilter);
    let minRangeValue = initialRange.min;
    let maxRangeValue = initialRange.max;

    modalContainer.innerHTML = `
    <style>
    .custom-filter-modal {
        width: 100%;
        max-width: 1200px;
        color: #fff;
    }
    .tracklist-table .actions-col {
        box-shadow: 2px 0 2px #121212;
    }
    .GenericModal__overlay .GenericModal {
        border-radius: 30px;
        overflow: hidden;
    }
    .GenericModal > .main-embedWidgetGenerator-container {
      height: auto !important;
    } 
    .main-trackCreditsModal-originalCredits{
      padding-bottom: 20px !important;
    }
    .text-overflow {
        position: relative;
    }

    .playlist-player-wrapper {
        background-color: #1c1c1c;
        border-radius: 20px;
        position: relative;
        display: flex;
        flex-direction: column;
        margin-bottom: 15px;
        border: 4px solid #1c1c1c;
    }

    .playlist-wrapper {
        max-height: 30vh;
        background-color: #121212;
        overflow: auto;
        padding: 0 0px;
        scrollbar-width: thin;
        scrollbar-color: #232323 transparent;
        position: relative;
    }

    .playlist-wrapper::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }

    .playlist-wrapper::-webkit-scrollbar-thumb {
        background-color: #ffffff40;
        border-radius: 4px;
    }

    .playlist-wrapper::-webkit-scrollbar-track {
        background: transparent;
    }

    .tracklist-table {
        width: 100%;
        border-collapse: separate;
        color: #b3b3b3;
        font-size: 14px;
        table-layout: fixed;
    }

    .tracklist-table th {
        text-align: left;
        padding: 8px;
        border-bottom: 1px solid #282828;
        font-weight: 400;
        font-family: 'SpotifyMixUI' !important;
        color: #b3b3b3;
        position: sticky;
        top: 0;
        background: #121212;
        z-index: 2;
        height: 45px;
        vertical-align: middle;
        white-space: nowrap;
    }
    .tracklist-table th:hover {
        color: #ffffff;
    }

    .tracklist-table th.sorted {
        color: #1ED760;
    }
    .tracklist-table .index-col {
        width: 52px;
    }

    .tracklist-table th.index-col {
        text-align: center;
    }

    .tracklist-table .title-col {
        width: 340px;
        padding-right: 16px;
    }

    .tracklist-table .artist-col {
        width: 200px;
    }

    .tracklist-table th:nth-child(4) {
        width: 200px;
    }
    .tracklist-table th:nth-child(6) {
        width: 85px;
        text-align: center;
    }

    .tracklist-table th:nth-child(8) {
        width: 90px;
        text-align: center;
    }


    .tracklist-table th:nth-child(7) {
        width: 120px;
        text-align: center;
    }

    .tracklist-table th:nth-child(5) {
        width: 100px;
        text-align: center;
        white-space: normal;
    }

    .tracklist-table th:nth-child(n+9) {
        text-align: center;
    }

    .tracklist-table th:nth-child(9) {
        width: 70px;
    }

    .tracklist-table th:nth-child(10) {
        width: 110px;
    }

    .tracklist-table th:nth-child(11) {
        width: 80px;
    }

    .tracklist-table th:nth-child(12) {
        width: 80px;
    }

    .tracklist-table th:nth-child(13) {
        width: 80px;
    }

    .tracklist-table th:nth-child(14) {
        width: 100px;
    }

    .tracklist-table th:nth-child(15) {
        width: 110px;
    }

    .tracklist-table th:nth-child(16) {
        width: 140px;
    }

    .tracklist-table th:nth-child(17) {
        width: 90px;
    }

    .sticky-col {
        position: sticky;
        background: #121212;
        z-index: 1;
    }

    .index-col {
        left: 0;
        text-align: center;
    }

    .title-col {
        left: 52px;
    }

    .artist-col {
        left: 392px;
        width: 200px;
    }

    .tracklist-table td:nth-child(n+6) {
        text-align: center;
    }

    .tracklist-table td:nth-child(4) {
        width: 200px;
    }
    .tracklist-table td:nth-child(5) {
        width: 100px;
        text-align: center;
    }

    .tracklist-table .actions-col {
        width: 60px;
        right: 0;
        text-align: center;
        vertical-align: middle;
        box-shadow: 2px 0 2px #121212;
    }

    .actions-col {
        right: 0;
        padding: 0 !important;
    }

    .actions-col::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 1px;
        background: #282828;
        pointer-events: none;
    }

    .tracklist-table td:nth-child(n+6):not(:last-child) {
        text-align: center;
    }

    .tracklist-table tr.removed {
        background-color: #4a1515 !important;
    }

    .tracklist-table tr.removed:hover {
        background-color: #5a1919 !important;
    }

    .tracklist-table tr.removed .sticky-col {
        background-color: #4a1515 !important;
    }

    .tracklist-table tr.removed:hover .sticky-col {
        background-color: #5a1919 !important;
    }

    .tracklist-table tr.removed.active {
        background-color: #6a1d1d !important;
    }

    .tracklist-table tr.removed.active .sticky-col {
        background-color: #6a1d1d !important;
    }

    .custom-filter-modal .sort-type-select {
      padding: 7px;
      border-radius: 4px;
      border: 1px solid #434343;
      background: #282828;
      color: white;
      width: 170px;
      cursor: pointer;
      margin-right: 100px;
    }

    #customFilterCreatePlaylist {
        margin: 0;
        padding: 8px 32px;
        border-radius: 500px;
        border: none;
        background: #1db954;
        color: black;
        font-size: 14px;
        font-weight: 700;
        cursor: pointer;
        transition: background-color 0.2s ease;
    }

    #customFilterCreatePlaylist:hover {
        background: #1ed760;
    }

    .remove-button {
        background: none;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        width: 100%;
        height: 100%;
        padding: 0;
    }

    .remove-icon {
        width: 14px;
        height: 14px;
        fill: #b3b3b3;
        transition: fill 0.2s ease;
    }

    .remove-button:hover .remove-icon {
        fill: #ffffff;
    }
    .text-overflow {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: block;
        width: 100%;
    }

    th.sticky-col {
        z-index: 3;
    }

    .artist-col::after {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        height: 100%;
        width: 1px;
        background: #282828;
        pointer-events: none;
    }

    .tracklist-table tr {
        height: 35px;
    }

    .tracklist-table tr:hover {
        background-color: #282828;
    }
     .tracklist-table tr.active {
        background-color: #5A5A5A !important;
    }

    .tracklist-table tbody tr {
        height: 35px;
    }

    .tracklist-table tbody tr:hover {
        background-color: #282828;
    }
     .tracklist-table tr.active .sticky-col {
        background-color: #5A5A5A !important;
    }


    .tracklist-table tbody tr:hover .sticky-col {
        background-color: #282828;
    }

    .tracklist-table thead tr .sticky-col {
        background-color: #121212;
    }

    .tracklist-table td {
        padding: 8px;
        border: none;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        vertical-align: middle;
        height: 35px;
    }

    .main-image-container {
        width: 33px;
        height: 33px;
        min-width: 33px;
        min-height: 33px;
        border-radius: 4px;
        background-color: #282828;
        position: relative;
        aspect-ratio: 1 / 1;
        flex-shrink: 0;
    }

    .main-image-image2 {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transition: opacity 0.3s ease;
        object-fit: cover;
    }

    .song-info {
        display: flex;
        align-items: center;
        gap: 12px;
        height: 100%;
        min-width: 0;
        padding-right: 16px;
    }

    .song-info img {
        width: 33px;
        height: 33px;
        border-radius: 4px;
        object-fit: cover;
    }

    .song-title {
        color: #fff;
        font-weight: 400;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: block;
    }


    .main-embedWidgetGenerator-container {
        width: 1200px !important;
        max-width: 1500px !important;
        max-height: 90vh !important;
        border-radius: 30px;
        overflow: hidden;
        background-color: #121212 !important;
        border: 2px solid #282828;
    }

    .GenericModal__overlay .GenericModal {
        border-radius: 30px;
        overflow: hidden;
    }

    .main-trackCreditsModal-mainSection {
        overflow-y: hidden !important;
        padding: 16px 32px 9px 32px;
    }

    .main-trackCreditsModal-header {
        padding: 16px 32px 12px !important;
    }

    .custom-filter-modal .main-popupModal-content {
        overflow-y: auto;
    }
    .GenericModal {
        position: relative;
        z-index: 1000;
    }

    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.25);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        z-index: 999;
    }
    .playlist-title-container {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      padding: 14px 20px;
    }

    .playlist-stats-container {
        display: flex;
        gap: 12px;
        color: #b3b3b3;
        font-size: 14px;
        margin-left: auto;
    }
    .player-controls2 {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
        padding: 12px 20px;
    }

    .control-button2 {
        background-color: transparent;
        border: 0;
        color: #ffffff;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color 0.2s ease;
    }

    .progress-bar2-container {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        gap: 8px;
        color: #b3b3b3;
        font-size: 12px;
        width: 450px;
        max-width: 450px;
    }

    #currentTime, #duration {
        min-width: 45px;
        text-align: center;
        font-variant-numeric: tabular-nums;
    }
    #currentTime {
        text-align: right;
    }

    #duration {
        text-align: left;
    }
    .progress-bar2 {
        flex: 1;
        height: 4px;
        background-color: #4d4d4d;
        border-radius: 2px;
        cursor: pointer;
        position: relative;
        min-width: 0;
    }

    .progress-bar2-inner {
        position: absolute;
        height: 100%;
        background-color: #ffffff;
        border-radius: 2px;
        transition: width 0.1s linear;
    }

    .progress-bar2:hover .progress-bar2-inner {
        background-color: #1db954;
    }


    .track-info-container {
        display: flex;
        align-items: center;
        gap: 12px;
        max-width: 300px;
        min-width: 200px;
    }

    .track-info-text {
        display: flex;
        flex-direction: column;
        min-width: 0;
    }

    .track-title {
        color: #fff;
        font-size: 14px;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .track-artist {
        color: #b3b3b3;
        font-size: 12px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .track-album-art {
        width: 40px;
        height: 40px;
        border-radius: 4px;
        background-color: #282828;
        flex-shrink: 0;
    }


    .max-rows-container {
        display: flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
    }

    .max-rows-label {
        color: #b3b3b3;
        font-size: 12px;
    }

    .max-rows-select {
        padding: 3px 4px;
        border-radius: 4px;
        border: 1px solid #434343;
        background: #282828;
        color: white;
        cursor: pointer;
    }
    .filter-settings-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto auto;
        gap: 15px;
        margin-bottom: 15px;
    }

    .settings-left-wrapper,
    .settings-right-wrapper {
        background-color: #1c1c1c;
        border-radius: 20px;
        padding: 20px;
        position: relative;
    }

    .settings-left-wrapper {
      grid-column: 1;
      grid-row: 1 / span 2;
      display: flex;
      flex-direction: column;
      gap: 0px;
      position: relative;
    }
    .settings-right-wrapper {
        grid-column: 2;
        grid-row: 1;
        display: flex;
        flex-direction: column;
        gap: 0px;
        position: relative;
    }

    .buttons-wrapper {
        grid-column: 2;
        grid-row: 2;
        background-color: #1c1c1c;
        border-radius: 20px;
        padding: 15px 20px;
         display: flex;
        align-items: center;
        justify-content: space-between;
    }


    .settings-left-wrapper.disabled > *:not(.settings-title-wrapper) {
        opacity: 0.5;
        pointer-events: none;
    }

    .settings-left-wrapper.disabled .settings-title-wrapper {
        opacity: 1;
        pointer-events: all;
    }

    .settings-left-wrapper.disabled #keywordFilterToggle {
        pointer-events: all;
    }

    .settings-left-wrapper.disabled .settings-title {
        opacity: 1;
    }

    .settings-title {
        color: white;
        font-weight: bold;
        font-size: 15px;
        margin-bottom: 5px;
    }
    .settings-title-wrapper {
      display: flex;
      justify-content: space-between;
      width: 100%;
      margin-bottom: 8px;
    }

    #rangeFilterType {
        padding: 6px;
        border-radius: 4px;
        border: 1px solid #434343;
        background: #282828;
        color: white;
        width: 150px;
        cursor: pointer;
    }

    .range-filter-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .range-filter-title-wrapper {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        gap: 12px;
        margin-bottom: 15px;
    }

    .range-filter-label {
        color: #fff;
        font-size: 13px;
        font-weight: 500;
        white-space: nowrap;
    }

    .range-filter-title {
        color: #fff;
        font-size: 13px;
        font-weight: 500;
    }

    .range-input-container {
        display: flex;
        align-items: center;
        gap: 15px;
    }

    .range-input {
        width: 85px;
        padding: 4px;
        border-radius: 4px;
        border: 1px solid #434343;
        background: #282828;
        color: white;
        text-align: center;
    }
    .dual-range-sliderx-container {
        position: relative;
        width: 100%;
        height: 20px;
        flex: 1;
    }

    .dual-range-sliderx-container input[type="range"] {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        width: 100%;
        outline: none;
        position: absolute;
        margin: auto;
        top: 0;
        bottom: 0;
        background-color: transparent;
        pointer-events: none;
    }

    .sliderx-track {
        width: 100%;
        height: 5px;
        position: absolute;
        margin: auto;
        top: 0;
        bottom: 0;
        border-radius: 5px;
        background-color: #4d4d4d;
    }

    .dual-range-sliderx-container input[type="range"]::-webkit-sliderx-runnable-track {
        -webkit-appearance: none;
        height: 5px;
    }

    .dual-range-sliderx-container input[type="range"]::-moz-range-track {
        -moz-appearance: none;
        height: 5px;
    }

    .dual-range-sliderx-container input[type="range"]::-ms-track {
        appearance: none;
        height: 5px;
    }

    .dual-range-sliderx-container input[type="range"]::-webkit-sliderx-thumb {
        -webkit-appearance: none;
        height: 16px;
        width: 16px;
        background-color: #fff;
        cursor: pointer;
        margin-top: -6px;
        pointer-events: auto;
        border-radius: 50%;
        border: 1px solid #434343;
    }
    .dual-range-sliderx-container input[type="range"]::-webkit-sliderx-thumb:hover {
        border: 1px solid #b3b3b3;
    }

    .dual-range-sliderx-container input[type="range"]::-moz-range-thumb {
        -webkit-appearance: none;
        height: 16px;
        width: 16px;
        cursor: pointer;
        border-radius: 50%;
        background-color: #fff;
        pointer-events: auto;
        border: 1px solid #434343;
    }

    .dual-range-sliderx-container input[type="range"]::-ms-thumb {
        appearance: none;
        height: 16px;
        width: 16px;
        cursor: pointer;
        border-radius: 50%;
        background-color: #fff;
        pointer-events: auto;
          border: 1px solid #434343;
    }
    .range-filters-items {
        max-height: 170px;
        overflow-y: auto;
        padding-top: 9px;
        scrollbar-width: thin;
        scrollbar-color: #ffffff40 transparent;
        display: flex;
        flex-direction: column;
        gap: 5px;
    }
    .range-filters-items::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }

    .range-filters-items::-webkit-scrollbar-thumb {
        background-color: #ffffff40;
        border-radius: 4px;
    }

    .range-filters-items::-webkit-scrollbar-track {
        background: transparent;
    }

    .custom-filter-modal .switch {
      position: relative;
      display: inline-block;
      width: 36px;
      height: 20px;
    }

    .custom-filter-modal .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .custom-filter-modal .sliderx {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #484848;
      border-radius: 24px;
      transition: .2s;
    }

    .custom-filter-modal .sliderx:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      border-radius: 50%;
      transition: .2s;
    }

    .custom-filter-modal input:checked + .sliderx {
      background-color: #1DB954;
    }

    .custom-filter-modal input:checked + .sliderx:before {
      transform: translateX(16px);
    }
    .keyword-filter-container {
        display: flex;
        gap: 15px;
        width: 100%;
    }

    .filter-group {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .filter-group-header {
      display: flex;
      align-items: center;
      gap: 8px;
      height: 20px;
      justify-content: space-between;
    }

    .filter-group-title {
        color: #fff;
        font-size: 13px;
        font-weight: 500;
    }

    .toggle-group {
        display: flex;
        gap: 5px;
        align-items: center;
    }

    .filter-mode-toggle-label {
        color: #b3b3b3;
        font-size: 13px;
    }

    .keyword-input-container {
        position: relative;
        display: flex;
        flex-direction: column;
        background: #282828;
        border-radius: 6px;
        min-height: 0px;
        max-height: 96px;
        width: 100%;
    }
    .keyword-tags-container {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        padding: 6px;
        overflow-y: auto;
        min-height: 68px;
        max-height: 68px;
        max-width: 252px;
        scrollbar-width: thin;
        scrollbar-color: #ffffff40 transparent;
    }

    .keyword-input-wrapper {
        position: relative;
        padding: 3px;
        border-top: 1px solid #444;
        background: #313131;
        border-bottom-left-radius: 6px;
        border-bottom-right-radius: 6px;
        display: flex;
        align-items: center;
    }
    .keyword-input {
        background: none;
        border: none;
        color: white;
        padding: 4px;
        width: 100%;
        height: 24px;
        margin: 0;
        flex: 1;
        min-width: 0;
    }

    .keyword-actions-container {
        display: flex;
        margin-left: auto;
        flex-shrink: 0;
    }

    .keyword-action-button {
        background-color: transparent;
        border: none;
        color: white;
        padding: 2px 7px;
        border-radius: 12px;
        font-size: 12px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        height: 24px;
        white-space: nowrap;
    }

    .keyword-action-button:hover {
        background-color: #484848;
    }

    .keyword-action-button svg {
        width: 14px;
        height: 14px;
        fill: #fff;
        display: block;
        margin: 0 auto;
    }
    .keyword-tag {
        display: inline-flex;
        align-items: center;
        background: #383838;
        border-radius: 12px;
        padding: 2px 8px;
        color: white;
        font-size: 12px;
        white-space: nowrap;
        flex-shrink: 0;
        height: 24px;
    }

    .keyword-tag-remove {
        margin-left: 4px;
        cursor: pointer;
        color: #ccc;
        font-size: 14px;
    }

    .keyword-input:focus {
        outline: none;
    }
      .filter-mode-radio-group {
        display: flex;
        align-items: center;
        gap: 16px;
        margin: 10px 0;
    }

    .radio-button-container {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
    }

    .radio-button {
        width: 16px;
        height: 16px;
        border: 2px solid #b3b3b3;
        border-radius: 50%;
        display: flex;
        padding: 2px;
    }

    .radio-button input {
        display: none;
    }

    .radio-button-inner {
        width: 8px;
        height: 8px;
        background-color: #1DB954;
        border-radius: 50%;
        display: none;
    }

    .radio-button input:checked + .radio-button-inner {
        display: block;
    }

    .radio-label {
        color: #b3b3b3;
        font-size: 13px;
    }

    .radio-button-container:hover .radio-button {
        border-color: #ffffff;
    }

    .radio-button-container:hover .radio-label {
        color: #ffffff;
    }
    .load-more-row {
        cursor: pointer;
        background-color: #3e3e3e;
        text-align: center;
        position: sticky;
        left: 0;
        z-index: 1;
    }
    .load-more-cell {
        padding: 10px;
        font-size: 12px;
        text-align: center;
        transition: background-color 0.2s;
    }
    .load-more-row:hover .load-more-cell {
        background-color: #4c4c4c;
    }
     .buttons-container {
        display: flex;
        justify-content: flex-start;
        padding: 16px 32px;
    }
    </style>
    <div class="playlist-player-wrapper">
        <div class="playlist-title-container">
          <span class="playlist-title" style="color: #fff; font-size: 15px; font-weight: bold;">Playlist Name</span>
          <div class="playlist-stats-container">
          </div>
      </div>
      <div class="playlist-wrapper">
          <table class="tracklist-table">
              <thead>
                  <tr>
                      ${tableHeaders}
                  </tr>
              </thead>
              <tbody>
                  ${generateTableRows(displayedTracks)}
              </tbody>
          </table>
      </div>
        <div class="player-controls2">
          <div class="track-info-container">
              <div class="track-album-art">
              </div>
              <div class="track-info-text">
                  <span class="track-title">Track Title</span>
                  <span class="track-artist">Artist Name</span>
              </div>
          </div>
          <div class="progress-bar2-container">
              <button class="control-button2" id="playPauseButton">
                  <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor">
                      <path d="M3 1.713a.7.7 0 0 1 1.05-.607l10.89 6.288a.7.7 0 0 1 0 1.212L4.05 14.894A.7.7 0 0 1 3 14.288V1.713z"/>
                  </svg>
              </button>
              <span id="currentTime">0:00</span>
              <div class="progress-bar2" id="progressBar">
                  <div class="progress-bar2-inner" id="progressBarInner"></div>
              </div>
              <span id="duration">0:00</span>
          </div>
          <div class="max-rows-container">
              <span class="max-rows-label">Max Rows:</span>
              <select class="max-rows-select">
                  <option value="50">50</option>
                  <option value="100">100</option>
                  <option value="200">200</option>
                  <option value="300">300</option>
                  <option value="500">500</option>
                  <option value="700">800</option>
                  <option value="1000">1000</option>
                  <option value="all">All</option>
              </select>
          </div>
      </div>
    </div>
    <div class="filter-settings-container">
      <div class="settings-left-wrapper">
          <div class="settings-title-wrapper">
              <div class="settings-title">Keyword Filters</div>
              <label class="switch">
                  <input type="checkbox" id="keywordFilterToggle">
                  <span class="sliderx"></span>
              </label>
          </div>
          <div class="filter-mode-container" style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 10px;">
            <div class="filter-mode-radio-group" style="display: flex; align-items: center; gap: 16px;">
              <div class="filter-mode-title" style="color: #fff; font-size: 13px; font-weight: 500; margin-right: 8px;">Filter Mode:</div>
              <label class="radio-button-container">
                <span class="radio-button">
                  <input type="radio" name="filterMode" value="exclude">
                  <span class="radio-button-inner"></span>
                </span>
                <span class="radio-label">Exclude</span>
              </label>
              <label class="radio-button-container">
                <span class="radio-button">
                  <input type="radio" name="filterMode" value="keep">
                  <span class="radio-button-inner"></span>
                </span>
                <span class="radio-label">Keep</span>
              </label>
              <span class="filter-mode-title" style="color: #fff; font-size: 13px; font-weight: 500; margin-left: 14px;">Match Whole Word:</span>
            </div>

            <label class="switch">
              <input type="checkbox" id="matchWholeWordToggle">
              <span class="sliderx"></span>
            </label>
          </div>
          <div class="keyword-filter-container">
              <div class="filter-group">
                  <div class="filter-group-header">
                      <span class="filter-group-title">Titles/Albums</span>
                      <div class="toggle-group">
                          <span class="filter-mode-toggle-label">Title</span>
                          <label class="switch">
                              <input type="checkbox" id="titleToggle" checked>
                              <span class="sliderx"></span>
                          </label>
                          <span class="filter-mode-toggle-label">Album</span>
                          <label class="switch">
                          <input type="checkbox" id="albumToggle" checked>
                          <span class="sliderx"></span>
                      </label>
                      </div>
                  </div>
                  <div class="keyword-input-container" id="titleAlbumKeywords">
                      <div class="keyword-tags-container">
                      </div>
                      <div class="keyword-input-wrapper">
                        <input type="text" class="keyword-input" placeholder="Add keywords...">
                          <div class="keyword-actions-container">
                              <button class="keyword-action-button keyword-save-button" title="Save Keywords">${saveIconSVG}</button>
                              <button class="keyword-action-button keyword-load-button" title="Load Keywords">${loadIconSVG}</button>
                              <button class="keyword-action-button keyword-remove-all-button" title="Clear Keywords">${clearIconSVG}</button>
                          </div>
                      </div>
                  </div>
              </div>

              <div class="filter-group">
                <div class="filter-group-header">
                  <span class="filter-group-title">Artists</span>
                    <div class="toggle-group">
                      <label class="switch">
                        <input type="checkbox" id="artistToggle" checked>
                        <span class="sliderx"></span>
                      </label>
                    </div>
                  </div>
                  <div class="keyword-input-container" id="artistKeywords">
                      <div class="keyword-tags-container">
                      </div>
                      <div class="keyword-input-wrapper">
                          <input type="text" class="keyword-input" placeholder="Add keywords...">
                      </div>
                  </div>
              </div>
            </div>
      </div>
      <div class="settings-right-wrapper">
            <div class="settings-title-wrapper">
                <div class="settings-title">Range Filters</div>
                  <label class="switch">
                    <input type="checkbox" id="rangeFilterToggle" checked>
                  <span class="sliderx"></span>
              </label>
            </div>
            <div class="range-filters-items">
                <div class="range-filter-container">
                  <div class="range-filter-title-wrapper">
                      <span class="range-filter-label">Filter by:</span>
                          <div class="range-filter-title">
                              <select id="rangeFilterType">
                                <option value="releaseDate" ${activeRangeFilter === 'releaseDate' ? 'selected' : ''}>Release Date</option>
                                <option value="durationMs" ${activeRangeFilter === 'durationMs' ? 'selected' : ''}>Duration</option>
                                <option value="playCount" ${activeRangeFilter === 'playCount' ? 'selected' : ''}>Plays</option>
                                <option value="popularity" ${activeRangeFilter === 'popularity' ? 'selected' : ''}>Popularity</option>
                                <option value="features.energy" ${activeRangeFilter === 'features.energy' ? 'selected' : ''}>Energy</option>
                                <option value="features.danceability" ${activeRangeFilter === 'features.danceability' ? 'selected' : ''}>Danceability</option>
                                <option value="features.valence" ${activeRangeFilter === 'features.valence' ? 'selected' : ''}>Valence</option>
                                <option value="features.tempo" ${activeRangeFilter === 'features.tempo' ? 'selected' : ''}>Tempo</option>
                              </select>
                          </div>
                    </div>
                    <div class="range-input-container">
                        <input type="text" class="range-input" id="rangeMin" placeholder="Min">
                        <div class="dual-range-sliderx-container" id="rangesliderx">
                            <div class="sliderx-track"></div>
                            <input type="range"  id="rangesliderx-1">
                            <input type="range"  id="rangesliderx-2">
                        </div>
                        <input type="text" class="range-input" id="rangeMax" placeholder="Max">
                    </div>
                </div>
            </div>
      </div>
      <div class="buttons-wrapper">
          <label for="sort-type-select" style="color: #fff; font-size: 13px; margin-right: 8px;">Sort Type:</label>
            <select class="sort-type-select" id="sort-type-select">
                <option value="default">Original Order</option>
                <option value="current">Current Order</option>
                <option value="playCount">Play Count</option>
                <option value="popularity">Popularity</option>
                <option value="releaseDate">Release Date</option>
                <option value="shuffle">Shuffle</option>
            </select>
            <button id="customFilterCreatePlaylist">Create Playlist</button>
      </div>
  </div>
    `;

    Spicetify.PopupModal.display({
        title: "<span style='font-size: 24px; font-weight: 700;'>Custom Filter</span>",
        content: modalContainer,
        isLarge: true,
    });
    tagActiveModalWithFontScope();
    
    const playlistTitleElement = modalContainer.querySelector(".playlist-title");
    updatePlaylistStats();
    
    (async () => {
        try {
            const id = currentUri.split(":")[2];
            if (URI.isPlaylistV1OrV2(currentUri)) {
                const getName = async () => {
                    if (isFallbackActive()) {
                        const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(currentUri);
                        return meta.name;
                    } else {
                        try {
                            const r = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${id}`);
                            return r.name;
                        } catch (e) {
                            if (registerWebApiFailure()) {
                                const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(currentUri);
                                return meta.name;
                            }
                            throw e;
                        }
                    }
                };
                const name = await getName();
                playlistTitleElement.textContent = name;
                playlistTitleElement.title = name;

            } else if (URI.isArtist(currentUri)) {
                const getName = async () => {
                    const fetchFallback = async () => {
                        const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, { uri: currentUri, locale: "en", includePrerelease: false });
                        return res.data.artistUnion.profile.name;
                    };
                    if (isFallbackActive()) return await fetchFallback();
                    try {
                        const r = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists/${id}`);
                        return r.name;
                    } catch (e) {
                        if (registerWebApiFailure()) return await fetchFallback();
                        throw e;
                    }
                };
                const name = await getName();
                playlistTitleElement.textContent = `All tracks by ${name}`;
                playlistTitleElement.title = `All tracks by ${name}`;

            } else if (isLikedSongsPage(currentUri)) {
                playlistTitleElement.textContent = "Liked Songs";
                playlistTitleElement.title = "Liked Songs";

            } else if (URI.isAlbum(currentUri)) {
                const getName = async () => {
                    const fetchFallback = async () => {
                        const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: currentUri, locale: "en", offset: 0, limit: 1 });
                        return res.data.albumUnion.name;
                    };
                    if (isFallbackActive()) return await fetchFallback();
                    try {
                        const r = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${id}`);
                        return r.name;
                    } catch (e) {
                        if (registerWebApiFailure()) return await fetchFallback();
                        throw e;
                    }
                };
                const name = await getName();
                playlistTitleElement.textContent = name;
                playlistTitleElement.title = name;
            }
        } catch (e) {
            console.warn("Failed to set modal title", e);
        }
    })();

    const overlay = document.createElement("div");
    overlay.className = "modal-overlay";
    const genericModalOverlay = document.querySelector(".GenericModal__overlay");

    if (genericModalOverlay) {
        genericModalOverlay.appendChild(overlay);
    }

    if (overlay) {
        overlay.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
        });
    }

    const modalContainerElement = document.querySelector(".main-popupModal-container");
    if (modalContainerElement) {
        modalContainerElement.style.zIndex = "2000";
    }

    tableBody = modalContainer.querySelector(".tracklist-table tbody");
    let activeRow = null;
    setupTableEventListeners(tableBody, originalTracks);

    settingsLeftWrapper = modalContainer.querySelector('.settings-left-wrapper');
    keywordFilterToggle = modalContainer.querySelector("#keywordFilterToggle");
    rangeFilterToggle = modalContainer.querySelector("#rangeFilterToggle");
    rangeFilterTypeSelect = modalContainer.querySelector("#rangeFilterType");
    filterModeRadios = modalContainer.querySelectorAll('input[name="filterMode"]');
    titleToggle = modalContainer.querySelector("#titleToggle");
    albumToggle = modalContainer.querySelector("#albumToggle");
    const titleAlbumContainer = modalContainer.querySelector("#titleAlbumKeywords");
    const artistContainer = modalContainer.querySelector("#artistKeywords");
    matchWholeWordToggle = modalContainer.querySelector("#matchWholeWordToggle");
    artistToggle = modalContainer.querySelector("#artistToggle");
    maxRowsSelect = modalContainer.querySelector(".max-rows-select");

    keepMatchingMode = false;
    titleToggle.checked = localStorage.getItem("sort-play-filter-title") !== "false";
    albumToggle.checked = localStorage.getItem("sort-play-filter-album") !== "false";
    artistToggle.checked = localStorage.getItem("sort-play-filter-artist") !== "false";
    matchWholeWord = localStorage.getItem("sort-play-match-whole-word") === "true";
    const savedPageSize = localStorage.getItem("sort-play-page-size");
    maxRowsSelect.value = savedPageSize || "100";
    matchWholeWordToggle.checked = matchWholeWord;


    pageSize = maxRowsSelect.value === "all" ? tracks.length : parseInt(maxRowsSelect.value);


    maxRowsSelect.addEventListener("change", () => {
        const selectedValue = maxRowsSelect.value;

        if (selectedValue === "all") {
            pageSize = tracks.length;
        } else {
            pageSize = parseInt(selectedValue);
        }

        localStorage.setItem("sort-play-page-size", selectedValue);

        startIndex = 0;
        isFirstLoad = true;
        isLastLoad = tracks.length <= pageSize + paginationThreshold;
        displayedTracks = tracks.slice(startIndex, isLastLoad ? tracks.length : pageSize);
        updateTable(displayedTracks);

        const playlistWrapper = modalContainer.querySelector(".playlist-wrapper");
        if (playlistWrapper) {
            playlistWrapper.scrollTop = 0;
        }
    });

    startIndex = 0;
    isFirstLoad = true;
    isLastLoad = tracks.length <= pageSize + paginationThreshold;

    displayedTracks = tracks.slice(startIndex, isLastLoad ? tracks.length : pageSize);
    updateTable(displayedTracks);
    const loadedKeywords = loadKeywords();
    titleAlbumKeywords = loadedKeywords.titleAlbumKeywords;
    artistKeywords = loadedKeywords.artistKeywords;
    
    titleAlbumKeywords.forEach(keyword => createKeywordTag(keyword, titleAlbumContainer, titleAlbumKeywords, updateTrackFilters));
    artistKeywords.forEach(keyword => createKeywordTag(keyword, artistContainer, artistKeywords, updateTrackFilters));

    setupKeywordInput(titleAlbumContainer, titleAlbumKeywords, updateTrackFilters);
    setupKeywordInput(artistContainer, artistKeywords, updateTrackFilters);

    tableBody.addEventListener("click", (event) => {
        const row = event.target.closest("tr");
        if (!row) return;

        if (event.target.closest(".actions-col")) {
            return;
        }

        if (activeRow) {
            activeRow.classList.remove("active");
        }

        row.classList.add("active");
        activeRow = row;
    });

    function updateTrackInfo(track) {
        const trackTitleElement = modalContainer.querySelector(".track-title");
        const trackArtistElement = modalContainer.querySelector(".track-artist");
        const trackAlbumArtElement = modalContainer.querySelector(".track-album-art");

        trackTitleElement.textContent = track.songTitle || track.name;
        trackTitleElement.title = track.songTitle || track.name;
        trackArtistElement.textContent = track.allArtists;
        trackArtistElement.title = track.allArtists;

        trackAlbumArtElement.innerHTML = '';

        const newAlbumArt = document.createElement("img");
        newAlbumArt.src = "/api/placeholder/40/40";
        newAlbumArt.alt = "";
        newAlbumArt.className = "player-album-art";
        newAlbumArt.width = 40;
        newAlbumArt.height = 40;
        newAlbumArt.style.borderRadius = "4px";
        newAlbumArt.dataset.trackUri = track.uri;

        trackAlbumArtElement.appendChild(newAlbumArt);
        trackAlbumArtElement.title = `${track.songTitle || track.name} - ${track.allArtists}`;
        loadAlbumArt(track, newAlbumArt);
    }

    tableBody.addEventListener("dblclick", async (event) => {
        const row = event.target.closest("tr");
        if (!row) return;

        const trackUri = row.dataset.trackUri;
        if (trackUri) {

            if (activeRow && activeRow !== row) {
                activeRow.classList.remove("active");
            }

            row.classList.add("active");
            activeRow = row;
            await Spicetify.Player.playUri(trackUri);

            const track = originalTracks.find(t => t.uri === trackUri);
            if (track) {
                updateTrackInfo(track);
            }
        }
    });

    tableBody.addEventListener("click", (event) => {
        if (event.target.tagName === "svg" || event.target.tagName === "path") {
            event.stopPropagation();
        }

        const removeButton = event.target.closest(".remove-button");
        if (!removeButton) return;

        const row = removeButton.closest("tr");
        const trackUri = row.dataset.trackUri;
        const track = originalTracks.find(t => t.uri === trackUri);

        if (track) {
            track.isRemoved = !track.isRemoved;
            row.classList.toggle("removed");
            const svgIcon = removeButton.querySelector("svg");
            svgIcon.outerHTML = track.isRemoved ? restoreIconSVG : removeIconSVG;
            updatePlaylistStats();
        }
    });

    let isRemoveDragging = false;
    let lastRemovedState = null;

    tableBody.addEventListener("mousedown", (event) => {
        const removeButton = event.target.closest(".remove-button");
        if (!removeButton) return;

        isRemoveDragging = true;
        const row = removeButton.closest("tr");
        const trackUri = row.dataset.trackUri;
        const track = originalTracks.find(t => t.uri === trackUri);

        if (track) {
            track.isRemoved = !track.isRemoved;
            lastRemovedState = track.isRemoved;
            row.classList.toggle("removed");

            const svgIcon = removeButton.querySelector("svg");
            svgIcon.outerHTML = track.isRemoved ? restoreIconSVG : removeIconSVG;
        }

        event.preventDefault();
    });

    tableBody.addEventListener("mouseover", (event) => {
        if (!isRemoveDragging) return;

        const removeButton = event.target.closest(".remove-button");
        if (!removeButton) return;

        const row = removeButton.closest("tr");
        const trackUri = row.dataset.trackUri;
        const track = originalTracks.find(t => t.uri === trackUri);

        if (track && track.isRemoved !== lastRemovedState) {
            track.isRemoved = lastRemovedState;
            row.classList.toggle("removed", lastRemovedState);

            const svgIcon = removeButton.querySelector("svg");
            svgIcon.outerHTML = lastRemovedState ? restoreIconSVG : removeIconSVG;
        }
    });

    document.addEventListener("mouseup", () => {
        isRemoveDragging = false;
        lastRemovedState = null;
    });

    tableBody.addEventListener("click", (event) => {
        if (event.target.tagName === "svg" || event.target.tagName === "path") {
            event.stopPropagation();
        }

        const removeButton = event.target.closest(".remove-button");
        if (!removeButton) return;

        const row = removeButton.closest("tr");
        const trackUri = row.dataset.trackUri;
        const track = originalTracks.find(t => t.uri === trackUri);

        if (track) {
            track.isRemoved = !track.isRemoved;
            row.classList.toggle("removed");

            const svgIcon = removeButton.querySelector("svg");
            svgIcon.outerHTML = track.isRemoved ? restoreIconSVG : removeIconSVG;
            updatePlaylistStats();
        }
    });

    let currentSort = { key: null, direction: 'none' };
    function updateHeaderText(header, direction) {
        const sortKey = header.dataset.sortKey;
        const baseText = header.textContent.split(' ')[0];

        if (direction === 'none') {
            header.textContent = baseText;
            header.classList.remove('sorted');
        } else {
            const arrow = direction === 'ascending' ? ' â–²' : ' â–¼';
            header.textContent = baseText + arrow;
            header.classList.toggle("sorted", direction !== 'none');
            header.classList.add('sorted');
        }
    }


    updateTable(displayedTracks);


    modalContainer.querySelectorAll(".tracklist-table th[data-sort-key]").forEach(header => {
        header.addEventListener('click', () => {
            const sortKey = header.dataset.sortKey;

            modalContainer.querySelectorAll(".tracklist-table th[data-sort-key]").forEach(h => {
                if (h !== header) {
                    updateHeaderText(h, 'none');
                }
            });

            if (currentSort.key === sortKey) {
                currentSort.direction = currentSort.direction === 'ascending' ? 'descending' :
                    (currentSort.direction === 'descending' ? 'none' : 'ascending');
            } else {
                currentSort.key = sortKey;
                currentSort.direction = 'ascending';
            }

            updateHeaderText(header, currentSort.direction);

            let sortedTracks;
            if (currentSort.direction === 'none') {
                sortedTracks = [...originalTracks];
            } else {
                sortedTracks = sortTracks(tracks, currentSort.key, currentSort.direction);
            }
            tracks = sortedTracks;
            startIndex = 0;
            isFirstLoad = true;
            isLastLoad = tracks.length <= pageSize + paginationThreshold;
            displayedTracks = tracks.slice(startIndex, isLastLoad ? tracks.length : pageSize);
            updateTable(displayedTracks);
        });
    });


    const playPauseButton = modalContainer.querySelector('#playPauseButton');
    const progressBar = modalContainer.querySelector('#progressBar');
    const progressBarInner = modalContainer.querySelector('#progressBarInner');
    const currentTimeElement = modalContainer.querySelector('#currentTime');
    const durationElement = modalContainer.querySelector('#duration');

    let isDragging = false;

    function updatePlayButton(isPlaying) {
        playPauseButton.innerHTML = isPlaying
            ? '<svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor"><path d="M2.7 1a.7.7 0 0 0-.7.7v12.6a.7.7 0 0 0 .7.7h2.6a.7.7 0 0 0 .7-.7V1.7a.7.7 0 0 0-.7-.7H2.7zm8 0a.7.7 0 0 0-.7.7v12.6a.7.7 0 0 0 .7.7h2.6a.7.7 0 0 0 .7-.7V1.7a.7.7 0 0 0-.7-.7h-2.6z"/></svg>'
            : '<svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor"><path d="M3 1.713a.7.7 0 0 1 1.05-.607l10.89 6.288a.7.7 0 0 1 0 1.212L4.05 14.894A.7.7 0 0 1 3 14.288V1.713z"/></svg>';
    }

    updatePlayButton(Spicetify.Player.isPlaying());

    playPauseButton.addEventListener('click', () => {
        Spicetify.Player.togglePlay();
    });

    progressBar.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        isDragging = true;
        const rect = progressBar.getBoundingClientRect();
        const pos = (e.clientX - rect.left) / rect.width;
        const duration = Spicetify.Player.getDuration();
        Spicetify.Player.seek(pos * duration);
    });


    progressBar.addEventListener('mousemove', (e) => {
        e.stopPropagation();
        if (!isDragging) return;
        const rect = progressBar.getBoundingClientRect();
        const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        progressBarInner.style.width = `${pos * 100}%`;
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
    });

    function updateProgress() {
        if (!isDragging) {
            const progress = Spicetify.Player.getProgress();
            const duration = Spicetify.Player.getDuration();
            const progressPercent = (progress / duration) * 100;
            progressBarInner.style.width = `${progressPercent}%`;
            currentTimeElement.textContent = Spicetify.Player.formatTime(progress);
            durationElement.textContent = Spicetify.Player.formatTime(duration);
        }
    }

    const playerStateHandler = (event) => {
        if (event?.data) {
            updatePlayButton(!event.data.isPaused);
        }
    };

    Spicetify.Player.addEventListener('onplaypause', playerStateHandler);

    const progressInterval = setInterval(updateProgress, 100);

    const cleanup = () => {
        if (observer) {
            observer.disconnect();
        }
        clearInterval(progressInterval);
        Spicetify.Player.removeEventListener('onplaypause', playerStateHandler);
        if (closeButton) {
            closeButton.removeEventListener("click", cleanup);
        }


        document.removeEventListener("mousemove", handleTrackMove);
        activeRow = null;

        Spicetify.PopupModal.hide();

    };
    const closeButton = document.querySelector('.main-trackCreditsModal-closeBtn');
    if (closeButton) {
        closeButton.addEventListener("click", cleanup);
    }


    const modalContainerElementForMutation = document.querySelector('.main-popupModal-container');
    if (modalContainerElementForMutation) {
        const mutationObserver = new MutationObserver((mutations) => {
            const closeButton = modalContainerElementForMutation.querySelector('.main-trackCreditsModal-closeBtn');
            if (closeButton && !closeButton.hasAttribute('data-cleanup-attached')) {
                closeButton.setAttribute('data-cleanup-attached', 'true');
                closeButton.addEventListener("click", cleanup);
            }
        });

        mutationObserver.observe(modalContainerElementForMutation, {
            childList: true,
            subtree: true
        });
    }
    setupDualRangesliderx("rangesliderx", "rangeMin", "rangeMax");
    updateRangeUI(activeRangeFilter);

    rangeFilterTypeSelect.addEventListener("change", (e) => {
        activeRangeFilter = e.target.value;
        localStorage.setItem("sort-play-active-range-filter", activeRangeFilter);
        updateRangeUI(activeRangeFilter);
        debouncedUpdateTrackFilters();
    });

    rangeFilterToggle.addEventListener("change", () => {
        updateTrackFilters();
    });

    matchWholeWordToggle.addEventListener("change", (e) => {
        matchWholeWord = e.target.checked;
        updateTrackFilters();
    });


    settingsLeftWrapper.classList.toggle('disabled', !keywordFilterToggle.checked);

    keywordFilterToggle.addEventListener("change", (e) => {
        settingsLeftWrapper.classList.toggle('disabled', !e.target.checked);

        if (!e.target.checked) {
            tracks.forEach(track => {
                track.isRemovedByKeyword = false;
            });
        }
        updateTrackFilters();
    });

    filterModeRadios.forEach(radio => {
        if ((keepMatchingMode && radio.value === "keep") || (!keepMatchingMode && radio.value === "exclude")) {
            radio.checked = true;
        }
    });

    filterModeRadios.forEach(radio => {
        radio.addEventListener("change", (e) => {
            keepMatchingMode = e.target.value === "keep";
            updateTrackFilters();
        });
    });

    matchWholeWordToggle.addEventListener("change", (e) => {
        matchWholeWord = e.target.checked;
        updateTrackFilters();
    });


    titleToggle.addEventListener("change", updateTrackFilters);
    albumToggle.addEventListener("change", updateTrackFilters);
    artistToggle.addEventListener("change", updateTrackFilters);

    const createPlaylistButton = modalContainer.querySelector("#customFilterCreatePlaylist");
    const sortTypeSelect = modalContainer.querySelector(".sort-type-select");
    let selectedSortType = "default";

    sortTypeSelect.addEventListener("change", () => {
        selectedSortType = sortTypeSelect.value;
    });

    function setupTableEventListeners(tableBody, originalTracks) {
      if (!tableBody) return;

      let isRemoveDragging = false;
      let lastRemovedState = null;
      let activeRow = null;

      tableBody.addEventListener("mousedown", (event) => {
          const removeButton = event.target.closest(".remove-button");
          if (!removeButton) return;

          isRemoveDragging = true;
          const row = removeButton.closest("tr");
          const trackUri = row.dataset.trackUri;
          const track = originalTracks.find(t => t.uri === trackUri);

          if (track) {
              track.isRemoved = !track.isRemoved;
              lastRemovedState = track.isRemoved;
              row.classList.toggle("removed");

              const svgIcon = removeButton.querySelector("svg");
              svgIcon.outerHTML = track.isRemoved ? restoreIconSVG : removeIconSVG;
              updatePlaylistStats(); 
          }

          event.preventDefault();
      });

      tableBody.addEventListener("mouseover", (event) => {
          if (!isRemoveDragging) return;

          const removeButton = event.target.closest(".remove-button");
          if (!removeButton) return;

          const row = removeButton.closest("tr");
          const trackUri = row.dataset.trackUri;
          const track = originalTracks.find(t => t.uri === trackUri);

          if (track && track.isRemoved !== lastRemovedState) {
              track.isRemoved = lastRemovedState;
              row.classList.toggle("removed", lastRemovedState);

              const svgIcon = removeButton.querySelector("svg");
              svgIcon.outerHTML = lastRemovedState ? restoreIconSVG : removeIconSVG;
              updatePlaylistStats(); 
          }
      });

      document.addEventListener("mouseup", () => {
          isRemoveDragging = false;
          lastRemovedState = null;
          updatePlaylistStats();
      });

      tableBody.addEventListener("click", async (event) => {
        const row = event.target.closest("tr");
        if (!row) return;

        const removeButton = event.target.closest(".remove-button");
        if (removeButton) {
            const trackUri = row.dataset.trackUri;
            const track = originalTracks.find(t => t.uri === trackUri);

            if (track) {
                track.isRemoved = !track.isRemoved;
                row.classList.toggle("removed", track.isRemoved);
                const svgIcon = removeButton.querySelector("svg");
                svgIcon.outerHTML = track.isRemoved ? restoreIconSVG : removeIconSVG;
            }
            return; 
        }

        if (!event.target.closest(".actions-col")) {
          if (activeRow) {
            activeRow.classList.remove("active");
          }
          row.classList.add("active");
          activeRow = row;
        }
      });

      tableBody.addEventListener("dblclick", async (event) => {
        const row = event.target.closest("tr");
        if (!row) return;

        const trackUri = row.dataset.trackUri;
        if (trackUri) {
          if (activeRow && activeRow !== row) {
            activeRow.classList.remove("active");
          }
          row.classList.add("active");
          activeRow = row;
          await Spicetify.Player.playUri(trackUri);

          const track = originalTracks.find(t => t.uri === trackUri);
          if (track) {
            updateTrackInfo(track);
          }
        }
      });
    }
      
    createPlaylistButton.addEventListener("click", async () => {
        const filteredTracks = tracks.filter(track => !track.isRemoved);

        if (filteredTracks.length === 0) {
            showNotification("No tracks selected to create a playlist.");
            return;
        }

        Spicetify.PopupModal.hide();
        setButtonProcessing(true);
        mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
        mainButton.style.color = buttonStyles.main.disabledColor;
        mainButton.style.cursor = "default";
        svgElement.style.fill = buttonStyles.main.disabledColor;
        menuButtons.forEach((button) => (button.disabled = true));
        mainButton.innerHTML = "0%";

        try {
            let sortedTracksForPlaylist;
            selectedSortType = sortTypeSelect.value;

            if (selectedSortType === "default") {
                sortedTracksForPlaylist = [...originalTracks].filter(track => !track.isRemoved);

            } else if (selectedSortType === "current") {
                sortedTracksForPlaylist = [...tracks].filter(track => !track.isRemoved);
            } else if (selectedSortType === "shuffle") {
                sortedTracksForPlaylist = shuffleArray(filteredTracks);
            }
            else {
                sortedTracksForPlaylist = sortTracks(filteredTracks, selectedSortType, sortOrderState[selectedSortType] ? "ascending" : "descending");
            }
            mainButton.innerText = "100%";

            const sourceUri = currentUri;
            const sourceId = sourceUri.split(":")[2];
            let sourceName = "Source";

            try {
                if (URI.isArtist(sourceUri)) {
                    const fetchArtistFallback = async () => {
                        const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, { uri: sourceUri, locale: "en", includePrerelease: false });
                        return res.data.artistUnion.profile.name;
                    };

                    if (isFallbackActive()) {
                        sourceName = await fetchArtistFallback();
                    } else {
                        try {
                            const artistData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists/${sourceId}`);
                            sourceName = artistData.name;
                        } catch (e) {
                            if (registerWebApiFailure()) {
                                sourceName = await fetchArtistFallback();
                            } else { throw e; }
                        }
                    }
                } else if (isLikedSongsPage(sourceUri)) {
                    sourceName = "Liked Songs";
                } else if (URI.isAlbum(sourceUri)) {
                    const fetchAlbumFallback = async () => {
                        const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: sourceUri, locale: "en", offset: 0, limit: 1 });
                        return res.data.albumUnion.name;
                    };

                    if (isFallbackActive()) {
                        sourceName = await fetchAlbumFallback();
                    } else {
                        try {
                            const albumData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${sourceId}`);
                            sourceName = albumData.name;
                        } catch (e) {
                            if (registerWebApiFailure()) {
                                sourceName = await fetchAlbumFallback();
                            } else { throw e; }
                        }
                    }
                } else {
                    const fetchPlaylistFallback = async () => {
                        const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(sourceUri);
                        return meta.name;
                    };

                    if (isFallbackActive()) {
                        sourceName = await fetchPlaylistFallback();
                    } else {
                        try {
                            const playlistData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${sourceId}`);
                            sourceName = playlistData.name;
                        } catch (e) {
                            if (registerWebApiFailure()) {
                                sourceName = await fetchPlaylistFallback();
                            } else { throw e; }
                        }
                    }
                }
            } catch (e) {
                console.warn("Failed to fetch source name for Custom Filter playlist", e);
            }

            let suffixPattern = new RegExp(
                `\\s*(${possibleSuffixes.join("|")})\\s*`
            );

            while (suffixPattern.test(sourceName)) {
                sourceName = sourceName.replace(suffixPattern, "");
            }


            let baseDescription = `Filtered using Sort-Play`;
            if (URI.isArtist(sourceUri)) {
                baseDescription = `Tracks by ${sourceName} Filtered using Sort-Play`;
            } else if (URI.isAlbum(sourceUri)) {
                let artistName = "Unknown Artist";
                try {
                    const fetchAlbumArtistFallback = async () => {
                        const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: sourceUri, locale: "en", offset: 0, limit: 1 });
                        return res.data.albumUnion.artists.items[0]?.profile?.name || "Unknown Artist";
                    };

                    if (isFallbackActive()) {
                        artistName = await fetchAlbumArtistFallback();
                    } else {
                        try {
                            const albumDetails = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${sourceId}`);
                            artistName = albumDetails.artists[0].name;
                        } catch (e) {
                            if (registerWebApiFailure()) {
                                artistName = await fetchAlbumArtistFallback();
                            } else { throw e; }
                        }
                    }
                } catch (e) {}
                baseDescription = `Tracks from ${sourceName} by ${artistName} Filtered using Sort-Play`;
            }

            let playlistDescription = baseDescription;

            const playlistName = `${sourceName} (Custom Filter)`;

            try {
                const newPlaylist = await createPlaylist(playlistName, playlistDescription);
                await new Promise(resolve => setTimeout(resolve, 1250));
                mainButton.innerText = "Saving...";
                const trackUris = sortedTracksForPlaylist.map((track) => track.uri);
                await addTracksToPlaylist(newPlaylist.id, trackUris);

                await addPlaylistToLibrary(newPlaylist.uri);

                const sortTypeInfo = {
                    playCount: { fullName: "play count", shortName: "PlayCount" },
                    popularity: { fullName: "popularity", shortName: "Popularity" },
                    releaseDate: { fullName: "release date", shortName: "ReleaseDate" },
                    scrobbles: { fullName: "Last.fm scrobbles", shortName: "Scrobbles" },
                    personalScrobbles: { fullName: "Last.fm personal scrobbles", shortName: "My Scrobbles" },
                    shuffle: { fullName: "shuffle", shortName: "Shuffle" },
                    aiPick: { fullName: "AI pick", shortName: "AI Pick" },
                    averageColor: { fullName: "album color", shortName: "Color" },
                    default: { fullName: "Default", shortName: "Default" },
                    current: { fullName: "Current", shortName: "Current" },

                }[selectedSortType];

                showNotification(
                    `Playlist created with ${sortTypeInfo.fullName} and custom filter!`
                );

                await navigateToPlaylist(newPlaylist);
            } catch (error) {
                console.error("Error creating or updating playlist:", error);
                showNotification(
                    `An error occurred while creating or updating the playlist. Please check your internet connection and try again.`
                );
            }
        }
        finally {
            resetButtons();
        }

    });


    if (isMenuOpen) {
      closeAllMenus();
    }
  }
  
  function getJobs() {
    try {
      return JSON.parse(localStorage.getItem(STORAGE_KEY_DYNAMIC_PLAYLIST_JOBS) || '[]');
    } catch (e) {
      return [];
    }
  }

  function saveJobs(jobs) {
    localStorage.setItem(STORAGE_KEY_DYNAMIC_PLAYLIST_JOBS, JSON.stringify(jobs));
  }

  function addJob(newJob) {
    const jobs = getJobs();
    jobs.push(newJob);
    saveJobs(jobs);
  }

  function deleteJob(jobId) {
    let jobs = getJobs();
    const jobToDelete = jobs.find(job => job.id === jobId);
    
    if (jobToDelete && jobToDelete.sources) {
        jobToDelete.sources.forEach(source => {
            idb.del('jobHistory', `${jobId}_${source.uri}`);
        });
    }

    jobs = jobs.filter(job => job.id !== jobId);
    saveJobs(jobs);
  }

  function updateJob(updatedJob) {
    const jobs = getJobs();
    const index = jobs.findIndex(job => job.id === updatedJob.id);
    if (index !== -1) {
      jobs[index] = updatedJob;
      saveJobs(jobs);
    }
  }

  function getDedicatedJobs() {
    try {
      return JSON.parse(localStorage.getItem(STORAGE_KEY_DEDICATED_PLAYLIST_JOBS) || '[]');
    } catch (e) {
      return [];
    }
  }

  function saveDedicatedJobs(jobs) {
    localStorage.setItem(STORAGE_KEY_DEDICATED_PLAYLIST_JOBS, JSON.stringify(jobs));
  }

  function addDedicatedJob(newJob) {
    const jobs = getDedicatedJobs();
    jobs.push(newJob);
    saveDedicatedJobs(jobs);
  }

  function deleteDedicatedJob(jobId) {
    let jobs = getDedicatedJobs();
    jobs = jobs.filter(job => job.id !== jobId);
    saveDedicatedJobs(jobs);
  }

  function updateDedicatedJob(updatedJob) {
    const jobs = getDedicatedJobs();
    const index = jobs.findIndex(job => job.id === updatedJob.id);
    if (index !== -1) {
      jobs[index] = updatedJob;
      saveDedicatedJobs(jobs);
    }
  }

  function getCustomSchedules() {
    try {
      return JSON.parse(localStorage.getItem(STORAGE_KEY_DYNAMIC_PLAYLIST_CUSTOM_SCHEDULES) || '[]');
    } catch (e) {
      return [];
    }
  }

  function saveCustomSchedules(schedules) {
    localStorage.setItem(STORAGE_KEY_DYNAMIC_PLAYLIST_CUSTOM_SCHEDULES, JSON.stringify(schedules));
  }
  
  async function executeSortOperation(config) {
    const { sortType, sources, deduplicate, isHeadless = false, preFetchedTracks = null, limitEnabled = false, additionalTracksToInclude = [], filters = {} } = config;

    let combinedTracks;
    let newUsedUrisBySource = {};

    if (preFetchedTracks) {
        combinedTracks = preFetchedTracks;
    } else {
        if (!sources || sources.length === 0) {
            throw new Error('No sources provided for dynamic playlist');
        }

        const trackFetchPromises = sources.map(async source => {
            const sourceUri = source.uri;
            let sourceTracks;

            if (URI.isPlaylistV1OrV2(sourceUri)) {
                sourceTracks = await getPlaylistTracks(sourceUri.split(":")[2]);
            } else if (URI.isArtist(sourceUri)) {
                sourceTracks = await getArtistTracks(sourceUri, isHeadless);
            } else if (isLikedSongsPage(sourceUri)) {
                sourceTracks = await getLikedSongs();
            } else if (URI.isAlbum(sourceUri)) {
                sourceTracks = await getAlbumTracks(sourceUri.split(":")[2]);
            } else {
                console.warn(`[Sort-Play Dynamic] Unsupported source URI type: ${sourceUri}`);
                return [];
            }
            
            if (sourceTracks) {
                sourceTracks = sourceTracks.filter(track => !Spicetify.URI.isLocal(track.uri));
            }

            if (limitEnabled && source.limit > 0 && source.limitEnabled !== false) {
                let actualLimit = source.limit;
                if (source.limitMode === 'percent') {
                    actualLimit = Math.max(1, Math.ceil(sourceTracks.length * (source.limit / 100)));
                }

                let historyKey = config.id ? `${config.id}_${source.uri}` : null;
                let storedHistory = historyKey ? await idb.get('jobHistory', historyKey) : [];
                let usedUris = new Set(storedHistory || source.usedTrackURIs || []);
                
                let availableTracks = sourceTracks.filter(t => !usedUris.has(t.uri));
                let selectedTracks;

                if (availableTracks.length < actualLimit && sourceTracks.length > 0) {
                    const shuffledAll = shuffleArray(sourceTracks);
                    selectedTracks = shuffledAll.slice(0, actualLimit);
                    newUsedUrisBySource[source.uri] = selectedTracks.map(t => t.uri);
                } else {
                    const shuffledAvailable = shuffleArray(availableTracks);
                    selectedTracks = shuffledAvailable.slice(0, actualLimit);
                    const newUris = selectedTracks.map(t => t.uri);
                    newUris.forEach(uri => usedUris.add(uri));
                    newUsedUrisBySource[source.uri] = Array.from(usedUris);
                }
                return selectedTracks;
            }
            return sourceTracks;
        });

        const trackArrays = await Promise.all(trackFetchPromises);
        combinedTracks = trackArrays.flat();
        
        if (limitEnabled && !isHeadless) {
             const totalLimit = sources.reduce((acc, s) => acc + (parseInt(s.limit) || 0), 0);
             const fetchedCount = combinedTracks.length;
             if (fetchedCount < totalLimit * 0.9 && fetchedCount > 0) {
                 showNotification(`Fetched ${fetchedCount} tracks (Limit total: ${totalLimit}). Some sources may be short.`, 'warning');
             }
        }

        const filteredAdditionalTracks = additionalTracksToInclude.filter(track => !Spicetify.URI.isLocal(track.uri));
        combinedTracks.push(...filteredAdditionalTracks);
    }

    let filteredTracks = combinedTracks;

    const likedFilterMode = filters.likedFilter || (filters.excludeLiked ? 'exclude' : 'all');
    const scrobbleFilterMode = filters.scrobbleFilter || (filters.excludeListened ? 'exclude' : 'all');

    if (likedFilterMode !== 'all') {
        if (!isHeadless) mainButton.innerText = "Filtering Liked...";
        const likedSongs = await getLikedSongs();
        const likedSongUris = new Set(likedSongs.map(s => s.uri));
        
        if (!isHeadless) mainButton.innerText = "ISRCs...";
        const tracksWithMetadata = await refreshTrackAlbumInfo(filteredTracks, (p) => {
             if (!isHeadless) mainButton.innerText = `ISRCs ${Math.floor(p)}%`;
        });

        const likedTrackIds = likedSongs.map(s => s.uri.split(':')[2]).filter(Boolean);
        const cachedLikedMetadata = await idb.getMany('trackMetadata', likedTrackIds, CACHE_EXPIRE_METADATA);
        
        const likedIsrcSet = new Set();
        cachedLikedMetadata.forEach(meta => {
            if (meta && meta.external_ids && meta.external_ids.isrc) {
                likedIsrcSet.add(meta.external_ids.isrc);
            }
        });

        filteredTracks = tracksWithMetadata.filter(track => {
            const isLiked = likedSongUris.has(track.uri) || (track.track?.external_ids?.isrc && likedIsrcSet.has(track.track.external_ids.isrc));
            
            if (likedFilterMode === 'exclude') return !isLiked;
            if (likedFilterMode === 'require') return isLiked;
            return true;
        });
    }

    if (scrobbleFilterMode !== 'all') {
        if (!isHeadless) mainButton.innerText = "Filtering History...";
        const lastFmUsername = loadLastFmUsername();
        if (lastFmUsername) {
            const tracksWithScrobbles = await processBatchesWithDelay(
                filteredTracks, 50, 1000, () => {}, getTrackDetailsWithPersonalScrobbles
            );
            
            filteredTracks = tracksWithScrobbles.filter(t => {
                const playCount = t.personalScrobbles || 0;
                if (scrobbleFilterMode === 'exclude') return playCount === 0;
                if (scrobbleFilterMode === 'require') return playCount > 0;
                return true;
            });
        } else {
            console.warn("[Sort-Play Dynamic Filter] Cannot filter by history. Last.fm username not set.");
            if (!isHeadless) showNotification("Last.fm username not set, skipping history filter.", 'warning');
        }
    }

    if (filters.maxPlayCount !== undefined && filters.maxPlayCount !== null && filters.maxPlayCount !== '') {
        if (!isHeadless) mainButton.innerText = "Filtering Plays...";
        const maxPlays = parseInt(filters.maxPlayCount, 10);
        if (!isNaN(maxPlays)) {
            const tracksWithPlaycounts = await enrichTracksWithPlayCounts(filteredTracks);
            filteredTracks = tracksWithPlaycounts.filter(t => {
                const playCount = parseInt(t.playCount, 10);
                return isNaN(playCount) || playCount <= maxPlays;
            });
        }
    }

    if (filters.keywordFilterEnabled && (filters.titleAlbumKeywords?.length > 0 || filters.artistKeywords?.length > 0)) {
        if (!isHeadless) mainButton.innerText = "Filtering Keywords...";
    
        const { keepMatchingMode, filterTitle, filterAlbum, filterArtist, matchWholeWord, titleAlbumKeywords = [], artistKeywords = [] } = filters;
        
        filteredTracks = filteredTracks.filter(track => {
            const trackTitle = track.songTitle || track.name || "";
            const trackAlbum = track.albumName || "";
            const trackArtists = track.allArtists || "";
    
            const hasTitleAlbumKeywords = titleAlbumKeywords.length > 0;
            const hasArtistKeywords = artistKeywords.length > 0;
    
            const titleAlbumMatch = hasTitleAlbumKeywords && titleAlbumKeywords.some(keyword => {
                const regex = matchWholeWord ? new RegExp(`\\b${escapeRegExp(keyword)}\\b`, 'i') : new RegExp(escapeRegExp(keyword), 'i');
                return (filterTitle && regex.test(trackTitle)) || (filterAlbum && regex.test(trackAlbum));
            });
    
            const artistMatch = hasArtistKeywords && filterArtist && artistKeywords.some(keyword => {
                const regex = matchWholeWord ? new RegExp(`\\b${escapeRegExp(keyword)}\\b`, 'i') : new RegExp(escapeRegExp(keyword), 'i');
                return regex.test(trackArtists);
            });
    
            if (keepMatchingMode) {
                const titleAlbumCondition = hasTitleAlbumKeywords ? titleAlbumMatch : true;
                const artistCondition = hasArtistKeywords ? artistMatch : true;
                return titleAlbumCondition && artistCondition;
            } else {
                return !(titleAlbumMatch || artistMatch);
            }
        });
    }

    if (filters.genreFilterSettings && (filters.genreFilterSettings.selectedGenres?.length > 0 || filters.genreFilterSettings.excludedGenres?.length > 0)) {
        if (!isHeadless) mainButton.innerText = "Filtering Genres...";
        const { selectedGenres, excludedGenres, matchAllGenres: jobMatchAll, groupGenres } = filters.genreFilterSettings;
        
        
        const { trackGenreMap } = await fetchAllTrackGenres(
            filteredTracks, 
            (progress) => { if (!isHeadless) mainButton.innerText = `Genres ${progress}`; }
        );

        filteredTracks = filterTracksByGenres(
            filteredTracks, 
            selectedGenres || [], 
            excludedGenres || [], 
            trackGenreMap, 
            jobMatchAll
        );
    }

    const tracks = Array.from(new Map(filteredTracks.map(track => [track.uri, track])).values());

    if (!tracks || tracks.length === 0) {
        return { trackUris: [], newUsedUrisBySource: {} };
    }

    const tracksWithPlayCounts = await enrichTracksWithPlayCounts(tracks);
    const tracksWithIds = await processBatchesWithDelay(tracksWithPlayCounts, 50, 500, () => {}, collectTrackIdsForPopularity);
    const tracksWithPopularity = await fetchPopularityForMultipleTracks(tracksWithIds, () => {});

    let tracksForProcessing = tracksWithPopularity;
    if (sortType === "releaseDate") {
        tracksForProcessing = await processBatchesWithDelay(tracksWithPopularity, 50, 500, () => {}, getTrackDetailsWithReleaseDate);
    }

    const audioFeatureSortTypes = ['tempo', 'energy', 'danceability', 'valence', 'acousticness', 'instrumentalness'];
    if (audioFeatureSortTypes.includes(sortType)) {
        const trackIds = tracksWithPopularity.map(t => t.trackId || t.uri.split(":")[2]);
        const allStats = await getBatchTrackStats(trackIds);
        
        if (Object.keys(allStats).length === 0 && trackIds.length > 0) {
             showNotification(`Failed to fetch audio features (e.g. ${sortType}). Results may be empty.`, true);
        }

        tracksForProcessing = tracksWithPopularity.map(track => {
            const stats = allStats[track.trackId || track.uri.split(":")[2]] || {};
            return { ...track, ...stats };
        });
    }

    const { unique: uniqueTracks } = deduplicate ? await deduplicateTracks(
        tracksForProcessing, 
        false, 
        sources.some(s => URI.isArtist(s.uri)),
        (progress) => { if (!isHeadless) mainButton.innerText = `Dedup ${progress}%`; }
    ) : { unique: tracksForProcessing, removed: [] };

    let sortedTracks;
    switch (sortType) {
        case "playCount":
            sortedTracks = uniqueTracks.sort((a, b) => {
                const valA = (a.playCount === "N/A" || a.playCount == null) ? -1 : Number(a.playCount);
                const valB = (b.playCount === "N/A" || b.playCount == null) ? -1 : Number(b.playCount);
                return valB - valA;
            });
            break;
        case "popularity":
            sortedTracks = uniqueTracks.sort((a, b) => {
                const valA = (a.popularity == null) ? -1 : a.popularity;
                const valB = (b.popularity == null) ? -1 : b.popularity;
                return valB - valA;
            });
            break;
        case "releaseDate":
            sortedTracks = uniqueTracks.sort((a, b) => {
                const valA = a.releaseDate ? new Date(a.releaseDate).getTime() : 0;
                const valB = b.releaseDate ? new Date(b.releaseDate).getTime() : 0;
                if (valA !== valB) return valB - valA;

                const albumA = (a.albumName || "").toLowerCase();
                const albumB = (b.albumName || "").toLowerCase();
                const albumCompare = albumA.localeCompare(albumB);
                if (albumCompare !== 0) return albumCompare;

                return (a.trackNumber || 0) - (b.trackNumber || 0);
            });
            break;
        case "scrobbles":
        case "personalScrobbles": {
            const tracksWithScrobbles = await handleScrobblesSorting(uniqueTracks, sortType, () => {});
            if (sortType === 'personalScrobbles') {
                const includeZeroScrobbles = localStorage.getItem("sort-play-include-no-scrobbles") !== "false";
                sortedTracks = tracksWithScrobbles
                    .filter(track => includeZeroScrobbles || (track.personalScrobbles != null && track.personalScrobbles > 0))
                    .sort((a, b) => (b.personalScrobbles ?? 0) - (a.personalScrobbles ?? 0));
            } else {
                const includeZeroScrobbles = localStorage.getItem("sort-play-include-zero-scrobbles") !== "false";
                sortedTracks = tracksWithScrobbles
                    .filter(track => includeZeroScrobbles || (track.scrobbles != null && track.scrobbles > 0))
                    .sort((a, b) => (b.scrobbles ?? 0) - (a.scrobbles ?? 0));
            }
            break;
        }
        case 'tempo':
        case 'energy':
        case 'danceability':
        case 'valence':
        case 'acousticness':
        case 'instrumentalness':
            sortedTracks = uniqueTracks
                .filter(track => track[sortType] !== null && track[sortType] !== undefined)
                .sort((a, b) => {
                    const valA = a[sortType] || 0;
                    const valB = b[sortType] || 0;
                    return valB - valA;
                });
            if (sortedTracks.length < uniqueTracks.length && (!isHeadless || sortedTracks.length === 0)) {
                 const dropped = uniqueTracks.length - sortedTracks.length;
                 showNotification(`Dropped ${dropped} tracks missing ${sortType} data.`, 'warning');
            }
            break;
        case "shuffle":
            sortedTracks = shuffleArray(uniqueTracks);
            break;
        default:
            sortedTracks = uniqueTracks;
            break;
    }

    return {
        trackUris: sortedTracks.map(t => t.uri),
        newUsedUrisBySource: newUsedUrisBySource
    };
  }
  
  const isJobDue = (job, currentTime) => {
    if (job.isDeleted) return false;
    const lastRun = job.lastRun || 0;
    const schedule = job.schedule;

    if (schedule === 'manual') {
        return false;
    }

    if (typeof schedule === 'number') {
        return currentTime > lastRun + schedule;
    }

    if (typeof schedule === 'string' && schedule.startsWith('release-')) {
        const daysSinceLastRun = (currentTime - lastRun) / (1000 * 60 * 60 * 24);

        switch (schedule) {
            case 'release-weekly':
                return daysSinceLastRun > 6;
            case 'release-every-two-weeks':
                return daysSinceLastRun > 13;
            case 'release-monthly':
                return daysSinceLastRun > 27;
            default:
                return false;
        }
    }
    return false;
  };

  async function runJob(jobConfig, isInitialRun = false, updateSchedule = true) {
    let job = { ...jobConfig };
    let finalTrackUris;
    let newDescription = null;
    const updateMode = job.updateMode || 'replace';

    if (isInitialRun) {
        const allSortableItems = buttonStyles.menuItems.flatMap(item => {
            if (item.type === 'parent' && item.children) {
                return item.children.flatMap(child => {
                    if (child.type === 'parent' && child.children) {
                        return child.children.filter(c => c && c.sortType && c.text);
                    }
                    if (child.sortType && child.text) {
                        return [child];
                    }
                    return [];
                });
            }
            if (item.sortType && item.text) {
                return [item];
            }
            return [];
        });

        const sortTypeInfo = allSortableItems.find(i => i.sortType === job.sortType);
        const sortTypeText = sortTypeInfo?.text ?? job.sortType.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());

        const playlistName = job.targetPlaylistName || (job.sources.length > 1 ? "Combined Dynamic Playlist" : `${job.sources[0].name} (Dynamic)`);
        const sourceNames = job.sources.length > 1 ? "multiple sources" : (job.sources[0]?.name || "Unknown Source");
        const playlistDescription = `Dynamically sorted by ${sortTypeText}. Source${job.sources.length > 1 ? 's' : ''}: ${sourceNames}. Managed by Sort-Play.`;
        
        const newPlaylist = await createPlaylist(playlistName, playlistDescription);
        job.targetPlaylistUri = newPlaylist.uri;
        job.targetPlaylistName = playlistName;

        if (job.sources.length === 1) {
            const firstSource = job.sources[0];
            const firstSourceCover = firstSource.coverUrl;
            if (firstSourceCover && !isDefaultMosaicCover(firstSourceCover)) {
                try {
                    let base64Image;
                    if (URI.isArtist(firstSource.uri)) {
                        base64Image = await toBase64(firstSourceCover);
                    } else {
                        base64Image = await imageUrlToBase64(firstSourceCover);
                    }
                    await setPlaylistImage(newPlaylist.id, base64Image);
                    job.coverUrl = firstSourceCover;
                } catch (error) {
                    console.warn(`[Sort-Play Dynamic] Could not apply original source cover for "${job.sources[0].name}":`, error);
                    job.coverUrl = newPlaylist.images?.length ? (newPlaylist.images[newPlaylist.images.length - 1] || newPlaylist.images[0]).url : null;
                }
            } else {
                job.coverUrl = newPlaylist.images?.length ? (newPlaylist.images[newPlaylist.images.length - 1] || newPlaylist.images[0]).url : null;
            }
        } else {
            job.coverUrl = newPlaylist.images?.length ? (newPlaylist.images[newPlaylist.images.length - 1] || newPlaylist.images[0]).url : null;
        }
        
        await addPlaylistToLibrary(newPlaylist.uri);
        
        const result = await executeSortOperation({ ...job, isHeadless: true });
        finalTrackUris = result.trackUris;
        
        for (const [sourceUri, newHistory] of Object.entries(result.newUsedUrisBySource)) {
            if (newHistory) {
                await idb.set('jobHistory', `${job.id}_${sourceUri}`, newHistory);
            }
        }
    } else {
        const playlistId = job.targetPlaylistUri.split(':')[2];
        try {
            let currentDescription = null;

            const fetchDescriptionInternal = async () => {
                const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(job.targetPlaylistUri);
                return meta.description;
            };

            if (isFallbackActive()) {
                currentDescription = await fetchDescriptionInternal();
            } else {
                try {
                    const currentPlaylistData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${playlistId}`);
                    currentDescription = currentPlaylistData.description;
                } catch (e) {
                    if (registerWebApiFailure()) {
                        currentDescription = await fetchDescriptionInternal();
                    } else {
                        throw e;
                    }
                }
            }

            if (currentDescription && currentDescription.includes("Managed by Sort-Play.")) {
                const allSortableItems = buttonStyles.menuItems.flatMap(item => {
                    if (item.type === 'parent' && item.children) {
                        return item.children.flatMap(child => {
                            if (child.type === 'parent' && child.children) {
                                return child.children.filter(c => c && c.sortType && c.text);
                            }
                            if (child.sortType && child.text) {
                                return [child];
                            }
                            return [];
                        });
                    }
                    if (item.sortType && item.text) {
                        return [item];
                    }
                    return [];
                });

                const sortTypeMap = allSortableItems.reduce((acc, item) => {
                    acc[item.sortType] = item.text;
                    return acc;
                }, {});

                let oldSortTypeText = null;
                for (const type in sortTypeMap) {
                    const regex = new RegExp(`by ${sortTypeMap[type]}\\.`, 'i');
                    if (regex.test(currentDescription)) {
                        oldSortTypeText = sortTypeMap[type];
                        break;
                    }
                }

                const newSortTypeText = sortTypeMap[job.sortType];

                if (oldSortTypeText && newSortTypeText && oldSortTypeText !== newSortTypeText) {
                    newDescription = currentDescription.replace(`by ${oldSortTypeText}`, `by ${newSortTypeText}`);
                }
            }
        } catch (e) {
            console.warn("Sort-Play: Could not fetch current playlist details to update description.", e);
        }

        if (updateMode === 'append') {
            const result = await executeSortOperation({ ...job, isHeadless: true });
            const sampledTrackUris = result.trackUris;

            if (!sampledTrackUris || sampledTrackUris.length === 0) {
                if (updateSchedule) job.lastRun = Date.now();
                return job;
            }
            const targetTracks = await getPlaylistTracks(playlistId);
            const targetTrackUris = new Set(targetTracks.map(t => t.uri));
            const newTrackUris = sampledTrackUris.filter(uri => !targetTrackUris.has(uri));

            if (newTrackUris.length > 0) {
                await Spicetify.Platform.PlaylistAPI.add(job.targetPlaylistUri, newTrackUris, { before: 0 });
            }
            for (const [sourceUri, newHistory] of Object.entries(result.newUsedUrisBySource)) {
                if (newHistory) {
                    await idb.set('jobHistory', `${job.id}_${sourceUri}`, newHistory);
                }
            }
            if (updateSchedule) job.lastRun = Date.now();
            return job;
        } else if (updateMode === 'merge') {
            const targetTracks = await getPlaylistTracks(playlistId);
            const mergeResult = await executeSortOperation({ ...job, isHeadless: true, additionalTracksToInclude: targetTracks });
            finalTrackUris = mergeResult.trackUris;
            for (const [sourceUri, newHistory] of Object.entries((updateMode === 'merge' ? mergeResult : updateResult).newUsedUrisBySource)) {
                if (newHistory) {
                    await idb.set('jobHistory', `${job.id}_${sourceUri}`, newHistory);
                }
            }
        } else {
            const sourcesForUpdate = job.updateFromSource ? job.sources : [{ uri: job.targetPlaylistUri, totalTracks: 0 }];
            const updateResult = await executeSortOperation({ ...job, sources: sourcesForUpdate, isHeadless: true });
            finalTrackUris = updateResult.trackUris;
            for (const [sourceUri, newHistory] of Object.entries((updateMode === 'merge' ? mergeResult : updateResult).newUsedUrisBySource)) {
                if (newHistory) {
                    await idb.set('jobHistory', `${job.id}_${sourceUri}`, newHistory);
                }
            }
        }
    }
    
    if (finalTrackUris && finalTrackUris.length > 0) {
        await replacePlaylistTracks(job.targetPlaylistUri.split(':')[2], finalTrackUris);
    } else {
        const msg = `[Sort-Play Dynamic] Job for "${job.targetPlaylistName}" resulted in 0 tracks. Check filters or audio data.`;
        console.warn(msg);
        showNotification(msg, 'warning');
    }

    if (newDescription) {
        try {
            const playlistId = job.targetPlaylistUri.split(':')[2];
            if (isFallbackActive()) {
                await Spicetify.Platform.PlaylistAPI.setAttributes(job.targetPlaylistUri, { description: newDescription });
            } else {
                try {
                    await Spicetify.CosmosAsync.put(
                        `https://api.spotify.com/v1/playlists/${playlistId}`,
                        { description: newDescription }
                    );
                } catch (e) {
                    if (registerWebApiFailure()) {
                        await Spicetify.Platform.PlaylistAPI.setAttributes(job.targetPlaylistUri, { description: newDescription });
                    } else {
                        throw e;
                    }
                }
            }
        } catch (e) {
            console.warn("Sort-Play: Failed to update playlist description.", e);
        }
    }

    if (updateSchedule) job.lastRun = Date.now();
    return job;
  }

  async function checkAndRunJobs() {
    const jobs = getJobs();
    const now = Date.now();
    const jobsToRun = jobs.filter(job => !job.isDeleted && isJobDue(job, now));
    const totalJobs = jobsToRun.length;

    if (totalJobs > 0) {
        const stickyNotification = showNotification(`Starting Dynamic Updates (0/${totalJobs})...`, 'sticky');
        
        try {
            for (let i = 0; i < totalJobs; i++) {
                const job = jobsToRun[i];
                const currentStep = i + 1;
                
                stickyNotification.update(`Updating Dynamic Playlists (${currentStep}/${totalJobs}): ${job.targetPlaylistName}`);

                try {
                    const updatedJob = await runJob(job);
                    updateJob(updatedJob);
                } catch (error) {
                    showDetailedError(error, `Failed to run dynamic playlist job for "${job.targetPlaylistName}"`);
                    job.lastRun = now;
                    updateJob(job);
                }

                if (i < totalJobs - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }
        } finally {
            stickyNotification.remove();
            showNotification(`Finished updating ${totalJobs} dynamic playlists.`);
        }
    }
  }

  function startScheduler() {
    let isSchedulerRunning = false;

    const runSequence = async () => {
        if (isSchedulerRunning) return;
        isSchedulerRunning = true;
        try {
            await checkAndRunJobs();
            
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            await checkAndRunDedicatedJobs();
        } catch (e) {
            console.error("[Sort-Play] Scheduler error:", e);
        } finally {
            isSchedulerRunning = false;
        }
    };

    runSequence();
    setInterval(runSequence, SCHEDULER_INTERVAL_MINUTES * 60 * 1000);
  }


  async function fetchUserLibrary() {
    try {
        const rootlist = await Spicetify.Platform.RootlistAPI.getContents();

        const playlistPromises = rootlist.items
            .filter(item => item.type === 'playlist')
            .map(async (item) => {
                const images = item.images || [];
                if (images.length > 0 || item.imageUrl) {
                    return {
                        uri: item.uri,
                        name: item.name,
                        info: 'Playlist',
                        coverUrl: images.length ? (images[images.length - 1] || images[0]).url : item.imageUrl,
                        type: 'playlist'
                    };
                } else {
                    const fetchWithInternal = async () => {
                        try {
                            const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(item.uri);
                            const fetchedImages = meta.images || [];
                            return {
                                uri: item.uri,
                                name: item.name || meta.name,
                                info: 'Playlist',
                                coverUrl: fetchedImages.length ? (fetchedImages[fetchedImages.length - 1] || fetchedImages[0]).url : null,
                                type: 'playlist'
                            };
                        } catch (e) {
                            console.warn(`Sort-Play: Could not fetch metadata for playlist ${item.name}`, e);
                            return {
                                uri: item.uri,
                                name: item.name,
                                info: 'Playlist',
                                coverUrl: null,
                                type: 'playlist'
                            };
                        }
                    };

                    if (isFallbackActive()) {
                        return await fetchWithInternal();
                    }

                    try {
                        const playlistId = item.uri.split(':')[2];
                        const playlistData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${playlistId}`);
                        const fetchedImages = playlistData.images || [];
                        return {
                            uri: item.uri,
                            name: item.name,
                            info: 'Playlist',
                            coverUrl: fetchedImages.length ? (fetchedImages[fetchedImages.length - 1] || fetchedImages[0]).url : null,
                            type: 'playlist'
                        };
                    } catch (error) {
                        if (registerWebApiFailure()) {
                            return await fetchWithInternal();
                        }
                        console.warn(`Sort-Play: Could not fetch full details for playlist ${item.name}`, error);
                        return {
                            uri: item.uri,
                            name: item.name,
                            info: 'Playlist',
                            coverUrl: null,
                            type: 'playlist'
                        };
                    }
                }
            });

        const resolvedPlaylists = await Promise.all(playlistPromises);

        const fetchAlbumsInternal = async () => {
            const resolvedAlbumsInternal = [];
            try {
                const libItems = await Spicetify.Platform.LibraryAPI.getContents({ limit: 100, sort: { field: "ADDED", order: "DESC" } });
                const albumItems = (libItems.items || []).filter(item => item.type === 'album' || (item.uri && item.uri.includes(':album:')));
                
                albumItems.forEach(item => {
                    const imageUrl = item.images?.length ? item.images[0].url : (item.image?.url || null);
                    resolvedAlbumsInternal.push({
                        uri: item.uri,
                        name: item.name,
                        info: `Album by ${item.artists ? item.artists.map(a => a.name).join(', ') : 'Unknown'}`,
                        coverUrl: imageUrl,
                        type: 'album'
                    });
                });
            } catch (e) {
                console.warn("[Sort-Play] Internal Album fetch failed:", e);
            }
            return resolvedAlbumsInternal;
        };

        let resolvedAlbums = [];

        if (isFallbackActive()) {
            resolvedAlbums = await fetchAlbumsInternal();
        } else {
            try {
                const albumsRes = await Spicetify.CosmosAsync.get('https://api.spotify.com/v1/me/albums?limit=50');
                if (albumsRes.items) {
                    albumsRes.items.forEach(item => {
                        const images = item.album.images || [];
                        resolvedAlbums.push({
                            uri: item.album.uri,
                            name: item.album.name,
                            info: `Album by ${item.album.artists.map(a => a.name).join(', ')}`,
                            coverUrl: images.length ? (images[images.length - 1] || images[0]).url : null,
                            type: 'album'
                        });
                    });
                }
            } catch (e) {
                if (registerWebApiFailure()) {
                    resolvedAlbums = await fetchAlbumsInternal();
                } else {
                    console.warn("Failed to fetch albums via Web API", e);
                }
            }
        }
        
        return [...resolvedPlaylists, ...resolvedAlbums];

    } catch (error) {
        console.error("Failed to fetch user library:", error);
        return [];
    }
  }

  async function showChangeSourceModal(title, libraryItemsPromise, onSourceChanged, isMultiSelect = true) {
    const overlay = document.createElement("div");
    overlay.id = "sort-play-change-source-modal";
    overlay.className = "sort-play-font-scope";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        z-index: 2003; display: flex; justify-content: center; align-items: center;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container";
    modalContainer.style.cssText = `
        width: 450px !important; display: flex; flex-direction: column;
        border-radius: 20px; background-color: #181818 !important; border: 1px solid #282828;
    `;

    let selectedSources = new Set();

    modalContainer.innerHTML = `
        <style>
            #user-library-container {
                margin-top: 16px;
                background-color: #282828;
                border-radius: 6px;
                padding: 8px;
                height: 300px;
                max-height: 300px;
                overflow-y: auto;
                scrollbar-width: thin;
                scrollbar-color: #535353 #282828;
            }
            #user-library-container::-webkit-scrollbar { width: 8px; }
            #user-library-container::-webkit-scrollbar-track { background: #282828; }
            #user-library-container::-webkit-scrollbar-thumb { background-color: #535353; border-radius: 4px; }
            .library-item {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 8px;
                border-radius: 4px;
                cursor: pointer;
                transition: background-color 0.2s ease, border 0.2s ease;
                border: 1px solid transparent;
            }
            .library-item:hover { background-color: #3e3e3e; }
            .library-item.selected {
                background-color: #3a4f3a;
                border: 1px solid #1ed760;
            }
            .library-item-cover { width: 40px; height: 40px; border-radius: 4px; object-fit: cover; flex-shrink: 0; background-color: #3e3e3e; }
            .library-item-text { display: flex; flex-direction: column; overflow: hidden; }
            .library-item-title { color: white; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
            .library-item-info { color: #b3b3b3; font-size: 12px; }
            .main-buttons-button.main-button-primary { background-color: #1ED760; color: black; transition: background-color 0.1s ease;}
            .main-buttons-button.main-button-primary:hover { background-color: #3BE377; }
            .main-buttons-button.main-button-secondary { background-color: #333333; color: white; transition: background-color 0.1s ease; }
            .main-buttons-button.main-button-secondary:hover { background-color: #444444; }
            #search-suggestions {
                position: fixed;
                background-color: #282828;
                border: 1px solid #3e3e3e;
                border-radius: 6px;
                z-index: 2005;
                box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                display: flex;
                max-height: 450px;
                overflow: hidden;
            }
            .suggestions-column {
                flex: 1;
                overflow-y: auto;
                padding: 4px;
                scrollbar-width: thin;
                scrollbar-color: #535353 #282828;
            }
            .suggestions-column::-webkit-scrollbar { width: 6px; }
            .suggestions-column::-webkit-scrollbar-track { background: #282828; }
            .suggestions-column::-webkit-scrollbar-thumb { background-color: #535353; border-radius: 3px; }
            .suggestions-column:first-child {
                border-right: 1px solid #3e3e3e;
            }
            .suggestion-item {
                display: flex;
                align-items: center;
                padding: 8px;
                cursor: pointer;
                border-radius: 4px;
            }
            .suggestion-item:hover {
                background-color: #3e3e3e;
            }
            .suggestion-cover {
                width: 32px;
                height: 32px;
                margin-right: 8px;
                border-radius: 4px;
                object-fit: cover;
                flex-shrink: 0;
            }
            .suggestion-text {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                font-size: 14px;
                color: white;
            }
            .suggestion-header {
                font-size: 12px;
                font-weight: bold;
                color: #b3b3b3;
                padding: 8px 8px 4px;
                text-transform: uppercase;
            }
            #source-clear-btn {
                position: absolute;
                right: 10px;
                top: 50%;
                transform: translateY(-50%);
                background: none;
                border: none;
                color: #b3b3b3;
                cursor: pointer;
                font-size: 20px;
                padding: 0 5px;
                line-height: 1;
                display: none;
            }
            #source-clear-btn:hover { color: white; }
        </style>
        <div class="main-trackCreditsModal-header" style="padding: 20px 24px 10px;">
            <h1 class="main-trackCreditsModal-title" style="font-size: 20px; font-weight: 700; color: white;">${title}</h1>
        </div>
        <div class="main-trackCreditsModal-mainSection" style="padding: 16px 24px; scrollbar-width: none;">
            <p style="color: #b3b3b3; font-size: 14px; margin: 0 0 12px;">Search for source, paste a link, or select from your library.</p>
            <div style="position: relative;">
                <input type="text" id="source-url-input" placeholder="Search or paste link..." style="width: 100%; background-color: #3e3e3e; border: 1px solid #3e3e3e; border-radius: 4px; padding: 8px 30px 8px 12px; color: white; box-sizing: border-box;">
                <button id="source-clear-btn">&times;</button>
            </div>
            <div id="source-change-error" style="color: #f15e6c; font-size: 12px; margin-top: 8px; display: none;"></div>
            <div id="user-library-container">
                <div style="text-align: center; color: #b3b3b3; font-size: 14px; padding: 20px 0;">Loading Library...</div>
            </div>
        </div>
        <div class="main-trackCreditsModal-originalCredits" style="padding: 16px 24px; border-top: 1px solid #282828; display: flex; justify-content: flex-end; gap: 10px;">
            <button id="cancel-change-source" class="main-buttons-button main-button-secondary" style="padding: 8px 18px; border-radius: 20px; font-weight: 550; font-size: 13px; text-transform: uppercase; cursor: pointer; border: none;">Cancel</button>
            <button id="confirm-change-source" class="main-buttons-button main-button-primary" style="padding: 8px 18px; border-radius: 20px; font-weight: 550; font-size: 13px; text-transform: uppercase; cursor: pointer; border: none; color: black;">Confirm</button>
        </div>
    `;
    
    const suggestionsContainer = document.createElement('div');
    suggestionsContainer.id = 'search-suggestions';
    suggestionsContainer.style.display = 'none';
    document.body.appendChild(suggestionsContainer);

    const searchInput = modalContainer.querySelector('#source-url-input');
    const clearButton = modalContainer.querySelector('#source-clear-btn');
    const libraryContainer = modalContainer.querySelector('#user-library-container');

    const positionSuggestionsPanel = () => {
        if (suggestionsContainer.style.display === 'none') return;
        const rect = searchInput.getBoundingClientRect();
        suggestionsContainer.style.top = `${rect.bottom + 4}px`;
        suggestionsContainer.style.left = `${rect.left}px`;
        suggestionsContainer.style.width = `${rect.width}px`;
    };

    const hideSuggestions = () => {
        suggestionsContainer.style.display = 'none';
        suggestionsContainer.innerHTML = '';
    };

    const renderSuggestions = (playlists = [], artists = []) => {
        if (playlists.length === 0 && artists.length === 0) {
            hideSuggestions();
            return;
        }

        suggestionsContainer.innerHTML = `
            <div class="suggestions-column">
                <div class="suggestion-header">Playlists</div>
                ${playlists.map(item => `
                    <div class="suggestion-item" data-uri="${item.uri}" data-url="${item.external_urls.spotify}">
                        <img src="${item.images[0]?.url || ''}" class="suggestion-cover">
                        <span class="suggestion-text" title="${item.name}">${item.name}</span>
                    </div>
                `).join('')}
            </div>
            <div class="suggestions-column">
                <div class="suggestion-header">Artists</div>
                ${artists.map(item => `
                    <div class="suggestion-item" data-uri="${item.uri}" data-url="${item.external_urls.spotify}">
                        <img src="${item.images[0]?.url || ''}" class="suggestion-cover">
                        <span class="suggestion-text" title="${item.name}">${item.name}</span>
                    </div>
                `).join('')}
            </div>
        `;
        suggestionsContainer.style.display = 'flex';
        positionSuggestionsPanel();

        suggestionsContainer.querySelectorAll('.suggestion-item').forEach(itemEl => {
            itemEl.addEventListener('click', () => {
                const uri = itemEl.dataset.uri;
                const url = itemEl.dataset.url;
                searchInput.value = url;
                clearButton.style.display = 'block';
                
                selectedSources.add(uri);
                hideSuggestions();
                
                const libraryItem = libraryContainer.querySelector(`.library-item[data-uri="${uri}"]`);
                if (libraryItem) {
                    libraryItem.classList.add('selected');
                }
            });
        });
    };

    const performSearch = async () => {
        const query = searchInput.value.trim();
        if (query.length < 3 || query.startsWith('http')) {
            hideSuggestions();
            return;
        }

        const fetchFallback = async () => {
            const token = await get_S_Client_Token();
            if (!token) {
                hideSuggestions();
                return;
            }
            try {
                const res = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=playlist,artist&limit=8`, {
                    headers: { "Authorization": `Bearer ${token}` }
                });
                
                if (res.status === 429) {
                    s_Access_Token = null; 
                    throw new Error("Rate Limited");
                }

                const data = await res.json();
                const playlists = data.playlists?.items?.filter(Boolean) || [];
                const artists = data.artists?.items?.filter(Boolean) || [];
                
                renderSuggestions(playlists, artists);
            } catch (e) {
                console.error("Client Credentials Search failed:", e);
                hideSuggestions();
            }
        };

        if (isFallbackActive()) {
            await fetchFallback();
            return;
        }

        try {
            const res = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=playlist,artist&limit=8`);
            const playlists = res.playlists?.items?.filter(Boolean) || [];
            const artists = res.artists?.items?.filter(Boolean) || [];
            renderSuggestions(playlists, artists);
        } catch (e) {
            if (registerWebApiFailure()) {
                await fetchFallback();
            } else {
                console.error("Search failed:", e);
                hideSuggestions();
            }
        }
    };

    const debouncedSearch = debounce(performSearch, 300);
    searchInput.addEventListener('input', () => {
        clearButton.style.display = searchInput.value.length > 0 ? 'block' : 'none';
        debouncedSearch();
    });

    clearButton.addEventListener('click', () => {
        searchInput.value = '';
        clearButton.style.display = 'none';
        hideSuggestions();
        searchInput.focus();
    });

    const outsideClickListener = (event) => {
        if (!modalContainer.contains(event.target) && !suggestionsContainer.contains(event.target)) {
            hideSuggestions();
        }
    };
    document.addEventListener('click', outsideClickListener, true);
    window.addEventListener('resize', positionSuggestionsPanel);
    window.addEventListener('scroll', positionSuggestionsPanel, true);

    const closeModal = () => {
        document.removeEventListener('click', outsideClickListener, true);
        window.removeEventListener('resize', positionSuggestionsPanel);
        window.removeEventListener('scroll', positionSuggestionsPanel, true);
        suggestionsContainer.remove();
        overlay.remove();
    };
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            e.preventDefault();
            e.stopPropagation();
        }
    });
    modalContainer.querySelector('#cancel-change-source').addEventListener('click', closeModal);

    const processUri = async (uri) => {
        const uriObj = Spicetify.URI.fromString(uri);
        const newUri = uriObj.toURI();
        let newSourceData = { uri: newUri };

        if (URI.isPlaylistV1OrV2(newUri)) {
            const fetchPlaylistFallback = async () => {
                const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(newUri);
                const owner = meta.owner?.displayName || meta.owner?.name || meta.owner?.username || "Unknown Owner";
                return {
                    name: meta.name,
                    info: `Playlist by ${owner}`,
                    coverUrl: meta.images?.length ? (meta.images[meta.images.length - 1] || meta.images[0]).url : null,
                    isStatic: false,
                    totalTracks: meta.totalLength
                };
            };

            if (isFallbackActive()) {
                Object.assign(newSourceData, await fetchPlaylistFallback());
            } else {
                try {
                    const data = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${newUri.split(":")[2]}`);
                    newSourceData.name = data.name;
                    const ownerName = data.owner?.display_name || data.owner?.id || "Unknown Owner";
                    newSourceData.info = `Playlist by ${ownerName}`;
                    newSourceData.coverUrl = data.images?.length ? (data.images[data.images.length - 1] || data.images[0]).url : null;
                    newSourceData.isStatic = false;
                    newSourceData.totalTracks = data.tracks.total;
                } catch (error) {
                    if (registerWebApiFailure()) {
                        Object.assign(newSourceData, await fetchPlaylistFallback());
                    } else {
                        throw error;
                    }
                }
            }
        } else if (URI.isArtist(newUri)) {
            const fetchArtistFallback = async () => {
                const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, {
                    uri: newUri, locale: "en", includePrerelease: false
                });
                const u = res.data.artistUnion;
                return {
                    name: u.profile.name,
                    info: `Artist Page`,
                    coverUrl: u.visuals.avatarImage?.sources?.[0]?.url || null,
                    isStatic: true,
                    totalTracks: 'N/A'
                };
            };

            if (isFallbackActive()) {
                Object.assign(newSourceData, await fetchArtistFallback());
            } else {
                try {
                    const data = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists/${newUri.split(":")[2]}`);
                    newSourceData.name = data.name;
                    newSourceData.info = `Artist Page`;
                    newSourceData.coverUrl = data.images?.length ? (data.images[data.images.length - 1] || data.images[0]).url : null;
                    newSourceData.isStatic = true;
                    newSourceData.totalTracks = 'N/A';
                } catch (error) {
                    if (registerWebApiFailure()) {
                        Object.assign(newSourceData, await fetchArtistFallback());
                    } else {
                        throw error;
                    }
                }
            }
        } else if (URI.isAlbum(newUri)) {
            const fetchAlbumFallback = async () => {
                const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, {
                    uri: newUri, locale: "en", offset: 0, limit: 1
                });
                const u = res.data.albumUnion;
                return {
                    name: u.name,
                    info: `Album by ${u.artists.items.map(a => a.profile.name).join(', ')}`,
                    coverUrl: u.coverArt.sources?.[0]?.url || null,
                    isStatic: true,
                    totalTracks: u.tracksV2 ? u.tracksV2.totalCount : u.tracks.totalCount
                };
            };

            if (isFallbackActive()) {
                Object.assign(newSourceData, await fetchAlbumFallback());
            } else {
                try {
                    const data = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${newUri.split(":")[2]}`);
                    newSourceData.name = data.name;
                    newSourceData.info = `Album by ${data.artists.map(a => a.name).join(', ')}`;
                    newSourceData.coverUrl = data.images?.length ? (data.images[data.images.length - 1] || data.images[0]).url : null;
                    newSourceData.isStatic = true;
                    newSourceData.totalTracks = data.tracks.total;
                } catch (error) {
                    if (registerWebApiFailure()) {
                        Object.assign(newSourceData, await fetchAlbumFallback());
                    } else {
                        throw error;
                    }
                }
            }
        } else {
            throw new Error("Unsupported link type. Please use a Playlist, Album, or Artist link.");
        }
        return newSourceData;
    };

    modalContainer.querySelector('#confirm-change-source').addEventListener('click', async (e) => {
        const confirmButton = e.currentTarget;
        const url = searchInput.value.trim();
        
        if (url && url.startsWith('http')) {
            try {
                const uriObj = Spicetify.URI.fromString(url);
                selectedSources.add(uriObj.toURI());
            } catch (err) {
                showNotification("Invalid Spotify link pasted.", true);
                return;
            }
        }

        if (selectedSources.size === 0) {
            showNotification("Please select an item or paste a link.", true);
            return;
        }

        confirmButton.disabled = true;
        confirmButton.textContent = 'Verifying...';

        try {
            const sourcesData = await Promise.all(Array.from(selectedSources).map(uri => processUri(uri)));
            onSourceChanged(sourcesData);
            closeModal();
        } catch (error) {
            showNotification(error.message || "Invalid or unsupported Spotify link.", true);
            console.error("Error parsing source URL(s):", error);
        } finally {
            confirmButton.disabled = false;
            confirmButton.textContent = 'Confirm';
        }
    });

    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);

    const container = modalContainer.querySelector('#user-library-container');
    try {
        const libraryItems = await libraryItemsPromise;
        if (libraryItems && libraryItems.length > 0) {
            container.innerHTML = libraryItems.map(item => `
                <div class="library-item" data-uri="${item.uri}">
                    <img src="${item.coverUrl || ''}" class="library-item-cover">
                    <div class="library-item-text">
                        <span class="library-item-title" title="${item.name}">${item.name}</span>
                        <span class="library-item-info">${item.info}</span>
                    </div>
                </div>
            `).join('');

            container.querySelectorAll('.library-item').forEach(itemEl => {
                itemEl.addEventListener('click', async () => {
                    const uri = itemEl.dataset.uri;
                    if (selectedSources.has(uri)) {
                        selectedSources.delete(uri);
                        itemEl.classList.remove('selected');
                    } else {
                        selectedSources.add(uri);
                        itemEl.classList.add('selected');
                    }
                });
            });
            
        } else {
            container.innerHTML = '<div style="text-align: center; color: #b3b3b3; font-size: 14px; padding: 20px 0;">Could not load library.</div>';
        }
    } catch (error) {
        console.error("Failed to load library for modal:", error);
        container.innerHTML = '<div style="text-align: center; color: #f15e6c; font-size: 14px; padding: 20px 0;">Error loading library.</div>';
    }
  }

  async function showDynamicGenreFilterModal(sources, currentFilters, onScanComplete = null) {
    return new Promise((resolve) => {
        const overlay = document.createElement("div");
        overlay.id = "dynamic-genre-filter-overlay";
        overlay.className = "sort-play-font-scope";
        overlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); z-index: 2006;
            display: flex; justify-content: center; align-items: center;
        `;

        const modalContainer = document.createElement("div");
        modalContainer.className = "main-embedWidgetGenerator-container";
        modalContainer.style.zIndex = "2007";
        modalContainer.style.width = "750px";
        modalContainer.style.backgroundColor = "#181818";
        modalContainer.style.borderRadius = "25px";
        modalContainer.style.border = "2px solid #282828";
        modalContainer.style.maxHeight = "90vh";
        modalContainer.style.display = "flex";
        modalContainer.style.flexDirection = "column";

        let selectedGenres = currentFilters.selectedGenres ? [...currentFilters.selectedGenres] : [];
        let excludedGenres = currentFilters.excludedGenres ? [...currentFilters.excludedGenres] : [];
        let matchAllGenres = currentFilters.matchAllGenres || false;
        let groupGenres = currentFilters.groupGenres !== undefined ? currentFilters.groupGenres : true;
        
        let rawDetectedGenres = currentFilters.detectedGenres ? [...currentFilters.detectedGenres] : [];
        let detectedGenres = [...rawDetectedGenres];

        const normalizeList = (list) => {
            if (!list || list.length === 0) return [];
            const rawObjs = list.map(g => ({ name: g, source: 'spotify' }));
            const normalizedObjs = mapAndNormalizeGenres(rawObjs);
            return [...new Set(normalizedObjs.map(o => o.name))];
        };

        if (groupGenres && rawDetectedGenres.length > 0) {
            detectedGenres = normalizeList(rawDetectedGenres);
        }

        let isScanned = false;
        let allAvailableGenres = Object.keys(GENRE_MAPPINGS).sort();
        
        let lastScanResult = null; 
        let scannedTracks = []; 
        let genreCounts = new Map();
        let currentTrackGenreMap = new Map();

        const updateStats = () => {
            const statsContainer = modalContainer.querySelector('.genre-stats-footer');
            if (!statsContainer) return;

            if (scannedTracks.length === 0) {
                statsContainer.innerHTML = '';
                return;
            }

            let tracksWithGenresCount = 0;
            currentTrackGenreMap.forEach(genres => {
                if (genres && genres.length > 0) tracksWithGenresCount++;
            });

            const filteredTracks = filterTracksByGenres(
                scannedTracks,
                selectedGenres,
                excludedGenres,
                currentTrackGenreMap,
                matchAllGenres
            );

            statsContainer.innerHTML = `
                <span class="stat-item">Total tracks: ${tracksWithGenresCount}(${scannedTracks.length})</span>
                <span class="stat-item">Filtered tracks: ${filteredTracks.length}</span>
            `;
        };

        const renderGenres = () => {
            const container = modalContainer.querySelector('.genre-list-container');
            const searchTerm = modalContainer.querySelector('.search-bar').value.toLowerCase();
            
            let html = '';

            const renderGenreButton = (genre, isDetected = false) => {
                let statusClass = '';
                if (selectedGenres.includes(genre)) statusClass = 'selected';
                else if (excludedGenres.includes(genre)) statusClass = 'excluded';
                
                const countDisplay = isDetected ? (genreCounts.has(genre) ? genreCounts.get(genre) : '-') : 0;
                const hasCountClass = isDetected ? 'has-count' : '';
                
                return `
                    <button class="genre-button ${statusClass} ${isDetected ? 'detected' : ''} ${hasCountClass}" data-genre="${genre}">
                        <span>${genre}</span>
                        ${isDetected ? `<span class="genre-count-badge">${countDisplay}</span>` : ''}
                    </button>
                `;
            };

            const filteredDetected = detectedGenres.filter(g => g.toLowerCase().includes(searchTerm));
            const filteredCommon = allAvailableGenres.filter(g => g.toLowerCase().includes(searchTerm) && !detectedGenres.includes(g));

            if (detectedGenres.length > 0) {
                html += `<div class="genre-section-title">Detected Genres</div><div class="genre-group">`;
                if (filteredDetected.length > 0) {
                    html += filteredDetected.map(g => renderGenreButton(g, true)).join('');
                } else {
                    html += `<div class="no-results">No matching detected genres</div>`;
                }
                html += `</div>`;
            }

            html += `<div class="genre-section-title">Common Genres</div><div class="genre-group">`;
            if (filteredCommon.length > 0) {
                html += filteredCommon.map(g => renderGenreButton(g)).join('');
            } else {
                html += `<div class="no-results">No matching common genres</div>`;
            }
            html += `</div>`;

            container.innerHTML = html;

            container.querySelectorAll('.genre-button').forEach(btn => {
                const genre = btn.dataset.genre;
                btn.addEventListener('click', () => {
                    if (excludedGenres.includes(genre)) {
                        excludedGenres = excludedGenres.filter(g => g !== genre);
                    }
                    if (selectedGenres.includes(genre)) {
                        selectedGenres = selectedGenres.filter(g => g !== genre);
                    } else {
                        selectedGenres.push(genre);
                    }
                    renderGenres();
                    updateStats();
                });
                btn.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (selectedGenres.includes(genre)) {
                        selectedGenres = selectedGenres.filter(g => g !== genre);
                    }
                    if (excludedGenres.includes(genre)) {
                        excludedGenres = excludedGenres.filter(g => g !== genre);
                    } else {
                        excludedGenres.push(genre);
                    }
                    renderGenres();
                    updateStats();
                });
            });
        };

        const processRawGenres = (rawGenresMap) => {
            genreCounts.clear();
            currentTrackGenreMap.clear();
            
            const capturedRawSet = new Set();
            rawGenresMap.forEach(data => {
                const genres = [
                    ...(data.spotify_artist_genres || []),
                    ...(data.lastfm_track_genres || []),
                    ...(data.lastfm_artist_genres || []),
                    ...(data.deezer_genres || []),
                    ...(data.apple_music_genres || [])
                ];
                genres.forEach(g => capturedRawSet.add(g));
            });
            rawDetectedGenres = Array.from(capturedRawSet).sort();
            
            const genreDetails = new Map();
            const mainGenres = Object.keys(GENRE_MAPPINGS);
            const countryKeys = Object.keys(COUNTRY_MAPPINGS);
            
            const playlistArtistNames = new Set();
            const uriToArtistMap = new Map();
            
            if (scannedTracks.length > 0) {
                scannedTracks.forEach(t => {
                    const name = t.artistName || (t.artists && t.artists[0]?.name) || "";
                    if (name) {
                        const lowerName = name.toLowerCase();
                        playlistArtistNames.add(lowerName);
                        uriToArtistMap.set(t.uri, lowerName);
                    }
                });
            }
            const totalUniqueArtistsInPlaylist = playlistArtistNames.size;

            scannedTracks.forEach(track => {
                const rawData = rawGenresMap.get(track.uri);
                let finalGenresForTrack = [];

                if (rawData) {
                    let combined = [
                        ...(rawData.spotify_artist_genres || []).map(g => ({ name: g, source: 'spotify' })),
                        ...(rawData.lastfm_track_genres || []).map(g => ({ name: g, source: 'lastfm_track' })),
                        ...(rawData.lastfm_artist_genres || []).map(g => ({ name: g, source: 'lastfm_artist' })),
                        ...(rawData.deezer_genres || []).map(g => ({ name: g, source: 'deezer' })),
                        ...(rawData.apple_music_genres || []).map(g => ({ name: g, source: 'apple_music' }))
                    ];

                    let uniqueSet = new Set();
                    if (groupGenres) {
                        const mapped = mapAndNormalizeGenres(combined);
                        mapped.forEach(g => uniqueSet.add(JSON.stringify(g))); 
                    } else {
                        combined.forEach(g => uniqueSet.add(JSON.stringify({ name: g.name.toLowerCase().trim(), source: g.source })));
                    }
                    
                    finalGenresForTrack = Array.from(uniqueSet).map(s => JSON.parse(s));
                }
                
                currentTrackGenreMap.set(track.uri, finalGenresForTrack);

                const trackArtist = uriToArtistMap.get(track.uri) || "";
                
                const genresCountedForTrack = new Set();

                finalGenresForTrack.forEach(gObj => {
                    const genreName = gObj.name;
                    const source = gObj.source;

                    if (!genreDetails.has(genreName)) {
                        const normalizedKey = getNormalizedGenreKey(genreName);
                        let isMapped = !!VARIANT_TO_MAIN_GENRE_MAP[normalizedKey] || !!VARIANT_TO_MAIN_COUNTRY_MAP[normalizedKey];
                        
                        if (!isMapped) {
                            isMapped = mainGenres.some(key => genreName.toLowerCase().includes(key.toLowerCase()));
                            if (!isMapped) {
                                isMapped = countryKeys.some(key => genreName.toLowerCase().includes(key.toLowerCase()));
                            }
                        }

                        genreDetails.set(genreName, {
                            name: genreName,
                            isTrusted: false,
                            count: 0,
                            artists: new Set(),
                            isMapped: isMapped,
                            isSelfTitle: false
                        });
                    }

                    const details = genreDetails.get(genreName);
                    
                    if (trackArtist) details.artists.add(trackArtist);
                    if (source === 'spotify' || source === 'deezer' || source === 'apple_music') details.isTrusted = true;
                    if (trackArtist && genreName.toLowerCase() === trackArtist) details.isSelfTitle = true;

                    if (!genresCountedForTrack.has(genreName)) {
                        genreCounts.set(genreName, (genreCounts.get(genreName) || 0) + 1);
                        details.count++;
                        genresCountedForTrack.add(genreName);
                    }
                });
            });

            detectedGenres = Array.from(genreCounts.keys()).sort((a, b) => {
                const detailsA = genreDetails.get(a) || { count: 0, isTrusted: false, artists: new Set(), isMapped: false };
                const detailsB = genreDetails.get(b) || { count: 0, isTrusted: false, artists: new Set(), isMapped: false };

                const getTier = (details) => {
                    if (details.isTrusted) return 1;
                    if (details.isMapped) return 1;
                    if (details.isSelfTitle) return 2;
                    if (details.name.length < 2) return 2;
                    if (details.artists.size >= 3) return 1;
                    if (details.count >= 15 && details.artists.size >= 2) return 1;
                    if (totalUniqueArtistsInPlaylist < 3) {
                        const threshold = Math.min(4, Math.max(2, Math.ceil(scannedTracks.length * 0.05)));
                        if (details.count >= threshold) return 1;
                    }
                    return 2;
                };

                const tierA = getTier(detailsA);
                const tierB = getTier(detailsB);

                if (tierA !== tierB) return tierA - tierB;
                if (detailsB.count !== detailsA.count) return detailsB.count - detailsA.count;
                if (detailsA.isTrusted && !detailsB.isTrusted) return -1;
                if (!detailsA.isTrusted && detailsB.isTrusted) return 1;

                return a.localeCompare(b);
            });
            
            if (onScanComplete) {
                onScanComplete(detectedGenres);
            }
            
            renderGenres();
            updateStats();
        };

        modalContainer.innerHTML = `
            <style>
                .modal-header { padding: 24px 32px 16px; border-bottom: 1px solid #282828; display: flex; justify-content: space-between; align-items: center; }
                .modal-title { font-size: 24px; font-weight: 700; color: white; }
                .scan-banner { background-color: #2a2a2a; padding: 12px 24px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #333; transition: opacity 0.3s ease; }
                .scan-text { color: #b3b3b3; font-size: 14px; }
                .scan-btn { background-color: #1ED760; color: black; border: none; padding: 6px 16px; border-radius: 20px; font-weight: 600; font-size: 13px; cursor: pointer; transition: background-color 0.1s; }
                .scan-btn:hover { background-color: #3BE377; }
                .scan-btn:disabled { background-color: #555; color: #888; cursor: default; }
                .modal-content { padding: 20px 32px; flex-grow: 1; overflow: hidden; display: flex; flex-direction: column; }
                .search-container { position: relative; margin-bottom: 16px; }
                .search-bar { width: 100%; padding: 10px 16px; background-color: #333; border: 1px solid #333; border-radius: 8px; color: white; font-size: 14px; box-sizing: border-box; }
                .search-bar:focus { border-color: #555; outline: none; }
                .settings-row { display: flex; gap: 20px; margin-bottom: 16px; align-items: center; }
                .switch-label { color: #ccc; font-size: 14px; display: flex; align-items: center; gap: 8px; cursor: pointer; }
                .switch { position: relative; display: inline-block; width: 36px; height: 20px; }
                .switch input { opacity: 0; width: 0; height: 0; }
                .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #484848; transition: .2s; border-radius: 20px; }
                .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .2s; border-radius: 50%; }
                input:checked + .slider { background-color: #1ED760; }
                input:checked + .slider:before { transform: translateX(16px); }
                .genre-list-container { flex-grow: 1; overflow-y: auto; padding-right: 8px; scrollbar-width: thin; scrollbar-color: #555 transparent; }
                .genre-list-container::-webkit-scrollbar { width: 8px; }
                .genre-list-container::-webkit-scrollbar-thumb { background-color: #555; border-radius: 4px; }
                .genre-section-title { color: #888; font-size: 12px; font-weight: 700; text-transform: uppercase; margin: 16px 0 8px; letter-spacing: 0.5px; }
                .genre-group { display: flex; flex-wrap: wrap; gap: 8px; }
                .genre-button { background-color: #333; color: #ddd; padding: 6px 12px; border-radius: 16px; border: none; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: all 0.1s; }
                .genre-button.selected { background-color: #1ED760; color: black; }
                .genre-button.excluded { background-color: #a92121; color: white; }
                .genre-button.has-count { padding: 4px 6px 4px 10px; }
                .genre-count-badge { background-color: rgba(255, 255, 255, 0.1); color: #e0e0e0; padding: 3px 9px; border-radius: 12px; font-size: 12px; font-weight: 400; min-width: 16px; text-align: center; }
                .genre-button.selected .genre-count-badge { background-color: rgba(0, 0, 0, 0.2); color: #000; }
                .genre-button.excluded .genre-count-badge { background-color: rgba(255, 255, 255, 0.2); color: #fff; }
                .detected-badge { font-size: 8px; color: #1ED760; }
                .modal-footer { padding: 16px 32px; border-top: 1px solid #282828; display: flex; justify-content: space-between; align-items: center; }
                .genre-stats-footer { display: flex; gap: 20px; }
                .footer-buttons { display: flex; gap: 12px; }
                .stat-item { color: #b3b3b3; font-size: 14px; }
                .btn-secondary { background: transparent; border: 1px solid #666; color: white; padding: 8px 20px; border-radius: 20px; font-weight: 600; cursor: pointer; }
                .btn-secondary:hover { border-color: white; }
                .btn-primary { background-color: #1ED760; border: none; color: black; padding: 8px 24px; border-radius: 20px; font-weight: 600; cursor: pointer; }
                .btn-primary:hover { background-color: #3BE377; }
                .no-results { color: #666; font-style: italic; font-size: 13px; width: 100%; text-align: center; padding: 10px; }
                .tooltip-container { position: relative; display: inline-block; vertical-align: middle; }
                .custom-tooltip { visibility: hidden; position: absolute; z-index: 10000; background-color: #373737; color: white; padding: 8px 12px; border-radius: 4px; font-size: 14px; max-width: 240px; width: max-content; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); line-height: 1.4; word-wrap: break-word; text-align: left; pointer-events: none; }
                .custom-tooltip::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #373737 transparent transparent transparent; }
                .tooltip-container:hover .custom-tooltip { visibility: visible; }
            </style>
            <div class="modal-header">
                <span class="modal-title">Genre Filter</span>
                <button class="main-trackCreditsModal-closeBtn" id="close-modal-btn">
                    <svg width="18" height="18" viewBox="0 0 32 32" fill="currentColor"><path d="M31.098 29.794L16.955 15.65 31.097 1.51 29.683.093 15.54 14.237 1.4.094-.016 1.508 14.126 15.65-.016 29.795l1.414 1.414L15.54 17.065l14.144 14.143"></path></svg>
                </button>
            </div>
            <div class="scan-banner" style="${isScanned ? 'display: none;' : ''}">
            <span class="scan-text" id="scan-status-text">${detectedGenres.length > 0 ? "Showing saved genres. Scan sources to update counts." : "Showing common genres. Click 'Scan Sources' to see actual genres from your sources."}</span>
                <button class="scan-btn" id="scan-sources-btn">Scan Sources</button>
            </div>
            <div class="modal-content">
                <div style="margin-bottom: 8px; font-size: 13px; color: #b3b3b3;">ðŸ’¡ Left-click to include â€¢ Right-click to exclude</div>
                <div class="search-container">
                    <input type="text" class="search-bar" placeholder="Search genres...">
                </div>
                <div class="settings-row">
                    <label class="switch-label">
                        <div class="switch"><input type="checkbox" id="match-all-toggle" ${matchAllGenres ? 'checked' : ''}><span class="slider"></span></div>
                        Match All Selected
                        <span class="tooltip-container">
                            ${infoIconSvg}
                            <span class="custom-tooltip">Only include tracks matching all selected genres.</span>
                        </span>
                    </label>
                    <label class="switch-label">
                        <div class="switch"><input type="checkbox" id="group-genres-toggle" ${groupGenres ? 'checked' : ''}><span class="slider"></span></div>
                        Group Similar Genres
                        <span class="tooltip-container">
                            ${infoIconSvg}
                            <span class="custom-tooltip">Enable to group similar genres (e.g. 'electro' -> 'electronic'). Disable to see raw tags.</span>
                        </span>
                    </label>
                </div>
                <div class="genre-list-container"></div>
            </div>
            <div class="modal-footer">
                <div class="genre-stats-footer"></div>
                <div class="footer-buttons">
                    <button class="btn-secondary" id="cancel-btn">Cancel</button>
                    <button class="btn-primary" id="save-btn">Save Filter</button>
                </div>
            </div>
        `;

        document.body.appendChild(overlay);
        overlay.appendChild(modalContainer);

        renderGenres();

        const scanBtn = modalContainer.querySelector('#scan-sources-btn');
        const statusText = modalContainer.querySelector('#scan-status-text');
        const scanBanner = modalContainer.querySelector('.scan-banner');
        
        const runScan = async (preFetchedTracks = null) => {
            if (isScanned && !preFetchedTracks) return;
            scanBtn.disabled = true;
            statusText.textContent = "Fetching tracks from sources...";
            
            try {
                let allTracks = preFetchedTracks;
                if (!allTracks) {
                    const trackFetchPromises = sources.map(async source => {
                        const sourceUri = source.uri;
                        let sourceTracks;
                        if (URI.isPlaylistV1OrV2(sourceUri)) {
                            sourceTracks = await getPlaylistTracks(sourceUri.split(":")[2]);
                        } else if (URI.isArtist(sourceUri)) {
                            sourceTracks = await getArtistTracks(sourceUri, true);
                        } else if (isLikedSongsPage(sourceUri)) {
                            sourceTracks = await getLikedSongs();
                        } else if (URI.isAlbum(sourceUri)) {
                            sourceTracks = await getAlbumTracks(sourceUri.split(":")[2]);
                        }
                        return sourceTracks ? sourceTracks.filter(track => !Spicetify.URI.isLocal(track.uri)) : [];
                    });

                    const trackArrays = await Promise.all(trackFetchPromises);
                    allTracks = trackArrays.flat();
                }
                
                if (allTracks.length === 0) {
                    statusText.textContent = "No tracks found in sources.";
                    scanBtn.disabled = false;
                    return;
                }

                let genresReady = false;

                await fetchAllTrackGenres(
                    allTracks,
                    (progress) => {
                        if (!genresReady) {
                            statusText.textContent = `Scanning genres: ${progress}`;
                        }
                    },
                    (result) => {
                        genresReady = true;
                        isScanned = true;
                        lastScanResult = result.rawTrackGenres;
                        scannedTracks = allTracks;
                        
                        processRawGenres(lastScanResult);
                        scanBanner.style.display = 'none';
                    }
                );

            } catch (error) {
                console.error("Genre scan failed:", error);
                statusText.textContent = "Scan failed. Check console for details.";
                scanBtn.disabled = false;
            }
        };

        scanBtn.addEventListener('click', () => runScan());

        if (!isScanned) {
            (async () => {
                try {
                    const trackFetchPromises = sources.map(async source => {
                        const sourceUri = source.uri;
                        if (URI.isPlaylistV1OrV2(sourceUri)) {
                            return await getPlaylistTracks(sourceUri.split(":")[2]);
                        } else if (URI.isArtist(sourceUri)) {
                            return await getArtistTracks(sourceUri, true);
                        } else if (isLikedSongsPage(sourceUri)) {
                            return await getLikedSongs();
                        } else if (URI.isAlbum(sourceUri)) {
                            return await getAlbumTracks(sourceUri.split(":")[2]);
                        }
                        return [];
                    });

                    const trackArrays = await Promise.all(trackFetchPromises);
                    const allTracks = trackArrays.flat().filter(track => !Spicetify.URI.isLocal(track.uri));

                    if (allTracks.length > 0) {
                        let cachedCount = 0;
                        allTracks.forEach(t => {
                            if (sessionGenreCache.has(t.uri)) cachedCount++;
                        });

                        if (cachedCount > 0 && (cachedCount / allTracks.length) > 0.8) {
                            runScan(allTracks);
                        }
                    }
                } catch(e) {
                    console.warn("Auto-scan check failed", e);
                }
            })();
        }

        modalContainer.querySelector('.search-bar').addEventListener('input', renderGenres);
        
        modalContainer.querySelector('#match-all-toggle').addEventListener('change', (e) => {
            matchAllGenres = e.target.checked;
            updateStats();
        });

        modalContainer.querySelector('#group-genres-toggle').addEventListener('change', (e) => {
            groupGenres = e.target.checked;
            if (lastScanResult) {
                processRawGenres(lastScanResult);
            } else {
                if (groupGenres) {
                    selectedGenres = normalizeList(selectedGenres);
                    excludedGenres = normalizeList(excludedGenres);
                    detectedGenres = normalizeList(rawDetectedGenres);
                } else {
                    detectedGenres = [...rawDetectedGenres];
                }
                renderGenres();
                updateStats();
            }
        });

        const closeModal = (data) => {
            overlay.remove();
            resolve(data);
        };

        modalContainer.querySelector('#save-btn').addEventListener('click', () => {
            closeModal({
                selectedGenres,
                excludedGenres,
                matchAllGenres,
                groupGenres,
                detectedGenres: rawDetectedGenres
            });
        });

        modalContainer.querySelector('#cancel-btn').addEventListener('click', () => closeModal(null));
        modalContainer.querySelector('#close-modal-btn').addEventListener('click', () => closeModal(null));
        overlay.addEventListener('click', (e) => { if(e.target === overlay) closeModal(null); });
    });
  }
  
  async function showDynamicFilterModal(currentFilters) {
    return new Promise((resolve) => {
        const lastFmUsername = loadLastFmUsername();
        const isExcludeListenedDisabled = !lastFmUsername;
        let titleAlbumKeywords = new Set();
        let artistKeywords = new Set();
        let keepMatchingMode, filterTitle, filterAlbum, filterArtist, matchWholeWord;
        
        let likedFilterMode = currentFilters.likedFilter || (currentFilters.excludeLiked ? 'exclude' : 'all');
        let scrobbleFilterMode = currentFilters.scrobbleFilter || (currentFilters.excludeListened ? 'exclude' : 'all');

        const overlay = document.createElement("div");
        overlay.id = "filter-overlay";
        overlay.className = "sort-play-font-scope";
        overlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); z-index: 2006;
            display: flex; justify-content: center; align-items: center;
        `;

        const modalContainer = document.createElement("div");
        modalContainer.className = "main-embedWidgetGenerator-container";
        modalContainer.style.zIndex = "2007";
        modalContainer.style.width = "650px";
        modalContainer.style.backgroundColor = "#181818";
        modalContainer.style.borderRadius = "25px";
        modalContainer.style.border = "2px solid #282828";

        modalContainer.innerHTML = `
          <style>
            .main-trackCreditsModal-mainSection { padding: 20px 32px !important; overflow: hidden; }
            #filter-overlay .settings-left-wrapper { background-color: #1c1c1c; border-radius: 20px; padding: 20px; position: relative; margin-top: 20px; }
            #filter-overlay .settings-left-wrapper.disabled > *:not(.settings-title-wrapper) { opacity: 0.5; pointer-events: none; }
            #filter-overlay .settings-left-wrapper.disabled .settings-title-wrapper { opacity: 1; pointer-events: all; }
            #filter-overlay .settings-left-wrapper.disabled #keywordFilterToggle { pointer-events: all; }
            #filter-overlay .settings-title { color: white; font-weight: bold; font-size: 15px; margin-bottom: 5px; }
            #filter-overlay .settings-title-wrapper { display: flex; justify-content: space-between; width: 100%; margin-bottom: 8px; }
            #filter-overlay .filter-mode-radio-group { display: flex; align-items: center; gap: 16px; margin: 10px 0; }
            #filter-overlay .radio-button-container { display: flex; align-items: center; gap: 8px; cursor: pointer; }
            #filter-overlay .radio-button { width: 16px; height: 16px; border: 2px solid #b3b3b3; border-radius: 50%; display: flex; padding: 2px; }
            #filter-overlay .radio-button input { display: none; }
            #filter-overlay .radio-button-inner { width: 8px; height: 8px; background-color: #1DB954; border-radius: 50%; display: none; }
            #filter-overlay .radio-button input:checked + .radio-button-inner { display: block; }
            #filter-overlay .radio-label { color: #b3b3b3; font-size: 13px; }
            #filter-overlay .radio-button-container:hover .radio-button, #filter-overlay .radio-button-container:hover .radio-label { color: #ffffff; border-color: #ffffff; }
            #filter-overlay .keyword-filter-container { display: flex; gap: 15px; width: 100%; }
            #filter-overlay .filter-group { flex: 1; display: flex; flex-direction: column; gap: 12px; }
            #filter-overlay .filter-group-header { display: flex; align-items: center; gap: 8px; height: 20px; justify-content: space-between; }
            #filter-overlay .filter-group-title { color: #fff; font-size: 13px; font-weight: 500; }
            #filter-overlay .toggle-group { display: flex; gap: 5px; align-items: center; }
            #filter-overlay .filter-mode-toggle-label { color: #b3b3b3; font-size: 13px; }
            #filter-overlay .keyword-input-container { position: relative; display: flex; flex-direction: column; background: #282828; border-radius: 6px; min-height: 96px; max-height: 96px; width: 100%; }
            #filter-overlay .keyword-tags-container { display: flex; flex-wrap: wrap; gap: 4px; padding: 6px; overflow-y: auto; flex-grow: 1; scrollbar-width: thin; scrollbar-color: #ffffff40 transparent; }
            #filter-overlay .keyword-input-wrapper { position: relative; padding: 3px; border-top: 1px solid #444; background: #313131; border-bottom-left-radius: 6px; border-bottom-right-radius: 6px; display: flex; align-items: center; }
            #filter-overlay .keyword-input { background: none; border: none; color: white; padding: 4px; width: 100%; height: 24px; margin: 0; flex: 1; min-width: 0; }
            #filter-overlay .keyword-input:focus { outline: none; }
            #filter-overlay .keyword-actions-container { display: flex; margin-left: auto; flex-shrink: 0; }
            #filter-overlay .keyword-action-button { background-color: transparent; border: none; color: white; padding: 2px 7px; border-radius: 12px; font-size: 12px; cursor: pointer; transition: background-color: 0.2s ease; height: 24px; white-space: nowrap; }
            #filter-overlay .keyword-action-button:hover { background-color: #484848; }
            #filter-overlay .keyword-action-button svg { width: 14px; height: 14px; fill: #fff; display: block; margin: 0 auto; }
            #filter-overlay .keyword-tag { display: inline-flex; align-items: center; background: #383838; border-radius: 12px; padding: 2px 8px; color: white; font-size: 12px; white-space: nowrap; flex-shrink: 0; height: 24px; }
            #filter-overlay .keyword-tag-remove { margin-left: 4px; cursor: pointer; color: #ccc; font-size: 14px; }
            #filter-overlay .setting-row { display: flex; justify-content: space-between; align-items: center; padding: 5px 0; }
            #filter-overlay .setting-row .description { color: #c1c1c1; }
            #filter-overlay .setting-row.disabled .description { opacity: 0.5; }
            #filter-overlay .tooltip-container { position: relative; display: inline-block; vertical-align: middle; }
            #filter-overlay .custom-tooltip { visibility: hidden; position: absolute; z-index: 2008; background-color: #373737; color: white; padding: 8px 12px; border-radius: 4px; font-size: 14px; max-width: 280px; width: max-content; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); line-height: 1.4; word-wrap: break-word; text-align: left; }
            #filter-overlay .custom-tooltip::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #373737 transparent transparent transparent; }
            #filter-overlay .tooltip-container:hover .custom-tooltip { visibility: visible; }
            #filter-overlay .switch { position: relative; display: inline-block; width: 40px; height: 24px; flex-shrink: 0; }
            #filter-overlay .switch input { opacity: 0; width: 0; height: 0; }
            #filter-overlay .sliderx { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #484848; border-radius: 24px; transition: .2s; }
            #filter-overlay .sliderx:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; border-radius: 50%; transition: .2s; }
            #filter-overlay input:checked + .sliderx { background-color: #1DB954; }
            #filter-overlay input:checked + .sliderx:before { transform: translateX(16px); }
            #filter-overlay .switch.disabled .sliderx, #filter-overlay input:disabled + .sliderx { opacity: 0.5; cursor: not-allowed; }
            #filter-overlay .main-buttons-button.main-button-primary { background-color: #1ED760; color: black; transition: background-color 0.1s ease;}
            #filter-overlay .main-buttons-button.main-button-primary:hover { background-color: #3BE377; }
            #filter-overlay .main-buttons-button.main-button-secondary { background-color: #333333; color: white; transition: background-color 0.1s ease; }
            #filter-overlay .main-buttons-button.main-button-secondary:hover { background-color: #444444; }
            
            #filter-overlay .segmented-control { 
                display: grid; 
                grid-template-columns: 55px 1fr 1fr; 
                background-color: #454545;
                border-radius: 4px; 
                padding: 1px;
                width: 290px; 
                gap: 1px;
            }
            
            #filter-overlay .segment-btn { 
                background: #282828; 
                border: none; 
                color: #b3b3b3; 
                padding: 4px 2px; 
                font-size: 12px; 
                font-weight: 400; 
                cursor: pointer; 
                border-radius: 0;
                transition: background-color 0.2s, color 0.2s;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
            }

            #filter-overlay .segment-btn:first-child {
                border-top-left-radius: 4px;
                border-bottom-left-radius: 4px;
            }

            #filter-overlay .segment-btn:last-child {
                border-top-right-radius: 4px;
                border-bottom-right-radius: 4px;
            }
            
            #filter-overlay .segment-btn:hover { 
                color: white; 
                background-color: #333; 
            }
            
            #filter-overlay .segment-btn.active { 
                background-color: #555; 
                color: white; 
                font-weight: 600; 
            }
            
            #filter-overlay .segment-btn.active[data-value="require"],
            #filter-overlay .segment-btn.active[data-value="exclude"] { 
                background-color: #1ED760; 
                color: black; 
            }
            
            #filter-overlay .setting-row.disabled .segmented-control { opacity: 0.5; pointer-events: none; }
          </style>
          <div class="main-trackCreditsModal-header">
              <h1 class="main-trackCreditsModal-title"><span style='font-size: 25px;'>Track Filtering Options</span></h1>
          </div>
          <div class="main-trackCreditsModal-mainSection">
              <div style="display: flex; flex-direction: column; gap: 16px;">
                  <div class="setting-row">
                      <span class="description">Liked Status</span>
                      <div class="segmented-control" id="liked-filter-control">
                          <button class="segment-btn ${likedFilterMode === 'all' ? 'active' : ''}" data-value="all" data-text="Any">Any</button>
                          <button class="segment-btn ${likedFilterMode === 'exclude' ? 'active' : ''}" data-value="exclude" data-text="Exclude Liked">Exclude Liked</button>
                          <button class="segment-btn ${likedFilterMode === 'require' ? 'active' : ''}" data-value="require" data-text="Only Liked">Only Liked</button>
                      </div>
                  </div>
                  <div class="setting-row ${isExcludeListenedDisabled ? 'disabled' : ''}">
                      <span class="description">
                          Scrobble History
                          <span class="tooltip-container">
                              ${infoIconSvg}
                              <span class="custom-tooltip">Requires Last.fm. ${isExcludeListenedDisabled ? '(Set Last.fm username in settings)' : ''}</span>
                          </span>
                      </span>
                      <div class="segmented-control" id="scrobble-filter-control">
                          <button class="segment-btn ${scrobbleFilterMode === 'all' ? 'active' : ''}" data-value="all" data-text="Any">Any</button>
                          <button class="segment-btn ${scrobbleFilterMode === 'exclude' ? 'active' : ''}" data-value="exclude" data-text="Exclude Played">Exclude Played</button>
                          <button class="segment-btn ${scrobbleFilterMode === 'require' ? 'active' : ''}" data-value="require" data-text="Only Played">Only Played</button>
                      </div>
                  </div>
                  <div class="setting-row">
                      <span class="description">
                          Max Play Count
                          <span class="tooltip-container">
                              ${infoIconSvg}
                              <span class="custom-tooltip">Only include tracks with a play count less than or equal to this value. Leave blank to disable.</span>
                          </span>
                      </span>
                      <input type="number" id="filter-max-playcount" placeholder="e.g., 10000" min="1000" step="1000" style="width: 150px; padding: 6px; border-radius: 4px; border: 1px solid #666; background-color: #282828; color: white; text-align: center;">
                  </div>
              </div>

              <div class="settings-left-wrapper">
                  <div class="settings-title-wrapper">
                      <div class="settings-title">Keyword Filters</div>
                      <label class="switch"><input type="checkbox" id="keywordFilterToggle"><span class="sliderx"></span></label>
                  </div>
                  <div class="filter-mode-container" style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 10px;">
                      <div class="filter-mode-radio-group">
                          <div class="filter-mode-title" style="color: #fff; font-size: 13px; font-weight: 500; margin-right: 8px;">Filter Mode:</div>
                          <label class="radio-button-container"><span class="radio-button"><input type="radio" name="filterMode" value="exclude"><span class="radio-button-inner"></span></span><span class="radio-label">Exclude</span></label>
                          <label class="radio-button-container"><span class="radio-button"><input type="radio" name="filterMode" value="keep"><span class="radio-button-inner"></span></span><span class="radio-label">Keep</span></label>
                          <span class="filter-mode-title" style="color: #fff; font-size: 13px; font-weight: 500; margin-left: 14px;">Match Whole Word:</span>
                      </div>
                      <label class="switch"><input type="checkbox" id="matchWholeWordToggle"><span class="sliderx"></span></label>
                  </div>
                  <div class="keyword-filter-container">
                      <div class="filter-group">
                          <div class="filter-group-header">
                              <span class="filter-group-title">Titles/Albums</span>
                              <div class="toggle-group">
                                  <span class="filter-mode-toggle-label">Title</span>
                                  <label class="switch"><input type="checkbox" id="titleToggle" checked><span class="sliderx"></span></label>
                                  <span class="filter-mode-toggle-label">Album</span>
                                  <label class="switch"><input type="checkbox" id="albumToggle" checked><span class="sliderx"></span></label>
                              </div>
                          </div>
                          <div class="keyword-input-container" id="titleAlbumKeywords">
                              <div class="keyword-tags-container"></div>
                              <div class="keyword-input-wrapper">
                                  <input type="text" class="keyword-input" placeholder="Add keywords...">
                                  <div class="keyword-actions-container">
                                      <button class="keyword-action-button keyword-save-button" title="Save Keywords">${saveIconSVG}</button>
                                      <button class="keyword-action-button keyword-load-button" title="Load Keywords">${loadIconSVG}</button>
                                      <button class="keyword-action-button keyword-remove-all-button" title="Clear Keywords">${clearIconSVG}</button>
                                  </div>
                              </div>
                          </div>
                      </div>
                      <div class="filter-group">
                          <div class="filter-group-header">
                              <span class="filter-group-title">Artists</span>
                              <div class="toggle-group">
                                  <label class="switch"><input type="checkbox" id="artistToggle" checked><span class="sliderx"></span></label>
                              </div>
                          </div>
                          <div class="keyword-input-container" id="artistKeywords">
                              <div class="keyword-tags-container"></div>
                              <div class="keyword-input-wrapper"><input type="text" class="keyword-input" placeholder="Add keywords..."></div>
                          </div>
                      </div>
                  </div>
              </div>
              <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 24px;">
                  <button id="cancel-filters" class="main-buttons-button main-button-secondary" style="padding: 8px 18px; border-radius: 20px; font-weight: 550; font-size: 13px; text-transform: uppercase; cursor: pointer; border: none;">Cancel</button>
                  <button id="save-filters" class="main-buttons-button main-button-primary" style="padding: 8px 18px; border-radius: 20px; font-weight: 550; font-size: 13px; text-transform: uppercase; cursor: pointer; border: none;">Save</button>
              </div>
          </div>
        `;
        
        document.body.appendChild(overlay);
        overlay.appendChild(modalContainer);

        const closeModal = (data) => {
            overlay.remove();
            resolve(data);
        };

        const keywordFilterWrapper = modalContainer.querySelector('.settings-left-wrapper');
        const keywordFilterToggle = modalContainer.querySelector("#keywordFilterToggle");
        const filterModeRadios = modalContainer.querySelectorAll('input[name="filterMode"]');
        const titleToggle = modalContainer.querySelector("#titleToggle");
        const albumToggle = modalContainer.querySelector("#albumToggle");
        const artistToggle = modalContainer.querySelector("#artistToggle");
        const matchWholeWordToggle = modalContainer.querySelector("#matchWholeWordToggle");
        const titleAlbumContainer = modalContainer.querySelector("#titleAlbumKeywords");
        const artistContainer = modalContainer.querySelector("#artistKeywords");

        const setupSegmentedControl = (controlId, updateVar) => {
            const control = modalContainer.querySelector(`#${controlId}`);
            if (!control) return;
            control.querySelectorAll('.segment-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    control.querySelectorAll('.segment-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    updateVar(btn.dataset.value);
                });
            });
        };

        setupSegmentedControl('liked-filter-control', (val) => { likedFilterMode = val; });
        setupSegmentedControl('scrobble-filter-control', (val) => { scrobbleFilterMode = val; });

        document.getElementById('filter-max-playcount').value = currentFilters.maxPlayCount || '';
        keywordFilterToggle.checked = currentFilters.keywordFilterEnabled || false;
        keywordFilterWrapper.classList.toggle('disabled', !keywordFilterToggle.checked);

        keepMatchingMode = currentFilters.keepMatchingMode ?? false;
        filterTitle = currentFilters.filterTitle ?? (localStorage.getItem("sort-play-filter-title") !== "false");
        filterAlbum = currentFilters.filterAlbum ?? (localStorage.getItem("sort-play-filter-album") !== "false");
        filterArtist = currentFilters.filterArtist ?? (localStorage.getItem("sort-play-filter-artist") !== "false");
        matchWholeWord = currentFilters.matchWholeWord ?? (localStorage.getItem("sort-play-match-whole-word") === "true");
        
        filterModeRadios.forEach(radio => radio.checked = (keepMatchingMode && radio.value === "keep") || (!keepMatchingMode && radio.value === "exclude"));
        titleToggle.checked = filterTitle;
        albumToggle.checked = filterAlbum;
        artistToggle.checked = filterArtist;
        matchWholeWordToggle.checked = matchWholeWord;

        const loadedKeywords = loadKeywords();
        titleAlbumKeywords = currentFilters.titleAlbumKeywords ? new Set(currentFilters.titleAlbumKeywords) : loadedKeywords.titleAlbumKeywords;
        artistKeywords = currentFilters.artistKeywords ? new Set(currentFilters.artistKeywords) : loadedKeywords.artistKeywords;
        
        if(titleAlbumContainer) titleAlbumContainer.querySelector(".keyword-tags-container").innerHTML = "";
        if(artistContainer) artistContainer.querySelector(".keyword-tags-container").innerHTML = "";

        titleAlbumKeywords.forEach(keyword => createKeywordTag(keyword, titleAlbumContainer, titleAlbumKeywords));
        artistKeywords.forEach(keyword => createKeywordTag(keyword, artistContainer, artistKeywords));

        setupKeywordInput(titleAlbumContainer, titleAlbumKeywords);
        setupKeywordInput(artistContainer, artistKeywords);

        keywordFilterToggle.addEventListener('change', (e) => keywordFilterWrapper.classList.toggle('disabled', !e.target.checked));
        filterModeRadios.forEach(radio => radio.addEventListener("change", (e) => keepMatchingMode = e.target.value === "keep"));
        titleToggle.addEventListener('change', e => filterTitle = e.target.checked);
        albumToggle.addEventListener('change', e => filterAlbum = e.target.checked);
        artistToggle.addEventListener('change', e => filterArtist = e.target.checked);
        matchWholeWordToggle.addEventListener('change', e => matchWholeWord = e.target.checked);
        
        modalContainer.querySelector('#save-filters').addEventListener('click', () => {
            saveKeywords(titleAlbumKeywords, artistKeywords);
            localStorage.setItem("sort-play-filter-title", filterTitle);
            localStorage.setItem("sort-play-filter-album", filterAlbum);
            localStorage.setItem("sort-play-filter-artist", filterArtist);
            localStorage.setItem("sort-play-match-whole-word", matchWholeWord);

            const newFilters = {
                likedFilter: likedFilterMode,
                scrobbleFilter: scrobbleFilterMode,
                maxPlayCount: modalContainer.querySelector('#filter-max-playcount').value,
                keywordFilterEnabled: modalContainer.querySelector('#keywordFilterToggle').checked,
                keepMatchingMode,
                filterTitle,
                filterAlbum,
                filterArtist,
                matchWholeWord,
                titleAlbumKeywords: Array.from(titleAlbumKeywords),
                artistKeywords: Array.from(artistKeywords),
            };
            closeModal(newFilters);
        });

        modalContainer.querySelector('#cancel-filters').addEventListener('click', () => closeModal(null));
        overlay.addEventListener("click", (e) => { 
            if (e.target === overlay) {
                closeModal(null);
            }
        });
    });
  }

  function showDynamicPlaylistsWindow() {
    const existingModal = document.getElementById('sort-play-dynamic-playlist-modal');
    if (existingModal) existingModal.remove();

    let userLibraryPromise = null;

    const overlay = document.createElement("div");
    overlay.id = "sort-play-dynamic-playlist-modal";
    overlay.className = "sort-play-font-scope";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        z-index: 2002; display: flex; justify-content: center; align-items: center;
        opacity: 0; transition: opacity 0.2s ease;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container";
    modalContainer.style.cssText = `
        width: 900px !important; display: flex; flex-direction: column;
        border-radius: 30px; background-color: #181818 !important; border: 2px solid #282828;
    `;
    const shadowRoot = modalContainer.attachShadow({ mode: 'open' });
    modalContainer.querySelector = (sel) => shadowRoot.querySelector(sel);
    modalContainer.querySelectorAll = (sel) => shadowRoot.querySelectorAll(sel);

    const closeModal = () => {
        overlay.style.opacity = "0";
        setTimeout(() => overlay.remove(), 200);
    };
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            e.preventDefault();
            e.stopPropagation();
        }
    });

    const penIconSvg = `<svg width="16px" height="16px" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="M2.25,12.9378906 L2.25,15.75 L5.06210943,15.75 L13.3559575,7.45615192 L10.5438481,4.64404249 L2.25,12.9378906 L2.25,12.9378906 L2.25,12.9378906 Z M15.5306555,5.28145396 C15.8231148,4.98899458 15.8231148,4.5165602 15.5306555,4.22410082 L13.7758992,2.46934454 C13.4834398,2.17688515 13.0110054,2.17688515 12.718546,2.46934454 L11.3462366,3.84165394 L14.1583461,6.65376337 L15.5306555,5.28145396 L15.5306555,5.28145396 L15.5306555,5.28145396 Z"></path></svg>`;

    const formatTimeAgo = (timestamp) => {
        if (!timestamp) return 'Never';
        const seconds = Math.floor((new Date() - new Date(timestamp)) / 1000);
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + " years ago";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + " months ago";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + " days ago";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + " hours ago";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + " minutes ago";
        return "Just now";
    };

    const renderJobList = () => {
        const jobs = getJobs();
        const scheduleMap = {
            10800000: 'Every 3 Hours', 21600000: 'Every 6 Hours',
            86400000: 'Daily', 604800000: 'Weekly', 2592000000: 'Monthly',
            'release-weekly': 'Weekly (on Friday)',
            'release-every-two-weeks': 'Every Two Weeks (on Friday)',
            'release-monthly': 'Monthly (on a Friday)',
            'manual': 'Manual Only'
        };
        const customSchedules = getCustomSchedules();
        customSchedules.forEach(schedule => {
            scheduleMap[schedule.value] = schedule.text;
        });

        const sortByParent = buttonStyles.menuItems.find(i => i.sortType === 'sortByParent');
        const allSortOptions = sortByParent.children.flatMap(opt => (opt.type === 'parent' && opt.children) ? opt.children : opt);
        const sortTypeMap = allSortOptions.reduce((acc, item) => {
            if (item.sortType) {
                acc[item.sortType] = item.text;
            }
            return acc;
        }, {});

        let jobsHtml = jobs.map(job => `
            <div class="job-item ${job.isDeleted ? 'deleted' : ''}" data-job-id="${job.id}">
            <div class="job-cover-art-container">
                <img 
                    src="${job.coverUrl || ''}" 
                    alt="${job.targetPlaylistName || job.sourceName}" 
                    style="visibility: hidden;" 
                    onerror="this.remove()"
                >
            </div>
                <div class="job-details">
                    <span class="job-source-name" title="${job.targetPlaylistName || job.sourceName}">${job.targetPlaylistName || job.sourceName}</span>
                    <span class="job-info">${sortTypeMap[job.sortType] || 'Unknown Sort'} &bull; ${scheduleMap[job.schedule] || 'Custom'}</span>
                    <div class="job-status-line">
                        <span class="job-last-run">Last run: ${formatTimeAgo(job.lastRun)}</span>
                        <span class="job-deleted-status">${job.isDeleted ? 'â€¢ Playlist not in library' : ''}</span>
                    </div>
                </div>
                <div class="job-actions">
                    <button class="job-action-btn job-run-btn" data-job-id="${job.id}" title="Run Now" ${runningJobIds.has(job.id) ? 'disabled' : ''}>&#x25B6;</button>
                    <button class="job-action-btn job-edit-btn" data-job-id="${job.id}" title="Edit Job">${penIconSvg}</button>
                    <button class="job-action-btn job-delete-btn" data-job-id="${job.id}" title="Delete Job">
                        <svg width="13" height="13" viewBox="0 0 16 16" fill="currentColor"><path d="M.293.293a1 1 0 0 1 1.414 0L8 6.586 14.293.293a1 1 0 1 1 1.414 1.414L9.414 8l6.293 6.293a1 1 0 0 1-1.414 1.414L8 9.414l-6.293 6.293a1 1 0 0 1-1.414-1.414L6.586 8 .293 1.707a1 1 0 0 1 0-1.414z"></path></svg>
                    </button>
                </div>
            </div>
        `).join('');

        if (jobs.length === 0) {
            jobsHtml = `<div class="no-jobs-message">No dynamic playlists scheduled.</div>`;
        }

        shadowRoot.innerHTML = `
            <style>
                :host { font-family: 'SpotifyMixUI', sans-serif !important; color: #fff; font-size: 16px; font-weight: 400; }
                *, button, input, select, textarea { box-sizing: border-box; font-family: 'SpotifyMixUI', sans-serif !important; }
                h1 { margin: 0; line-height: normal; }
                .dynamic-playlist-modal .main-trackCreditsModal-mainSection { 
                    padding: 24px 32px 38px !important; 
                    max-height: 70vh; 
                    flex-grow: 1; 
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                }
                .dynamic-playlist-modal .job-list-header { 
                    display: flex; 
                    justify-content: flex-end; 
                    align-items: center; 
                    margin-bottom: 20px; 
                    flex-shrink: 0;
                }
                .dynamic-playlist-modal .job-list-container {
                    flex-grow: 1;
                    overflow-y: auto;
                    margin-right: -16px;
                    padding-right: 16px;
                    scrollbar-width: thin;
                    scrollbar-color: #535353 transparent;
                }
                .dynamic-playlist-modal .job-list-container::-webkit-scrollbar { width: 8px; }
                .dynamic-playlist-modal .job-list-container::-webkit-scrollbar-track { background: transparent; }
                .dynamic-playlist-modal .job-list-container::-webkit-scrollbar-thumb { background-color: #535353; border-radius: 4px; }
                .dynamic-playlist-modal .job-list { 
                    display: flex; 
                    flex-direction: column; 
                    gap: 10px; 
                }
                .dynamic-playlist-modal .job-item { 
                    display: flex; 
                    align-items: center; 
                    gap: 16px;
                    background-color: #282828; 
                    padding: 15px; 
                    border-radius: 8px; 
                    transition: background-color 0.2s; 
                }
                .dynamic-playlist-modal .job-item.deleted {
                    background-color: #431919;
                }
                .dynamic-playlist-modal .job-item.deleted:hover {
                    background-color: #5a2e2e;
                }
                .dynamic-playlist-modal .job-cover-art-container {
                    width: 70px;
                    height: 70px;
                    border-radius: 4px;
                    flex-shrink: 0;
                    background-color: #353535;
                    color: #b3b3b3;
                    background-image: ${PLACEHOLDER_SVG_DATA_URI};
                    background-size: 45%;
                    background-position: center;
                    background-repeat: no-repeat;
                }
                .dynamic-playlist-modal .job-cover-art-container img {
                    width: 100%;
                    height: 100%;
                    border-radius: 4px;
                    object-fit: cover;
                }
                .dynamic-playlist-modal .job-item:hover { 
                    background-color: #383838; 
                }
                .dynamic-playlist-modal .job-details { 
                    flex-grow: 1; 
                    display: flex; 
                    flex-direction: column; 
                    gap: 4px; 
                    overflow: hidden; 
                }
                .dynamic-playlist-modal .job-source-name { 
                    color: white; 
                    font-weight: 500; 
                    font-size: 16px; 
                    white-space: nowrap; 
                    overflow: hidden; 
                    text-overflow: ellipsis; 
                    max-width: 350px; 
                }
                .dynamic-playlist-modal .job-info, .job-last-run { 
                    color: #b3b3b3; 
                    font-size: 14px; 
                }
                .dynamic-playlist-modal .job-status-line {
                    display: flex;
                    align-items: center;
                }
                .dynamic-playlist-modal .job-deleted-status {
                    color: #ff8a8a;
                    font-weight: 500;
                    font-size: 14px;
                    margin-left: 3px;
                }
                .main-trackCreditsModal-closeBtn { 
                    background: transparent; 
                    border: 0; 
                    padding: 0; 
                    color: #b3b3b3; 
                    cursor: pointer; 
                    transition: color 0.2s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                .main-trackCreditsModal-closeBtn:hover { 
                    color: #ffffff; 
                }
                .dynamic-playlist-modal .job-actions {
                    display: flex;
                    flex-direction: column;
                    gap: 4px;
                    align-items: center;
                    justify-content: center;
                }
                .dynamic-playlist-modal .job-action-btn {
                    background: none;
                    border: none;
                    color: #b3b3b3;
                    cursor: pointer;
                    padding: 4px;
                    line-height: 1;
                    border-radius: 50%;
                    transition: background-color 0.2s, color 0.2s;
                    width: 24px;
                    height: 24px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                .dynamic-playlist-modal .job-action-btn:hover {
                    background-color: rgba(255,255,255,0.1);
                    color: white;
                }
                .dynamic-playlist-modal .job-action-btn:disabled {
                    opacity: 0.5;
                    color: #666;
                }
                .dynamic-playlist-modal .job-action-btn:disabled:hover {
                    background-color: transparent;
                    color: #666;
                }
                .dynamic-playlist-modal .job-run-btn {
                    font-size: 12px;
                }
                .dynamic-playlist-modal .no-jobs-message { 
                    color: #b3b3b3; 
                    text-align: center; 
                    padding: 20px; 
                }
                .dynamic-playlist-modal .main-trackCreditsModal-closeBtn { 
                    background: transparent; 
                    border: 0; 
                    padding: 0; 
                    color: #b3b3b3; 
                    cursor: pointer; 
                    transition: color 0.2s ease; 
                }
                .dynamic-playlist-modal .main-trackCreditsModal-closeBtn:hover { 
                    color: #ffffff; 
                }
                .dynamic-playlist-modal .main-button-primary {
                    background-color: #1ED760;
                    color: black;
                    padding: 8px 18px;
                    border-radius: 20px;
                    font-weight: 550;
                    font-size: 13px;
                    text-transform: uppercase;
                    border: none;
                    cursor: pointer;
                    transition: background-color 0.1s ease;
                }
                .dynamic-playlist-modal .main-button-primary:hover {
                    background-color: #3BE377;
                }
                @keyframes fadeIn { from { opacity: 0; transform: scale(0.99); } to { opacity: 1; transform: scale(1); } }
                .dynamic-playlist-modal { animation: fadeIn 0.2s ease; }
            </style>
            <div class="dynamic-playlist-modal">
                <div class="main-trackCreditsModal-header" style="border-bottom: 1px solid #282828; display: flex; justify-content: space-between; align-items: center; padding: 29px 32px 19px 32px;">
                    <h1 class="main-trackCreditsModal-title" style="font-size: 26px; font-weight: 700; color: white;">Dynamic Playlists (beta)</h1>
                    <button id="closeDynamicPlaylistModal" aria-label="Close" class="main-trackCreditsModal-closeBtn">
                        <svg width="18" height="18" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M31.098 29.794L16.955 15.65 31.097 1.51 29.683.093 15.54 14.237 1.4.094-.016 1.508 14.126 15.65-.016 29.795l1.414 1.414L15.54 17.065l14.144 14.143" fill="currentColor" fill-rule="evenodd"></path></svg>
                    </button>
                </div>
                <div class="main-trackCreditsModal-mainSection">
                    <div class="job-list-header">
                        <button id="create-new-job-btn" class="main-buttons-button main-button-primary">Create New</button>
                    </div>
                    <div class="job-list-container">
                        <div class="job-list">${jobsHtml}</div>
                    </div>
                </div>
            </div>
        `;

        const imageElements = modalContainer.querySelectorAll('.job-cover-art-container img');
        imageElements.forEach(img => {
            const showImage = () => {
                img.style.visibility = 'visible';
            };

            if (img.complete) {
                showImage();
            } else {
                img.addEventListener('load', showImage);
            }
        });
        
        modalContainer.querySelector('#closeDynamicPlaylistModal').addEventListener('click', closeModal);
        modalContainer.querySelector('#create-new-job-btn').addEventListener('click', () => {
            const content = modalContainer.shadowRoot.querySelector('.dynamic-playlist-modal');
            if (content) {
                content.style.transition = 'opacity 0.2s ease';
                content.style.opacity = '0';
                setTimeout(() => renderJobForm(), 200);
            } else {
                renderJobForm();
            }
        });
        
        modalContainer.querySelectorAll('.job-run-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                const jobId = e.currentTarget.dataset.jobId;
                const job = jobs.find(j => j.id === jobId);
                if (!job) return;
        
                runningJobIds.add(job.id);
                closeModal();
        
                showNotification(`Running job for "${job.targetPlaylistName}"...`);
        
                try {
                    const shouldUpdateSchedule = isJobDue(job, Date.now());
                    const updatedJob = await runJob(job, false, shouldUpdateSchedule);
                    updateJob(updatedJob);
                    showNotification(`Dynamic playlist "${job.targetPlaylistName}" was updated.`);
                } catch (error) {
                    showDetailedError(error, `Failed to manually run dynamic playlist job for "${job.targetPlaylistName}"`);
                } finally {
                    runningJobIds.delete(job.id);
                }
            });
        });

        modalContainer.querySelectorAll('.job-edit-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const jobId = e.currentTarget.dataset.jobId;
                const jobToEdit = jobs.find(j => j.id === jobId);
                if (jobToEdit) {
                    const content = modalContainer.shadowRoot.querySelector('.dynamic-playlist-modal');
                    if (content) {
                        content.style.transition = 'opacity 0.2s ease';
                        content.style.opacity = '0';
                        setTimeout(() => renderJobForm(jobToEdit), 200);
                    } else {
                        renderJobForm(jobToEdit);
                    }
                }
            });
        });

        modalContainer.querySelectorAll('.job-delete-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                const jobId = e.currentTarget.dataset.jobId;
                const job = jobs.find(j => j.id === jobId);
                if (!job) return;

                const confirmed = await showConfirmationModal({
                    title: "Delete Dynamic Playlist?",
                    description: `This will stop future updates for "${job.targetPlaylistName || job.sourceName}" but will NOT delete the created playlist. Are you sure?`,
                    confirmText: "Delete",
                    cancelText: "Cancel",
                });

                if (confirmed === 'confirm') {
                    deleteJob(jobId);
                    renderJobList();
                }
            });
        });

        (async () => {
            const rootlist = await Spicetify.Platform.RootlistAPI.getContents();
            
            function getAllPlaylistUris(items) {
                let uris = [];
                for (const item of items) {
                    if (item.type === 'playlist') {
                        uris.push(item.uri);
                    } else if (item.type === 'folder' && Array.isArray(item.items)) {
                        uris.push(...getAllPlaylistUris(item.items));
                    }
                }
                return uris;
            }
        
            const allPlaylistUris = getAllPlaylistUris(rootlist.items);
            const userPlaylistUris = new Set(allPlaylistUris);

            let jobsWereUpdated = false;
            const mutableJobs = JSON.parse(JSON.stringify(jobs)); 

            const updatePromises = mutableJobs.map(async (job) => {
                if (!job.targetPlaylistUri) return;

                const jobItemElement = modalContainer.querySelector(`.job-item[data-job-id="${job.id}"]`);

                if (!userPlaylistUris.has(job.targetPlaylistUri)) {
                    if (!job.isDeleted) {
                        job.isDeleted = true;
                        jobsWereUpdated = true;
                    }
                    if (jobItemElement && !jobItemElement.classList.contains('deleted')) {
                        jobItemElement.classList.add('deleted');
                        const deletedStatusElement = jobItemElement.querySelector('.job-deleted-status');
                        if (deletedStatusElement) {
                            deletedStatusElement.textContent = 'â€¢ Playlist not in library';
                        }
                    }
                    return;
                }

                try {
                    const playlistId = job.targetPlaylistUri.split(':')[2];
                    let playlistData = null;

                    const fetchMetaInternal = async () => {
                        const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(job.targetPlaylistUri);
                        return {
                            name: meta.name,
                            images: meta.images
                        };
                    };

                    if (isFallbackActive()) {
                        playlistData = await fetchMetaInternal();
                    } else {
                        try {
                            playlistData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${playlistId}`);
                        } catch (e) {
                            if (registerWebApiFailure()) {
                                playlistData = await fetchMetaInternal();
                            } else {
                                throw e;
                            }
                        }
                    }
                    
                    if (job.isDeleted) {
                        job.isDeleted = false;
                        jobsWereUpdated = true;
                        if (jobItemElement) {
                            jobItemElement.classList.remove('deleted');
                            const deletedStatusElement = jobItemElement.querySelector('.job-deleted-status');
                            if (deletedStatusElement) {
                                deletedStatusElement.textContent = '';
                            }
                            const lastRunElement = jobItemElement.querySelector('.job-last-run');
                            if (lastRunElement) {
                                lastRunElement.textContent = `Last run: ${formatTimeAgo(job.lastRun)}`;
                            }
                        }
                    }

                    const currentCoverUrl = playlistData.images?.length ? (playlistData.images[playlistData.images.length - 1] || playlistData.images[0]).url : null;
                    if (currentCoverUrl && (!job.coverUrl || currentCoverUrl !== job.coverUrl)) {
                        job.coverUrl = currentCoverUrl;
                        jobsWereUpdated = true;
                        const imgElement = jobItemElement.querySelector('.job-cover-art-container img');
                        if (imgElement) {
                            imgElement.style.visibility = 'hidden'; 
                            imgElement.src = currentCoverUrl;
                        }
                    }

                    const currentName = playlistData.name;
                    if (currentName && currentName !== job.targetPlaylistName) {
                        job.targetPlaylistName = currentName;
                        jobsWereUpdated = true;
                        const nameElement = jobItemElement.querySelector('.job-source-name');
                        if (nameElement) {
                            nameElement.textContent = currentName;
                            nameElement.title = currentName;
                        }
                    }
                } catch (error) {
                    console.warn(`[Sort-Play Dynamic] Could not verify details for "${job.sourceName}".`, error);
                }
            });

            await Promise.all(updatePromises);

            if (jobsWereUpdated) {
                saveJobs(mutableJobs);
            }
        })();
    };

    const renderJobForm = (jobToEdit = null) => {
        if (!userLibraryPromise) {
            userLibraryPromise = fetchUserLibrary();
        }
        
        const isEditing = !!jobToEdit;
        let jobFilters = isEditing ? (jobToEdit.filters || {}) : {};
        let sources = isEditing ? [...jobToEdit.sources] : [];

        let currentDeduplicate = isEditing ? jobToEdit.deduplicate : playlistDeduplicate;
        let currentUpdateFromSource = isEditing ? jobToEdit.updateFromSource : (localStorage.getItem(STORAGE_KEY_DYNAMIC_UPDATE_SOURCE) === null ? true : localStorage.getItem(STORAGE_KEY_DYNAMIC_UPDATE_SOURCE) === 'true');
        
        const savedSortType = localStorage.getItem(STORAGE_KEY_DYNAMIC_SORT_TYPE) || 'playCount';
        const savedSchedule = localStorage.getItem(STORAGE_KEY_DYNAMIC_SCHEDULE) || '86400000';

        const sortByParent = buttonStyles.menuItems.find(i => i.sortType === 'sortByParent');
        const shuffleItem = buttonStyles.menuItems.find(i => i.sortType === 'shuffle');
        
        const sortChildren = [...sortByParent.children];
        const releaseDateIndex = sortChildren.findIndex(item => item.sortType === 'releaseDate');
        
        if (releaseDateIndex !== -1) {
            sortChildren.splice(releaseDateIndex + 1, 0, shuffleItem);
        } else {
            sortChildren.push(shuffleItem);
        }

        const sortOptions = sortChildren.flatMap(opt => {
            if (opt.type === 'parent' && opt.children) {
                return opt.children.map(childOpt => 
                    `<option value="${childOpt.sortType}" ${ (isEditing ? jobToEdit.sortType : savedSortType) === childOpt.sortType ? 'selected' : ''}>${childOpt.text}</option>`
                );
            } else if (opt.sortType) {
                return [`<option value="${opt.sortType}" ${ (isEditing ? jobToEdit.sortType : savedSortType) === opt.sortType ? 'selected' : ''}>${opt.text}</option>`];
            }
            return [];
        }).join('');

        const customSchedules = getCustomSchedules();
        const customScheduleOptions = customSchedules.map(s => `<option value="${s.value}" ${ (isEditing ? String(jobToEdit.schedule) : savedSchedule) === String(s.value) ? 'selected' : ''}>${s.text}</option>`).join('');
        
        let clearAndSeparatorHtml = '';
        if (customSchedules.length > 0) {
            clearAndSeparatorHtml = `
                <option value="clear-custom" style="color: #f15e6c; font-style: italic;">Clear Custom Schedules...</option>
            `;
        }
        shadowRoot.innerHTML = `
            <style>
                :host { font-family: 'SpotifyMixUI', sans-serif !important; color: #fff; font-size: 16px; font-weight: 400; }
                *, button, input, select, textarea { box-sizing: border-box; font-family: 'SpotifyMixUI', sans-serif !important; }
                h1 { margin: 0; line-height: normal; }
                .job-form-modal .main-trackCreditsModal-mainSection { 
                    padding: 24px 32px 38px !important; display: flex; flex-direction: column; scrollbar-width: none;
                }
                .job-form-layout-container {
                    display: flex;
                    gap: 16px;
                }
                .job-form-left-column {
                    flex: 1;
                    min-width: 0;
                }
                .job-form-right-column {
                    flex: 1;
                    min-width: 0;
                    display: flex;
                    flex-direction: column;
                    gap: 16px;
                }
              .job-form-modal .card { background-color: #282828; border-radius: 8px; padding: 16px; }
              .job-form-modal .card-title { font-weight: 700; color: white; margin-bottom: 12px; font-size: 16px; }
              .job-form-modal #source-list-container { display: flex; flex-direction: column; gap: 8px; max-height: 335px; overflow-y: auto; padding-right: 5px; margin-right: -4px;scrollbar-width: thin; overflow-y: scroll;}
              .job-form-modal .source-item { display: flex; align-items: center; gap: 10px; background-color: #3e3e3e; padding: 8px; border-radius: 6px; }
              .job-form-modal .source-cover-art-small { width: 40px; height: 40px; border-radius: 4px; object-fit: cover; flex-shrink: 0; }
              .job-form-modal .source-text-info { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
              .job-form-modal .source-name { color: white; font-weight: 500; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
              .job-form-modal .source-info { color: #b3b3b3; font-size: 12px; margin-top: 2px; }
              .job-form-modal .source-item-actions { display: flex; align-items: center; gap: 4px; }
              .job-form-modal .remove-source-btn, .job-form-modal .edit-source-btn { 
                  background: none; border: none; color: #b3b3b3; cursor: pointer; 
                  padding: 4px; line-height: 1; border-radius: 50%; 
                  height: 26px; width: 26px; display: flex; align-items: center; justify-content: center;
              }
              .job-form-modal .remove-source-btn { font-size: 20px; }
              .job-form-modal .remove-source-btn:hover, .job-form-modal .edit-source-btn:hover { 
                  color: white; background-color: rgba(255,255,255,0.1); 
              }
              .job-form-modal .source-actions-container { display: flex; gap: 8px; margin-top: 12px; }
              .job-form-modal .source-actions-container button {
                  width: auto;
                  margin-top: 0;
                  background-color: rgba(255,255,255,0.1);
                  border: none;
                  color: white;
                  border-radius: 34px;
                  height: 25px;
                  border: 1px solid #666;
              }
              .job-form-modal .source-actions-container button:hover {
                  background-color: rgba(255,255,255,0.2);
                  cursor: pointer;
                  transition: background-color 0.05s ease;
              }
              .job-form-modal #add-source-btn { flex-grow: 1; }
              .job-form-modal #clear-sources-btn { flex-grow: 0; padding: 0 20px; }
              .job-form-modal .form-select {
                  width: 220px; background: #282828; color: white; border: 1px solid #666;
                  border-radius: 15px; padding: 8px 12px; padding-right: 32px; font-size: 14px; cursor: pointer;
                  font-family: 'SpotifyMixUI', sans-serif !important;
                  -webkit-appearance: none; -moz-appearance: none; appearance: none;
                  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
                  background-repeat: no-repeat; background-position: right 12px center; background-size: 16px;
              }
              .job-form-modal .form-select:focus {
                  outline: none;
                  border: 1px solid #666;
              }
              .job-form-modal .form-select option {
                  background-color: #282828;
                  color: white;
                  font-family: 'SpotifyMixUI', sans-serif !important;
                  font-size: 14px;
                  padding: 4px;
              }
              .job-form-modal .setting-row { display: flex; justify-content: space-between; align-items: center; }
              .job-form-modal .card .setting-row + .setting-row { margin-top: 12px; }
              .job-form-modal .setting-row .description { color: #c1c1c1; font-size: 16px; }
              .main-trackCreditsModal-closeBtn { 
                  background: transparent; 
                  border: 0; 
                  padding: 0; 
                  color: #b3b3b3; 
                  cursor: pointer; 
                  transition: color 0.2s ease;
                  display: flex;
                  align-items: center;
                  justify-content: center;
              }
              .main-trackCreditsModal-closeBtn:hover { 
                  color: #ffffff; 
              }
              .job-form-modal .setting-row.disabled { opacity: 0.5; pointer-events: none; }
              .job-form-modal .switch { position: relative; display: inline-block; width: 40px; height: 24px; flex-shrink: 0; }
              .job-form-modal .switch input { opacity: 0; width: 0; height: 0; }
              .job-form-modal .sliderx { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #484848; border-radius: 24px; transition: .2s; }
              .job-form-modal .sliderx:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; border-radius: 50%; transition: .2s; }
              .job-form-modal input:checked + .sliderx { background-color: #1DB954; }
              .job-form-modal input:checked + .sliderx:before { transform: translateX(16px); }
              .job-form-modal .form-actions { display: flex; justify-content: flex-end; gap: 10px; }
              .job-form-modal .main-button-secondary { background-color: #333333; color: white; transition: background-color 0.1s ease;}
              .job-form-modal .main-button-secondary:hover { background-color: #444444; }
              .job-form-modal .main-button-primary { background-color: #1ED760; color: black; transition: background-color 0.1s ease;}
              .job-form-modal .main-button-primary:hover { background-color: #3BE377; }
              .job-form-modal #playlist-name-input:focus { border: 1px solid #666 !important; }
              .custom-schedule-container { display: none; align-items: center; gap: 8px; margin-top: 16px; padding: 10px; background-color: #3e3e3e; border-radius: 8px; }
              .custom-schedule-container.visible { display: flex; }
              .custom-schedule-container input[type="number"] { width: 60px; padding: 6px; border-radius: 4px; border: 1px solid #666; background-color: #282828; color: white; text-align: center; }
              .custom-schedule-container label { font-size: 12px; color: #b3b3b3; }
              .custom-schedule-ok-btn { padding: 6px 12px; border-radius: 15px; border: none; background-color: #1ed760; color: black; font-weight: bold; cursor: pointer; }
              .tooltip-container { position: relative; display: inline-block; vertical-align: middle; }
              .custom-tooltip {
                  visibility: hidden; position: absolute; z-index: 2005; background-color: #373737;
                  color: white; padding: 8px 12px; border-radius: 4px; font-size: 14px;
                  max-width: 280px; width: max-content; bottom: 100%; left: 50%;
                  transform: translateX(-50%); margin-bottom: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                  line-height: 1.4; word-wrap: break-word; text-align: left;
              }
              .custom-tooltip::after {
                  content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px;
                  border-width: 5px; border-style: solid; border-color: #373737 transparent transparent transparent;
              }
              .tooltip-container:hover .custom-tooltip { visibility: visible; }
              .job-form-modal #source-error-message {
                  color: #f15e6c;
                  font-size: 13px;
                  text-align: center;
                  margin-top: 8px;
                  margin-bottom: 4px;
              }
              #configure-filters-btn {
                  background-color: #282828;
              }
              #configure-filters-btn:hover {
                  background-color: #3e3e3e;
                  border-color: #878787;
              }
              #configure-genres-btn {
                  background-color: #282828;
              }
              #configure-genres-btn:hover {
                  background-color: #3e3e3e;
                border-color: #878787;
              }
              .job-form-modal .limit-input-group {
                  display: flex;
                  align-items: stretch;
                  background-color: #2a2a2a;
                  border: 1px solid #555;
                  border-radius: 4px;
                  overflow: hidden;
                  transition: border-color 0.2s;
                  height: 26px;
              }
              .job-form-modal .source-limit-input {
                  width: 40px !important;
                  border: none !important;
                  background: transparent !important;
                  padding: 0 4px !important;
                  text-align: center;
                  color: white !important;
                  font-weight: 500;
                  height: 100%;
                  outline: none !important;
                  -moz-appearance: textfield;
              }
              .job-form-modal .source-limit-input::-webkit-outer-spin-button,
              .job-form-modal .source-limit-input::-webkit-inner-spin-button {
                  -webkit-appearance: none;
                  margin: 0;
              }
              .job-form-modal .limit-spinners {
                  display: flex;
                  flex-direction: column;
                  width: 20px;
                  border-left: 1px solid #555;
                  border-right: 1px solid #555;
              }
              .job-form-modal .limit-spinner-btn {
                  flex: 1;
                  background-color: #444;
                  border: none;
                  color: #b3b3b3;
                  cursor: pointer;
                  padding: 0;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  transition: background 0.2s;
                  line-height: 0;
              }
              .job-form-modal .limit-spinner-btn:hover {
                  background-color: #666;
                  color: white;
              }
              .job-form-modal .limit-spinner-btn.up {
                  border-bottom: 1px solid #555;
              }
              .job-form-modal .limit-spinner-btn svg {
                  width: 8px;
                  height: 8px;
                  fill: currentColor;
              }
              .job-form-modal .limit-mode-btn {
                  background-color: #444;
                  border: none;
                  color: #b3b3b3;
                  width: 28px;
                  padding: 0;
                  font-size: 11px;
                  font-weight: 700;
                  cursor: pointer;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  transition: all 0.2s;
              }
              .job-form-modal .limit-mode-btn:hover {
                  background-color: #555;
                  color: white;
              }
              .job-form-modal .limit-mode-btn.active {
                  background-color: #1ed760;
                  color: black;
              }
              .job-form-modal .limit-preview {
                  font-size: 11px;
                  color: #888;
                  margin-left: 8px;
                  white-space: nowrap;
                  font-style: italic;
              }
              .job-form-modal .source-limit-toggle-btn {
                  background-color: #444;
                  border: 1px solid #555;
                  color: #b3b3b3;
                  padding: 0 10px;
                  height: 24px;
                  border-radius: 4px;
                  font-size: 11px;
                  font-weight: 700;
                  cursor: pointer;
                  margin-right: 5px;
                  transition: all 0.2s;
              }
              .job-form-modal .source-limit-toggle-btn:hover {
                  background-color: #555;
                  color: white;
              }
              .job-form-modal .source-limit-toggle-btn.active {
                  background-color: #fff;
                  color: black;
              }
              @keyframes fadeIn { from { opacity: 0; transform: scale(0.99); } to { opacity: 1; transform: scale(1); } }
              .job-form-modal { animation: fadeIn 0.2s ease; }
          </style>
            <div class="job-form-modal">
                <div class="main-trackCreditsModal-header" style="border-bottom: 1px solid #282828; display: flex; justify-content: space-between; align-items: center; padding: 29px 32px 19px 32px;">
                    <h1 class="main-trackCreditsModal-title" style="font-size: 26px; font-weight: 700; color: white;">${isEditing ? 'Edit' : 'New'} Dynamic Playlist</h1>
                    <button id="closeDynamicPlaylistModal" aria-label="Close" class="main-trackCreditsModal-closeBtn">
                        <svg width="18" height="18" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M31.098 29.794L16.955 15.65 31.097 1.51 29.683.093 15.54 14.237 1.4.094-.016 1.508 14.126 15.65-.016 29.795l1.414 1.414L15.54 17.065l14.144 14.143" fill="currentColor" fill-rule="evenodd"></path></svg>
                    </button>
                </div>
                <div class="main-trackCreditsModal-mainSection">
                    <div class="job-form-layout-container">
                        <div class="job-form-left-column">
                            <div class="card">
                                <div class="card-title">Sources</div>
                                <div id="source-list-container"></div>
                                <div id="source-error-message" style="display: none;"></div>
                                <div class="source-actions-container">
                                    <button id="add-source-btn" class="main-buttons-button main-button-secondary">+ Add Source</button>
                                    <button id="clear-sources-btn" class="main-buttons-button main-button-secondary">Clear</button>
                                </div>
                                <div style="border-top: 1px solid #3e3e3e; margin: 20px 0 4px;"></div>
                                <div class="setting-row" style="margin-top: 15px;">
                                    <span class="description">
                                        Limit tracks per source
                                        <span class="tooltip-container">
                                            ${infoIconSvg}
                                            <span class="custom-tooltip">Set a limit of random tracks to pull from each source, ensuring fresh content on every update.</span>
                                        </span>
                                    </span>
                                    <label class="switch"><input type="checkbox" id="limit-tracks-toggle" ${isEditing && jobToEdit.limitEnabled ? 'checked' : ''}><span class="sliderx"></span></label>
                                </div>
                                <div style="margin-top: 16px;">
                                    <label for="playlist-name-input" style="display: block; color: #b3b3b3; font-size: 14px; margin-bottom: 8px;">New Playlist Name</label>
                                    <input type="text" id="playlist-name-input" value="" style="width: 100%; background-color: #3e3e3e; border: 1px solid #3e3e3e; border-radius: 4px; padding: 8px 12px; color: white; box-sizing: border-box;">
                                </div>
                            </div>
                        </div>
                        <div class="job-form-right-column">
                        <div class="card">
                            <div class="card-title">Configuration</div>
                            <div class="setting-row">
                                <span class="description">Update Behavior</span>
                                <select id="update-mode-select" class="form-select">
                                    <option value="replace">Replace All Tracks</option>
                                    <option value="merge">Add New Tracks & Re-sort All</option>
                                    <option value="append">Add New Tracks to Top</option>
                                </select>
                            </div>
                            <div class="setting-row" id="sort-type-row">
                                <span class="description">Sort Method</span>
                                <select id="sort-type-select" class="form-select">${sortOptions}</select>
                            </div>
                            <div class="setting-row" style="align-items: start;">
                                <span class="description" style="padding-top: 8px;">Update Schedule</span>
                                <div style="display: flex; flex-direction: column; align-items: flex-end;">
                                    <select id="schedule-select" class="form-select">
                                        <option value="manual" ${ (isEditing ? jobToEdit.schedule : savedSchedule) === 'manual' ? 'selected' : ''}>Manual Only</option>
                                        <option value="10800000" ${ (isEditing ? String(jobToEdit.schedule) : savedSchedule) === '10800000' ? 'selected' : ''}>Every 3 Hours</option>
                                        <option value="21600000" ${ (isEditing ? String(jobToEdit.schedule) : savedSchedule) === '21600000' ? 'selected' : ''}>Every 6 Hours</option>
                                        <option value="43200000" ${ (isEditing ? String(jobToEdit.schedule) : savedSchedule) === '43200000' ? 'selected' : ''}>Every 12 Hours</option>
                                        <option value="86400000" ${ (isEditing ? String(jobToEdit.schedule) : savedSchedule) === '86400000' ? 'selected' : ''}>Daily</option>
                                        <option value="172800000" ${ (isEditing ? String(jobToEdit.schedule) : savedSchedule) === '172800000' ? 'selected' : ''}>Every 2d</option>
                                        <option value="604800000" ${ (isEditing ? String(jobToEdit.schedule) : savedSchedule) === '604800000' ? 'selected' : ''}>Weekly</option>
                                        <option value="2592000000" ${ (isEditing ? String(jobToEdit.schedule) : savedSchedule) === '2592000000' ? 'selected' : ''}>Monthly</option>
                                        <option disabled>- Release Day Schedules -</option>
                                        <option value="release-weekly" ${ (isEditing ? jobToEdit.schedule : savedSchedule) === 'release-weekly' ? 'selected' : ''}>Weekly (on Friday)</option>
                                        <option value="release-every-two-weeks" ${ (isEditing ? jobToEdit.schedule : savedSchedule) === 'release-every-two-weeks' ? 'selected' : ''}>Every Two Weeks (on Friday)</option>
                                        <option value="release-monthly" ${ (isEditing ? jobToEdit.schedule : savedSchedule) === 'release-monthly' ? 'selected' : ''}>Monthly (on a Friday)</option>
                                        <option disabled>- Custom Schedules -</option>
                                        ${customScheduleOptions}
                                        <option value="custom">+ Custom</option>
                                        ${clearAndSeparatorHtml}
                                    </select>
                                    <div id="custom-schedule-container" class="custom-schedule-container">
                                        <input type="number" id="days" min="0" value="0"><label for="days">d</label>
                                        <input type="number" id="hours" min="0" max="23" value="0"><label for="hours">h</label>
                                        <input type="number" id="minutes" min="0" max="59" value="0"><label for="minutes">m</label>
                                        <button id="set-custom-schedule-btn" class="custom-schedule-ok-btn">Set</button>
                                    </div>
                                    <div id="custom-schedule-error" style="color: #f15e6c; font-size: 12px; text-align: right; margin-top: 4px; display: none;"></div>
                                    <label id="custom-schedule-min-label" style="font-size: 12px; color: #b3b3b3; text-align: right; display: none; margin-top: 4px;">Minimum: ${SCHEDULER_INTERVAL_MINUTES} minutes</label>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <div class="card-title">Track Filtering</div>
                            <div class="setting-row">
                                <span class="description">
                                    Apply filters to source tracks
                                    <span class="tooltip-container">
                                        ${infoIconSvg}
                                        <span class="custom-tooltip">Configure advanced filters for tracks from your sources.</span>
                                    </span>
                                </span>
                                <button id="configure-filters-btn" class="main-buttons-button main-button-secondary" style="padding: 6px 25px; border-radius: 20px; border: 1px solid #666; cursor: pointer; color: white; font-weight: 500; font-size: 12px; transition: background-color 0.1s ease, border-color 0.1s ease;">Configure</button>
                            </div>
                            <div class="setting-row" style="margin-top: 12px;">
                                <span class="description">
                                    Apply genre filter to tracks
                                    <span class="tooltip-container">
                                        ${infoIconSvg}
                                        <span class="custom-tooltip">Filter tracks based on genres. Can exclude or require specific genres.</span>
                                    </span>
                                </span>
                                <button id="configure-genres-btn" class="main-buttons-button main-button-secondary" style="padding: 6px 32px; border-radius: 20px; border: 1px solid #666; cursor: pointer; color: white; font-weight: 500; font-size: 12px; transition: background-color 0.1s ease, border-color 0.1s ease;">Genres</button>
                            </div>
                        </div>
                            <div class="card">
                                <div class="card-title">Settings</div>
                                    <div class="setting-row">
                                    <span class="description">Deduplicate tracks</span>
                                    <label class="switch"><input type="checkbox" id="deduplicate-toggle" ${currentDeduplicate ? 'checked' : ''}><span class="sliderx"></span></label>
                                </div>
                                <div class="setting-row" id="update-source-row">
                                    <span class="description">
                                        Always update from original source
                                        <span class="tooltip-container">
                                            ${infoIconSvg}
                                            <span class="custom-tooltip">Enabled: Fetches fresh tracks from the source(s) for each update.<br><br>Disabled: Only re-sorts the tracks already inside this dynamic playlist.</span>
                                        </span>
                                    </span>
                                    <label class="switch"><input type="checkbox" id="update-source-toggle" ${currentUpdateFromSource ? 'checked' : ''}><span class="sliderx"></span></label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="main-trackCreditsModal-originalCredits" style="padding: 24px 32px !important; border-top: 1px solid #282828;">
                    <div class="form-actions">
                        <button id="cancel-job-btn" class="main-buttons-button main-button-secondary" style="padding: 8px 18px; border-radius: 20px; font-weight: 550; font-size: 13px; text-transform: uppercase; cursor: pointer; border: none;">Cancel</button>
                        <button id="save-job-btn" class="main-buttons-button main-button-primary" style="padding: 8px 18px; border-radius: 20px; font-weight: 550; font-size: 13px; text-transform: uppercase; cursor: pointer; border: none;">${isEditing ? 'Save Changes' : 'Save & Create'}</button>
                    </div>
                </div>
            </div>
        `;
        
        const playlistNameInput = modalContainer.querySelector('#playlist-name-input');
        const updateModeSelect = modalContainer.querySelector('#update-mode-select');
        const sortTypeRow = modalContainer.querySelector('#sort-type-row');
        const sortTypeSelectUI = modalContainer.querySelector('#sort-type-select');
        const updateSourceRow = modalContainer.querySelector('#update-source-row');
        const updateSourceToggle = modalContainer.querySelector('#update-source-toggle');
        const deduplicateToggle = modalContainer.querySelector('#deduplicate-toggle');
        const limitTracksToggle = modalContainer.querySelector('#limit-tracks-toggle');
        const sourceListContainer = modalContainer.querySelector('#source-list-container');
        const configureFiltersBtn = modalContainer.querySelector('#configure-filters-btn');
        const configureGenresBtn = modalContainer.querySelector('#configure-genres-btn');

        if (configureFiltersBtn) {
            configureFiltersBtn.addEventListener('click', async () => {
                const newFilters = await showDynamicFilterModal(jobFilters);
                if (newFilters) {
                    jobFilters = { ...jobFilters, ...newFilters };
                }
            });
        }

        if (configureGenresBtn) {
            configureGenresBtn.addEventListener('click', async () => {
                if (sources.length === 0) {
                    showNotification("Please add at least one source before configuring genres.", true);
                    return;
                }
                
                const currentGenreSettings = jobFilters.genreFilterSettings || {
                    selectedGenres: [],
                    excludedGenres: [],
                    matchAllGenres: false,
                    groupGenres: true,
                    detectedGenres: []
                };

                const newGenreSettings = await showDynamicGenreFilterModal(
                    sources, 
                    currentGenreSettings,
                    (detectedGenres) => {
                        if (!jobFilters.genreFilterSettings) {
                            jobFilters.genreFilterSettings = {
                                selectedGenres: [],
                                excludedGenres: [],
                                matchAllGenres: false,
                                groupGenres: true
                            };
                        }
                        jobFilters.genreFilterSettings.detectedGenres = detectedGenres;
                    }
                );
                
                if (newGenreSettings) {
                    jobFilters.genreFilterSettings = newGenreSettings;
                    showNotification("Genre filters saved.");
                }
            });
        }

        deduplicateToggle.addEventListener('change', (e) => {
            currentDeduplicate = e.target.checked;
        });
        updateSourceToggle.addEventListener('change', (e) => {
            currentUpdateFromSource = e.target.checked;
        });

        const updateFormState = () => {
            if (!isEditing) {
                if (sources.length === 0) {
                    playlistNameInput.value = "Dynamic Playlist";
                } else if (sources.length === 1) {
                    playlistNameInput.value = `${sources[0].name} (Dynamic)`;
                } else {
                    playlistNameInput.value = "Combined Dynamic Playlist";
                }
            } else {
                playlistNameInput.value = jobToEdit.targetPlaylistName;
            }
        
            updateSourceRow.classList.toggle('disabled', false);
            updateSourceToggle.checked = currentUpdateFromSource;
        };

        if (isEditing) {
            updateModeSelect.value = jobToEdit.updateMode || 'replace';
        }

        const handleUpdateModeChange = () => {
            if (updateModeSelect.value === 'append') {
                sortTypeRow.classList.add('disabled');
                sortTypeSelectUI.disabled = true;
            } else {
                sortTypeRow.classList.remove('disabled');
                sortTypeSelectUI.disabled = false;
            }
    
            if (updateModeSelect.value === 'replace') {
                updateSourceRow.classList.remove('disabled');
                updateSourceToggle.disabled = false;
                updateSourceToggle.checked = currentUpdateFromSource; 
            } else {
                updateSourceRow.classList.add('disabled');
                updateSourceToggle.disabled = true;
                updateSourceToggle.checked = true;
            }
        };

        updateModeSelect.addEventListener('change', handleUpdateModeChange);
        handleUpdateModeChange();
        
        const renderSources = () => {
            const container = modalContainer.querySelector('#source-list-container');
            const sourceErrorEl = modalContainer.querySelector('#source-error-message');

            if (sourceErrorEl && sources.length > 0) {
                sourceErrorEl.style.display = 'none';
            }

            if (!container) return;
            
            container.innerHTML = sources.map((source, index) => {
                const limitMode = source.limitMode || 'count';
                const isPercent = limitMode === 'percent';
                const total = parseInt(source.totalTracks) || 0;
                let previewText = '';
                if (isPercent && total > 0 && source.limit) {
                    const calc = Math.ceil(total * (source.limit / 100));
                    previewText = `(~${calc} tracks)`;
                }

                const isSourceLimitEnabled = source.limitEnabled !== false;
                const limitBtnClass = isSourceLimitEnabled ? 'active' : '';
                const limitControlsStyle = isSourceLimitEnabled ? 'opacity: 1; pointer-events: auto;' : 'opacity: 0.4; pointer-events: none;';

                return `
                <div class="source-item" data-uri="${source.uri}">
                    <img src="${source.coverUrl || 'https://i.imgur.com/33q4t4k.png'}" class="source-cover-art-small">
                    <div class="source-text-info">
                        <div class="source-name" title="${source.name}">${source.name}</div>
                        <div class="source-info">${source.info} â€¢ ${source.totalTracks ?? 'N/A'} tracks</div>
                        <div class="source-limit-wrapper" style="display: none; margin-top: 6px; align-items: center;">
                            <button class="source-limit-toggle-btn ${limitBtnClass}" data-index="${index}" title="Toggle limit for this source">Limit</button>
                            <div class="limit-controls-container" style="display: flex; align-items: center; transition: opacity 0.2s; ${limitControlsStyle}">
                                <div class="limit-input-group">
                                    <input type="number" 
                                        class="source-limit-input" 
                                        data-index="${index}" 
                                        value="${source.limit || 10}" 
                                        min="1" 
                                        max="${isPercent ? 100 : (source.totalTracks || '')}">
                                    <div class="limit-spinners">
                                        <button class="limit-spinner-btn up" data-index="${index}" title="Increase">
                                            <svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path></svg>
                                        </button>
                                        <button class="limit-spinner-btn down" data-index="${index}" title="Decrease">
                                            <svg viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"></path></svg>
                                        </button>
                                    </div>
                                    <button class="limit-mode-btn ${isPercent ? 'active' : ''}" 
                                            data-index="${index}" 
                                            title="Click to toggle between Count (#) and Percentage (%)">
                                        ${isPercent ? '%' : '#'}
                                    </button>
                                </div>
                                <span class="limit-preview" id="limit-preview-${index}">${previewText}</span>
                            </div>
                        </div>
                    </div>
                    <div class="source-item-actions">
                        <button class="edit-source-btn" data-index="${index}" title="Change source">${penIconSvg}</button>
                        <button class="remove-source-btn" data-index="${index}" title="Remove source">&times;</button>
                    </div>
                </div>
            `}).join('');

            container.querySelectorAll('.edit-source-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const indexToChange = parseInt(e.currentTarget.dataset.index, 10);
                    showChangeSourceModal(
                        "Change Source",
                        userLibraryPromise,
                        (newSourcesData) => {
                            const existingUris = sources.filter((_, i) => i !== indexToChange).map(s => s.uri);
                            const uniqueNewSources = newSourcesData.filter(newSource => !existingUris.includes(newSource.uri));
                            if (uniqueNewSources.length < newSourcesData.length) showNotification("Some selected sources were already in the list and have been ignored.");
                            if (uniqueNewSources.length > 0) sources.splice(indexToChange, 1, ...uniqueNewSources);
                            else sources.splice(indexToChange, 1);
                            renderSources();
                        },
                        true 
                    );
                });
            });

            container.querySelectorAll('.remove-source-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const indexToRemove = parseInt(e.currentTarget.dataset.index, 10);
                    sources.splice(indexToRemove, 1);
                    renderSources();
                    updateFormState();
                });
            });

            container.querySelectorAll('.limit-spinner-btn').forEach(btn => {
                let interval;
                let timeout;
                const isUp = btn.classList.contains('up');
                const index = parseInt(btn.dataset.index, 10);
                
                const performUpdate = () => {
                    const source = sources[index];
                    const input = container.querySelector(`.source-limit-input[data-index="${index}"]`);
                    const preview = container.querySelector(`#limit-preview-${index}`);
                    
                    if (!input) return;

                    const currentVal = parseInt(input.value) || 0;
                    const max = parseInt(input.max);
                    const min = parseInt(input.min) || 1;
                    
                    let newVal = isUp ? currentVal + 1 : currentVal - 1;
                    
                    if (!isNaN(max) && newVal > max) newVal = max;
                    if (newVal < min) newVal = min;
                    
                    if (newVal !== currentVal) {
                        input.value = newVal;
                        source.limit = newVal;
                        
                        if (source.limitMode === 'percent' && source.totalTracks && !isNaN(parseInt(source.totalTracks))) {
                            const calc = Math.ceil(parseInt(source.totalTracks) * (newVal / 100));
                            preview.textContent = `(~${calc} tracks)`;
                        } else {
                            preview.textContent = '';
                        }
                    }
                };

                const stop = () => {
                    clearTimeout(timeout);
                    clearInterval(interval);
                };

                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault(); 
                    performUpdate();
                    timeout = setTimeout(() => {
                        interval = setInterval(performUpdate, 50);
                    }, 400);
                });

                btn.addEventListener('mouseup', stop);
                btn.addEventListener('mouseleave', stop);
            });

            updateFormState();
        };

        renderSources();

        const toggleLimitInputs = (show) => {
            const wrappers = modalContainer.querySelectorAll('.source-limit-wrapper');
            wrappers.forEach(wrapper => {
                wrapper.style.display = show ? 'flex' : 'none';
            });
        };

        if (limitTracksToggle.checked) {
            toggleLimitInputs(true);
        }

        limitTracksToggle.addEventListener('change', (e) => {
            toggleLimitInputs(e.target.checked);
        });

        sourceListContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('source-limit-toggle-btn')) {
                const btn = e.target;
                const index = parseInt(btn.dataset.index, 10);
                const source = sources[index];
                
                const newState = source.limitEnabled === false ? true : false;
                source.limitEnabled = newState;
                
                if (newState) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
                
                const controlsContainer = btn.nextElementSibling;
                if (controlsContainer) {
                    controlsContainer.style.opacity = newState ? '1' : '0.4';
                    controlsContainer.style.pointerEvents = newState ? 'auto' : 'none';
                }
            }

            if (e.target.classList.contains('limit-mode-btn')) {
                const btn = e.target;
                const index = parseInt(btn.dataset.index, 10);
                const source = sources[index];
                const input = sourceListContainer.querySelector(`.source-limit-input[data-index="${index}"]`);
                const preview = sourceListContainer.querySelector(`#limit-preview-${index}`);
                
                if (!source.limitMode || source.limitMode === 'count') {
                    source.limitMode = 'percent';
                    btn.textContent = '%';
                    btn.classList.add('active');
                    input.max = 100;
                    if (parseInt(input.value) > 100) {
                        input.value = 100;
                        source.limit = 100;
                    }
                } else {
                    source.limitMode = 'count';
                    btn.textContent = '#';
                    btn.classList.remove('active');
                    input.max = source.totalTracks || '';
                }
                
                if (source.limitMode === 'percent' && source.totalTracks && !isNaN(parseInt(source.totalTracks))) {
                    const calc = Math.ceil(parseInt(source.totalTracks) * (parseInt(input.value) / 100));
                    preview.textContent = `(~${calc} tracks)`;
                } else {
                    preview.textContent = '';
                }
            }
        });

        sourceListContainer.addEventListener('input', (e) => {
            if (e.target.classList.contains('source-limit-input')) {
                const index = parseInt(e.target.dataset.index, 10);
                let value = parseInt(e.target.value, 10);
                const max = parseInt(e.target.max, 10);
                const source = sources[index];

                if (!isNaN(max) && value > max) {
                    value = max;
                    e.target.value = max;
                }

                if (source && value > 0) {
                    source.limit = value;
                    
                    const preview = sourceListContainer.querySelector(`#limit-preview-${index}`);
                    if (source.limitMode === 'percent' && source.totalTracks && !isNaN(parseInt(source.totalTracks))) {
                        const calc = Math.ceil(parseInt(source.totalTracks) * (value / 100));
                        preview.textContent = `(~${calc} tracks)`;
                    } else {
                        preview.textContent = '';
                    }
                }
            }
        });

        modalContainer.querySelector('#clear-sources-btn').addEventListener('click', () => {
            sources.length = 0;
            renderSources();
            toggleLimitInputs(limitTracksToggle.checked);
            updateFormState();
        });

        modalContainer.querySelector('#add-source-btn').addEventListener('click', () => {
            showChangeSourceModal(
                "Add Source",
                userLibraryPromise,
                (newSourcesData) => {
                    newSourcesData.forEach(newSource => {
                        if (!sources.some(s => s.uri === newSource.uri)) {
                            sources.push(newSource);
                        } else {
                            showNotification(`Source "${newSource.name}" is already in the list.`, 'warning');
                        }
                    });
                    renderSources();
                    toggleLimitInputs(limitTracksToggle.checked);
                },
                true
            );
        });

        const scheduleSelect = modalContainer.querySelector('#schedule-select');
        const customScheduleContainer = modalContainer.querySelector('#custom-schedule-container');
        
        modalContainer.querySelector('#sort-type-select').addEventListener('change', (e) => localStorage.setItem(STORAGE_KEY_DYNAMIC_SORT_TYPE, e.target.value));
        scheduleSelect.addEventListener('change', (e) => localStorage.setItem(STORAGE_KEY_DYNAMIC_SCHEDULE, e.target.value));
        
        let previousScheduleValue = scheduleSelect.value;
        
        const minLabel = modalContainer.querySelector('#custom-schedule-min-label');

        scheduleSelect.addEventListener('change', async (e) => {
            const selectedValue = e.target.value;

            if (selectedValue === 'clear-custom') {
                e.target.value = previousScheduleValue;

                const customSchedules = getCustomSchedules();
                if (customSchedules.length === 0) {
                    showNotification("No custom schedules to clear.");
                    return;
                }

                const confirmed = await showConfirmationModal({
                    title: "Clear Custom Schedules?",
                    description: "This will permanently remove all of your saved custom schedules. This action cannot be undone. Are you sure?",
                    confirmText: "Clear All",
                    cancelText: "Cancel",
                });

                if (confirmed === 'confirm') {
                    saveCustomSchedules([]);
                    showNotification("All custom schedules have been cleared.");
                    await renderJobForm(jobToEdit);
                }
            } else {
                const isCustom = selectedValue === 'custom';
                customScheduleContainer.classList.toggle('visible', isCustom);
                minLabel.style.display = isCustom ? 'block' : 'none';
                if (!isCustom) {
                    previousScheduleValue = selectedValue;
                    localStorage.setItem(STORAGE_KEY_DYNAMIC_SCHEDULE, selectedValue);
                }
            }
        });

        scheduleSelect.addEventListener('change', () => {
            customScheduleContainer.classList.toggle('visible', scheduleSelect.value === 'custom');
        });

        modalContainer.querySelector('#set-custom-schedule-btn').addEventListener('click', () => {
            const days = parseInt(modalContainer.querySelector('#days').value) || 0;
            const hours = parseInt(modalContainer.querySelector('#hours').value) || 0;
            const minutes = parseInt(modalContainer.querySelector('#minutes').value) || 0;
            
            const totalMs = (days * 86400000) + (hours * 3600000) + (minutes * 60000);
            const minMs = SCHEDULER_INTERVAL_MINUTES * 60 * 1000;

            if (totalMs < minMs) {
                showNotification(`Schedule must be at least ${SCHEDULER_INTERVAL_MINUTES} minutes.`, true);
                return;
            }

            let text = 'Every ';
            if (days > 0) text += `${days}d `;
            if (hours > 0) text += `${hours}h `;
            if (minutes > 0) text += `${minutes}m`;
            text = text.trim();

            const customSchedules = getCustomSchedules();
            if (!customSchedules.some(s => s.value === totalMs)) {
                customSchedules.push({ value: totalMs, text });
                saveCustomSchedules(customSchedules);
            }

            const customOption = document.createElement('option');
            customOption.value = totalMs;
            customOption.textContent = text;
            scheduleSelect.insertBefore(customOption, scheduleSelect.querySelector('option[value="custom"]'));
            scheduleSelect.value = totalMs;
            localStorage.setItem(STORAGE_KEY_DYNAMIC_SCHEDULE, totalMs);
            customScheduleContainer.classList.remove('visible');
            minLabel.style.display = 'none';
            renderJobForm(jobToEdit); 
        });

        const transitionToList = () => {
            const content = modalContainer.shadowRoot.querySelector('.job-form-modal');
            if (content) {
                content.style.transition = 'opacity 0.2s ease';
                content.style.opacity = '0';
                setTimeout(() => renderJobList(), 200);
            } else {
                renderJobList();
            }
        };

        modalContainer.querySelector('#closeDynamicPlaylistModal').addEventListener('click', transitionToList);
        modalContainer.querySelector('#cancel-job-btn').addEventListener('click', transitionToList);
        
        modalContainer.querySelector('#save-job-btn').addEventListener('click', (e) => {
            if (sources.length === 0) {
                showNotification("Please add at least one source.", true);
                return;
            }

            const limitEnabled = modalContainer.querySelector('#limit-tracks-toggle').checked;
            if (limitEnabled) {
                modalContainer.querySelectorAll('.source-limit-input').forEach(input => {
                    const index = parseInt(input.dataset.index, 10);
                    const value = parseInt(input.value, 10);
                    if (sources[index] && value > 0) {
                        sources[index].limit = value;
                        if (!sources[index].limitMode) sources[index].limitMode = 'count';
                    }
                });
            }

            if (isEditing && jobToEdit && jobToEdit.sources) {
                sources.forEach(source => {
                    const originalSource = jobToEdit.sources.find(s => s.uri === source.uri);
                    if (originalSource && originalSource.usedTrackURIs) {
                        source.usedTrackURIs = originalSource.usedTrackURIs;
                    }
                });
            }

            const scheduleValue = modalContainer.querySelector('#schedule-select').value;
            const jobData = {
                sources: sources,
                limitEnabled: limitEnabled,
                targetPlaylistName: modalContainer.querySelector('#playlist-name-input').value.trim(),
                updateMode: modalContainer.querySelector('#update-mode-select').value,
                sortType: modalContainer.querySelector('#sort-type-select').value,
                deduplicate: currentDeduplicate,
                updateFromSource: currentUpdateFromSource,
                schedule: isNaN(parseInt(scheduleValue)) ? scheduleValue : parseInt(scheduleValue),
                filters: jobFilters,
            };
            
            if (isEditing) {
                const updatedJob = { ...jobToEdit, ...jobData };
                updateJob(updatedJob);
                transitionToList();
            } else {
                const newJob = {
                    ...jobData,
                    id: crypto.randomUUID(),
                    createdAt: Date.now(),
                    lastRun: null,
                };
                closeModal();
                runJob(newJob, true)
                .then(completedJob => {
                    addJob(completedJob);
                    showNotification(`Dynamic playlist "${completedJob.targetPlaylistName}" created successfully!`);
                })
                .catch(error => {
                    showDetailedError(error, `Error creating dynamic playlist "${newJob.targetPlaylistName}"`);
                });
            }
        });

        if (!isEditing && sources.length === 0) {
            (async () => {
                let sourceUri = getCurrentUri();
                if (sourceUri && !isLocalFilesPage(sourceUri)) {
                    try {
                        let sourceName, sourceInfo, sourceCoverUrl, isStaticSource = false, totalTracks = 'N/A';
                        if (URI.isPlaylistV1OrV2(sourceUri)) {
                            const data = await Spicetify.Platform.PlaylistAPI.getMetadata(sourceUri);
                            sourceName = data.name; 
                            const ownerName = data.owner?.displayName || data.owner?.name || "Unknown Owner";
                            sourceInfo = `Playlist by ${ownerName}`; 
                            sourceCoverUrl = data.images?.length ? (data.images[data.images.length - 1] || data.images[0]).url : null;
                            totalTracks = data.totalLength;
                        } else if (URI.isArtist(sourceUri)) {
                            const id = sourceUri.split(":")[2];
                            let data;
                            if (isFallbackActive()) {
                                const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, { uri: sourceUri, locale: "en", includePrerelease: false });
                                data = { name: res.data.artistUnion.profile.name, images: [{ url: res.data.artistUnion.visuals.avatarImage?.sources?.[0]?.url }] };
                            } else {
                                try {
                                    data = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists/${id}`);
                                } catch(e) {
                                    if(registerWebApiFailure()) {
                                        const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, { uri: sourceUri, locale: "en", includePrerelease: false });
                                        data = { name: res.data.artistUnion.profile.name, images: [{ url: res.data.artistUnion.visuals.avatarImage?.sources?.[0]?.url }] };
                                    }
                                }
                            }
                            sourceName = data.name; sourceInfo = `Artist Page`; sourceCoverUrl = data.images?.[0]?.url; isStaticSource = true; totalTracks = 'N/A';
                        } else if (isLikedSongsPage(sourceUri)) {
                            sourceName = "Liked Songs"; sourceInfo = "Your collection"; sourceCoverUrl = 'https://misc.scdn.co/liked-songs/liked-songs-640.png';
                            const likedSongs = await getLikedSongs();
                            totalTracks = likedSongs.length;
                        } else if (URI.isAlbum(sourceUri)) {
                            const id = sourceUri.split(":")[2];
                            let data;
                            if (isFallbackActive()) {
                                const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: sourceUri, locale: "en", offset: 0, limit: 1 });
                                const u = res.data.albumUnion;
                                data = { name: u.name, artists: u.artists.items, images: [{ url: u.coverArt.sources[0].url }], tracks: { total: u.tracksV2 ? u.tracksV2.totalCount : u.tracks.totalCount } };
                            } else {
                                try {
                                    data = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${id}`);
                                } catch(e) {
                                    if(registerWebApiFailure()) {
                                        const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: sourceUri, locale: "en", offset: 0, limit: 1 });
                                        const u = res.data.albumUnion;
                                        data = { name: u.name, artists: u.artists.items, images: [{ url: u.coverArt.sources[0].url }], tracks: { total: u.tracksV2 ? u.tracksV2.totalCount : u.tracks.totalCount } };
                                    }
                                }
                            }
                            const artistNames = data.artists.map(a => a.profile ? a.profile.name : a.name).join(', ');
                            sourceName = data.name; sourceInfo = `Album by ${artistNames}`; sourceCoverUrl = data.images?.[0]?.url; isStaticSource = true; totalTracks = data.tracks.total;
                        }
                        
                        if (sourceName) {
                            sources.push({ uri: sourceUri, name: sourceName, info: sourceInfo, coverUrl: sourceCoverUrl, isStatic: isStaticSource, totalTracks: totalTracks });
                            renderSources();
                            updateFormState();
                            const limitToggle = modalContainer.querySelector('#limit-tracks-toggle');
                            if (limitToggle && limitToggle.checked) {
                                toggleLimitInputs(true);
                            }
                        }
                    } catch (e) { console.error("Could not fetch source details", e); }
                }
            })();
        }
    };
    
    renderJobList();
    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);

    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            overlay.style.opacity = "1";
        });
    });
  }

  const GENRE_MAPPINGS = {
    "acoustic": ["acoustic", "acoustic's", "acousticmusic", "acoustics"],
    "adult standards": ["adult standards", "crooner", "easy listening", "lounge", "standards", "traditional pop"],
    "afro r&b": ["afro r&b", "afro soul", "afrofuturism", "bongo flava"],
    "afro-funk": ["afro-funk", "highlife", "nigerian hip hop"],
    "afrobeats": ["afro beats", "afrobeats", "afropop", "afroswing", "azonto", "azontobeats", "coupÃ©-dÃ©calÃ©", "ghanaian pop", "makossa", "nigerian pop"],
    "alternative": ["alt", "alternative", "alternative's", "alternativemusic", "alternatives"],
    "alternative metal": ["alternative metal", "funk metal", "industrial metal", "nu metal", "rap metal"],
    "alternative rock": ["alternative rock", "britpop", "modern alternative rock", "modern rock", "permanent wave"],
    "amapiano": ["afro piano", "amapiano", "sgija"],
    "ambient": ["ambient", "ambient's", "ambients", "atmospheric"],
    "art pop": ["art pop", "baroque pop", "chamber pop", "experimental pop"],
    "art rock": ["art rock", "experimental rock", "rock in opposition", "zeuhl"],
    "bachata": ["bachata", "bachata dominicana"],
    "bebop": ["bebop", "bop", "post-bop"],
    "black metal": ["atmospheric black metal", "black metal", "blackgaze", "cascadian black metal", "melodic black metal", "metal noir quebecois", "pagan black metal", "raw black metal", "symphonic black metal", "viking metal"],
    "blues": ["blues", "blues'", "bluesier", "bluesiest", "bluesmusic", "bluesy", "punk blues"],
    "blues rock": ["blues rock", "british blues", "electric blues"],
    "bollywood pop": ["bollywood pop", "classic bollywood", "desi pop", "filmi", "kollywood", "modern bollywood", "mollywood", "sandalwood", "tollywood", "bollywood"],
    "bossa nova": ["bossa nova", "bossa nova cover", "bossa nova jazz", "samba-jazz"],
    "breakbeat": ["big beat", "breakbeat", "breaks", "funky breaks", "nu skool breaks"],
    "c-pop": ["c-pop", "cantopop", "chinese pop", "mandopop"],
    "chillwave": ["chillwave", "hypnagogic pop"],
    "christian hip hop": ["christian hip hop", "christian trap", "gospel rap"],
    "christian metal": ["christian death metal", "christian metal", "christian metalcore", "unblack metal"],
    "christian rock": ["christian alternative rock", "christian rock", "christian indie"],
    "city pop": ["city pop", "japanese funk", "japanese soul", "shibuya-kei"],
    "classic rock": ["album rock", "classic rock", "soft rock", "southern rock"],
    "classical": ["baroque", "baroque's", "classic", "classical", "classical music", "classical's", "classics", "orchestra", "orchestral", "orchestral music", "orchestras", "symphonic", "symphonies", "symphony"],
    "conscious hip hop": ["conscious hip hop", "political hip hop", "rap conscient", "underground hip hop"],
    "contemporary r&b": ["contemporary r and b", "contemporary r&b", "contemporary rhythm and blues", "contemporary rnb", "modern r&b", "modern rnb"],
    "corridos tumbados": ["corridos alternativos", "corridos belicos", "corridos tumbados", "sad sierreno", "sierreno"],
    "country": ["country", "country & western music", "country music", "country's", "countrymusic"],
    "cumbia": ["cumbia", "cumbia 420", "cumbia andina mexicana", "cumbia boliviana", "cumbia chilena", "cumbia del sureste", "cumbia lagunera", "cumbia peruana", "cumbia pop", "cumbia ranchera", "cumbia salvadorena", "cumbia santafesina", "cumbia sonidera", "cumbia uruguaya", "cumbia villera", "nu-cumbia", "tecnocumbia"],
    "dance": ["dance", "dance's", "dances", "dancey"],
    "dark wave": ["coldwave", "dark wave", "gothic", "gothic americana", "neoclassical darkwave"],
    "death metal": ["brutal death metal", "cavernous death metal", "death 'n' roll", "death metal", "deathgrind", "florida death metal", "gothenburg metal", "melodic death metal", "swedish melodeath", "technical death metal"],
    "dembow": ["dembow", "dembow dominicano"],
    "disco": ["disco", "disco music", "disco's", "discomusic", "discos", "future funk"],
    "doom metal": ["doom metal", "drone metal", "epic doom", "funeral doom", "psychedelic doom", "sludge metal"],
    "dream pop": ["dream pop", "ethereal wave"],
    "drill": ["aussie drill", "bronx drill", "brooklyn drill", "chicago drill", "classical drill", "drill", "drill chileno", "drill espanol", "drill francais", "drill tuga", "florida drill", "german drill", "melodic drill", "ny drill", "uk drill"],
    "drone": ["drone", "drone's", "dronemusic", "drones"],
    "drum and bass": ["d&b", "dnb", "drum & bass", "drum and bass", "drum n bass", "drumandbass", "Drum'n'bass"],
    "dubstep": ["brostep", "drumstep", "dub step", "dub-step", "dubstep", "dubstep's", "dubstepmusic"],
    "east coast hip hop": ["boom bap", "east coast hip hop", "hardcore hip hop"],
    "edm": ["edm", "edm music", "edm's", "edmmusic", "electronic dance", "electronic dance music"],
    "electro swing": ["electro swing", "swing house"],
    "electronic": ["electro", "electro's", "electronic", "electronic music", "electronic's", "electronica", "electronicas", "electronico", "electronics", "electronik", "eletronic"],
    "electropop": ["electro pop", "electro-pop", "electronic pop", "electropop"],
    "emo": ["emo", "emo rap", "emo trap", "emocore", "midwest emo", "pop emo"],
    "epic": ["epic", "epic music", "epic's", "epicmusic"],
    "epiccore": ["epic core", "epic-core", "epiccore"],
    "eurodance": ["bubblegum dance", "eurodance", "hands up", "hi-nrg", "italo dance"],
    "experimental": ["experiment", "experimental", "experimental electronic", "experimental's", "experimentalmusic", "experiments"],
    "folk": ["folk", "folk's", "folk-pop", "folkie", "folkier", "folklore", "folkmusic", "folksy", "contemporary folk"],
    "forro": ["baiao", "forro", "forro de favela", "forro tradicional", "piseiro", "xote"],
    "french hip hop": ["french hip hop", "pop urbaine", "r&b francais", "rap francais", "rap marseille"],
    "french pop": ["chanson", "french indie pop", "french pop", "french synthpop", "nouvelle chanson francaise", "variete francaise", "yeye"],
    "funk": ["funk", "funk's", "funkier", "funkiest", "funkmusic", "funky"],
    "funk carioca": ["brega funk", "funk 150 bpm", "funk carioca", "funk mandelao", "funk mtg", "funk ostentacao", "funk paulista", "funk viral", "mega funk", "rave funk"],
    "future bass": ["future bass", "future bass's", "futurebass", "futurebassmusic"],
    "gangster rap": ["chicano rap", "crunk", "dirty south rap", "g funk", "gangster rap", "hardcore hip hop", "houston rap", "memphis hip hop", "west coast rap"],
    "garage rock": ["freakbeat", "garage psych", "garage rock", "garage rock revival", "protopunk", "punk blues"],
    "german hip hop": ["frauenrap", "german alternative rap", "german cloud rap", "german hip hop", "german underground rap", "oldschool deutschrap"],
    "german pop": ["deutschrock", "german pop", "neue deutsche welle", "ostrock"],
    "glam rock": ["glam metal", "glam punk", "glam rock", "hard glam", "sleaze rock"],
    "global christian": ["african gospel", "celtic worship", "global christian", "latin christian", "reggae cristao", "tagalog worship", "world worship"],
    "gospel": ["black gospel", "brazilian gospel", "choir", "gospel", "gospel r&b", "gospel soul", "naija worship", "southern gospel", "spirituals"],
    "gothic metal": ["gothic", "gothic metal", "gothic symphonic metal", "metal gotico"],
    "gothic rock": ["dark post-punk", "deathrock", "gothabilly", "gothic", "gothic rock"],
    "grime": ["eskibeat", "grime", "sublow", "uk grime"],
    "grunge": ["grunge", "grungegaze", "post-grunge", "seattle sound"],
    "hard bop": ["bebop", "bop", "hard bop", "post-bop", "soul jazz"],
    "hard rock": ["glam metal", "hard rock", "hard rock music", "hard rock's", "hard-rock", "hardrock", "hardrockmusic"],
    "hardcore punk": ["crust punk", "d-beat", "hardcore punk", "melodic hardcore", "nyhc", "powerviolence", "skate punk", "straight edge", "youth crew"],
    "hardstyle": ["euphoric hardstyle", "gabber", "hard dance", "hardcore", "hardstyle", "jumpstyle", "rawstyle", "uptempo hardcore"],
    "heavy metal": ["hard rock", "heavy metal", "nwobhm", "traditional heavy metal"],
    "hip hop": ["hip hop", "hip hop's", "hip-hop", "hip-hop music", "hip-hops", "hiphop"],
    "house": ["deep house", "house", "house music", "house's", "housemusic"],
    "idm": ["ambient idm", "braindance", "drill and bass", "fluxwork", "glitch", "glitch hop", "idm", "intelligent dance music", "wonky"],
    "indie": ["indie", "indie's", "indiemusic", "indies"],
    "indie folk": ["chamber folk", "folk-pop", "freak folk", "indie anthem-folk", "indie folk", "new americana", "stomp and holler"],
    "indie pop": ["alt pop", "bedroom pop", "indie pop", "indie poptimism", "shimmer pop", "twee pop"],
    "indietronica": ["indie psych-pop", "indietronica", "metropopolis"],
    "industrial": ["aggrotech", "ebm", "electro-industrial", "industrial", "industrial rock", "martial industrial", "power noise", "industrial metal"],
    "instrumental": ["instrumental", "instrumental's", "instrumentalmusic", "instrumentals", "no vocals"],
    "italian pop": ["classic italian pop", "italian adult pop", "italian indie pop", "italian pop", "italian pop rock", "pop virale italiano"],
    "j-pop": ["anime", "j-division", "j-idol", "j-pop", "j-pop boy group", "j-pop girl group", "j-rap", "japanese teen pop", "kayokyoku", "vocaloid", "japanese electropop"],
    "j-rock": ["j-metal", "j-poprock", "j-rock"],
    "jazz": ["jazz", "jazz's", "jazzier", "jazziest", "jazzmusic", "jazzy"],
    "jazz rap": ["abstract hip hop", "jazz hop", "jazz rap"],
    "jungle": ["jungle", "jungle's", "junglemusic", "jungles"],
    "k-ballad": ["k-ballad", "k-pop ballad"],
    "k-pop": ["korean pop", "kpop"],
    "k-rock": ["k-indie", "k-rock", "korean indie rock"],
    "latin": ["latin", "latin's", "latina", "latinas", "latinmusic", "latino", "latinos"],
    "latin trap": ["trap argentino", "trap boricua", "trap chileno", "trap colombiano", "trap latino", "trap mexicano", "trap venezolano"],
    "lofi": ["chillhop", "lo fi", "lo-fi", "lo-fi beats", "lo-fi chill", "lo-fi cover", "lo-fi jazzhop", "lo-fi sleep", "lo-fi study", "lofi", "sad lo-fi"],
    "medieval": ["early music", "gregorian chant", "medieval", "renaissance"],
    "metal": ["metal", "metal rock", "metal's", "metalhead", "metallic", "metalmusic", "metals"],
    "metalcore": ["chaotic hardcore", "deathcore", "electronicore", "mathcore", "melodic metalcore", "metalcore", "nintendocore", "progressive metalcore"],
    "mpb": ["jovem guarda", "mpb", "nova mpb", "pop folk", "tropicalia", "velha guarda", "violao"],
    "new age": ["new age", "new age music", "new-age", "new-age music", "newage", "newagemusic"],
    "new wave": ["new romantic", "new wave", "new wave pop", "sophisti-pop"],
    "nu jazz": ["broken beat", "future jazz", "jazztronica", "nu jazz"],
    "old school hip hop": ["golden age hip hop", "old school hip hop"],
    "opera": ["arias", "libretto", "opera", "operatic"],
    "pagode": ["pagode", "pagode baiano", "pagode novo", "partido alto", "samba de roda"],
    "persian pop": ["farsi pop", "iranian pop", "persian pop"],
    "persian rock": ["iranian metal", "iranian rock", "persian metal", "persian rock"],
    "persian traditional": ["classical persian", "iranian traditional", "persian traditional", "sonati"],
    "phonk": ["aggressive phonk", "cowbell", "drift phonk", "gym phonk", "memphis phonk", "phonk"],
    "piano": ["piano", "piano cover", "piano music", "solo piano"],
    "pop": ["alt pop", "folk-pop", "pop", "pop music", "pop's", "popmusic", "pops"],
    "pop punk": ["anthem emo", "easycore", "neon pop punk", "pop punk", "socal pop punk"],
    "pop rap": ["commercial rap", "mainstream rap", "melodic rap", "pop rap", "radio rap", "rap pop"],
    "pop rock": ["britpop", "pop rock", "pop rock music", "pop rock's", "pop-rock", "poprock", "poprockmusic", "power pop"],
    "post-hardcore": ["post-hardcore", "swancore"],
    "post-punk": ["dance-punk", "minimal synth", "new rave", "no wave", "post-punk", "uk post-punk"],
    "power metal": ["epic metal", "fantasy metal", "melodic power metal", "power metal"],
    "progressive rock": ["canterbury scene", "crossover prog", "krautrock", "neo-prog", "progressive rock", "symphonic rock"],
    "psychedelic rock": ["acid rock", "neo-psychedelic", "psychedelic pop", "psychedelic rock", "raga rock", "space rock"],
    "punjabi pop": ["bhangra", "desi hip hop", "punjabi pop"],
    "punk": ["punk", "punk's", "punkmusic", "punks", "punky"],
    "r&b": ["neo soul", "r & b", "r and b", "r&b", "r&b's", "rhythm & blues", "rhythm and blues", "rnb", "rnb's", "trap soul"],
    "rap": ["rap", "rapper", "rappers", "raps"],
    "reggae": ["reggae", "reggae music", "reggae's", "reggaemusic"],
    "reggaeton": ["dembow", "neoperreo", "perreo", "pop reggaeton", "reggaeton", "reggaeton chileno", "reggaeton colombiano", "reggaeton flow", "reggaeton mexicano"],
    "regional mexican": ["banda", "banda sinaloense", "corrido", "grupera", "mariachi", "musica mexicana", "norteno", "norteno-sax", "ranchera", "regional mexican", "tejano"],
    "rock": ["power pop", "rock", "rock music", "rock's", "rockin", "rockin'", "rockmusic", "rocks"],
    "salsa": ["boogaloo", "modern salsa", "salsa", "salsa choke", "salsa colombiana", "salsa cubana", "salsa puertorriquena", "salsa urbana", "salsa venezolana", "timba"],
    "samba": ["samba", "samba paulista", "samba-enredo", "samba-rock"],
    "scandinavian pop": ["classic swedish pop", "danish pop", "dansband", "finnish pop", "iskelma", "norwegian pop", "scandipop", "swedish pop"],
    "sertanejo": ["agronejo", "sertanejo", "sertanejo pop", "sertanejo tradicional", "sertanejo universitario"],
    "singer-songwriter": ["acoustic pop", "cantautor", "canzone d'autore", "gen z singer-songwriter", "liedermacher", "lilith", "neo mellow", "singer-songwriter"],
    "soul": ["neo soul", "soul", "soul music", "soul's", "soulful", "soulmusic", "souly"],
    "soundtrack": ["film music", "film score", "game music", "game score", "movie music", "original motion picture soundtrack", "original score", "original soundtrack", "ost", "score", "soundtrack", "theme music", "tv music"],
    "sufi music": ["ghazal", "indian instrumental", "qawwali", "sufi music"],
    "swing": ["big band", "swing"],
    "symphonic metal": ["gothic symphonic metal", "symphonic metal", "symphonic power metal"],
    "synthpop": ["electropop", "synth pop", "synth-pop", "synthpop", "neo-synthpop"],
    "synthwave": ["futuresynth", "outrun", "retrowave", "synth wave", "synth-wave", "synthwave", "synthwave's"],
    "techno": ["tech", "techno", "techno music", "techno's", "technomusic"],
    "trance": ["psytrance", "trance", "trance music", "trance's", "trancemusic", "trancing"],
    "trap": ["atl trap", "cloud rap", "dark trap", "desi trap", "emo trap", "melodic rap", "plugg", "pluggnb", "rage rap", "sad rap", "trap", "trap brasileiro", "trap carioca", "trap queen", "trap soul", "viral rap"],
    "trip hop": ["trip hop", "trip hop's", "trip hops", "triphop", "triphopmusic"],
    "turkish folk": ["turkish folk"],
    "turkish pop": ["arabesk", "turkish pop"],
    "turkish rock": ["anadolu rock", "turkish alternative", "turkish psych", "turkish rock"],
    "uk garage": ["2-step", "bassline", "future garage", "speed garage", "uk garage"],
    "vaporwave": ["broken transmission", "future funk", "mallsoft", "slushwave", "utopian virtual", "vapor trap", "vaporwave"],
    "vgm": ["anime game", "anime score", "gamecore", "indie game soundtrack", "japanese vgm", "nintendocore", "otacore", "rhythm game", "scorecore", "vgm", "vgm remix", "video game music"],
    "vocal jazz": ["crooner", "jazz singing", "lounge music", "vocal jazz"],
    "west coast hip hop": ["g funk", "g-funk", "west coast hip hop", "west coast rap"],
    "christian pop": ["christian pop", "ccm", "deep ccm", "christian music"],
    "worship": ["worship", "worship pop", "pop worship", "anthem worship", "praise", "adoracao", "louvor"],
    "arabic pop": ["arabic pop", "dabke", "egyptian pop", "iraqi pop", "khaliji", "lebanese pop", "maghreb pop", "raÃ¯", "shaabi", "arabic hip hop"],
    "balkan": ["balkan brass", "chalga", "manele", "tallava", "turbo-folk", "yugoslav rock"],
    "bluegrass": ["bluegrass", "jamgrass", "old-time", "progressive bluegrass"],
    "bolero": ["bolero", "bolero cubano", "bolero mexicano"],
    "celtic": ["celtic", "celtic punk", "celtic rock", "irish folk", "scottish folk", "traditional irish"],
    "dangdut": ["campursari", "dangdut", "dangdut koplo"],
    "flamenco": ["flamenco", "flamenco pop", "nuevo flamenco", "rumba", "rumba catalana"],
    "indonesian pop": ["indo pop", "indonesian indie", "indonesian pop", "pop minang"],
    "kizomba": ["ghetto zouk", "kizomba", "semba", "tarraxinha", "zouk"],
    "merengue": ["mambo", "merengue", "merengue tipico", "tecno-merengue"],
    "rockabilly": ["neo-rockabilly", "psychobilly", "rockabilly"],
    "schlager": ["discofox", "german schlager", "partyschlager", "schlager", "volksmusik"],
    "ska": ["rocksteady", "ska", "ska punk", "traditional ska", "two-tone"],
    "soukous": ["congolese rumba", "ndombolo", "soukous"],
    "tango": ["neotango", "tango", "tango cancion"],
    "thai pop": ["luk thung", "mor lam", "t-pop", "thai indie", "thai pop", "thai rock"],
    "vietnamese pop": ["v-pop", "vietnamese hip hop", "vietnamese pop", "vinahouse"],
    "dancehall": ["dancehall", "dancehall queen", "ragga"],
    "dub": ["dub", "dub poetry", "reggae dub"],
    "folk metal": ["celtic metal", "folk metal", "medieval metal", "pagan metal"],
    "highlife": ["burger highlife", "highlife", "igbo highlife"],
    "math rock": ["math pop", "math rock", "midwest math rock"],
    "opm": ["opm", "pinoy indie", "pinoy pop", "pinoy rock", "vispop"],
    "post-rock": ["instrumental post-rock", "post-rock", "post-metal"],
    "russian pop": ["russian dance", "russian hip hop", "russian pop", "russian rock"],
    "soca": ["calypso", "chutney", "soca"],
    "vallenato": ["vallenato", "vallenato moderno"],
    "americana": ["americana", "alternative country", "roots rock", "southern gothic", "stomp and holler"],
    "chiptune": ["8-bit", "bitpop", "chiptune"],
    "enka": ["enka", "japanese traditional"],
    "fado": ["fado", "fado de coimbra", "fado de lisboa", "portuguese folk"],
    "grindcore": ["cybergrind", "goregrind", "grindcore", "pornogrind"],
    "klezmer": ["klezmer", "yiddish folk"],
    "latin jazz": ["afro-cuban jazz", "latin jazz"],
    "polka": ["polka", "slovenian folk"],
    "trot": ["trot", "korean traditional"],
    "zydeco": ["cajun", "louisiana blues", "swamp pop", "zydeco"],
    "afro house": ["afro house", "gqom", "kuduro", "south african house", "3-step", "afro house angolano"],
    "doo-wop": ["doo-wop", "rhythm and blues", "street corner harmony"],
    "french house": ["filter house", "french house", "french touch"],
    "noise": ["harsh noise", "japanoise", "noise", "noise rock", "power electronics"],
    "progressive metal": ["djent", "math metal", "progressive metal", "progressive metalcore"],
    "show tunes": ["broadway", "hollywood", "musical", "show tunes", "theatre", "west end"],
    "thrash metal": ["crossover thrash", "speed metal", "teutonic thrash metal", "thrash metal", "trash metal"],
    "tropical house": ["tropical house", "sax house", "deep tropical house"],
    "children's music": ["children's music", "disney", "kids", "kindermusik", "nursery rhymes"],
    "lullaby": ["lullaby", "baby sleep", "music box"],
    "club": ["baltimore club", "jersey club", "philly club"],
    "comedy": ["comedy", "comedy rock", "parody", "stand-up", "stand-up comedy"],
    "dungeon synth": ["dungeon synth", "fantasy synth"],
    "eurovision": ["eurovision"],
    "kawaii metal": ["kawaii metal", "idol metal", "cute metal"],
    "moombahton": ["moombahton", "moombahcore"],
    "nightcore": ["nightcore", "sped up"],
    "christmas": ["christmas", "christmas pop", "holiday", "carols"],
    "jazz fusion": ["jazz fusion", "fusion", "jazz rock", "electric jazz"],
    "psytrance": ["psytrance", "psychedelic trance", "goa trance", "dark psytrance", "forest psy"],
    "sea shanties": ["sea shanty", "shanty", "maritime"],
    "surf rock": ["surf rock", "surf music", "instrumental surf"],
    "a cappella": ["a cappella", "acappella", "barbershop", "vocal group"],
    "bass house": ["bass house", "g-house", "wobble house"],
    "boogie": ["boogie", "post-disco"],
    "choral": ["choral", "choir", "chamber choir", "gregorian chant"],
    "dark ambient": ["dark ambient", "ritual ambient", "isolationism"],
    "neofolk": ["neofolk", "dark folk", "apocalyptic folk"],
    "new jack swing": ["new jack swing", "90s r&b"],
    "smooth jazz": ["smooth jazz", "contemporary jazz"],
    "breakcore": ["breakcore", "lolicore", "mashcore"],
    "dark cabaret": ["dark cabaret", "cabaret", "circus rock"],
    "eurobeat": ["eurobeat", "para para"],
    "shoegaze": ["shoegaze", "nu gaze", "chillgaze", "blackgaze"],
    "stoner rock": ["stoner rock", "stoner metal", "desert rock", "heavy psych"],
    "visual kei": ["visual kei", "angura kei", "eroguro"],
    "yacht rock": ["yacht rock"],
    "acid jazz": ["acid jazz"],
    "downtempo": ["downtempo", "chillout"],
    "happy hardcore": ["happy hardcore", "uk hardcore", "makina"],
    "riot grrrl": ["riot grrrl"],
    "rock and roll": ["rock & roll", "rock and roll", "rock n roll", "rock n' roll"],
    "oldies": ["oldies", "golden oldies", "classic oldies"],
    "screamo": ["screamo", "skramz", "emoviolence"],
    "slowcore": ["slowcore", "sadcore"],
    "axÃ©": ["axÃ©", "samba-reggae"],
    "hyperpop": ["hyperpop", "digicore", "glitchcore", "dariacore"],
    "ballad": ["ballad", "power ballad", "piano ballad", "pop ballad", "sentimental"],
  };

  const COUNTRY_MAPPINGS = {
    "united states": ["usa", "us", "united states", "united states of america", "america", "american", "u.s.a.", "murica"],
    "canada": ["canada", "canadian", "canadien", "ca", "canuck", "great white north"],
    "mexico": ["mexico", "mexican", "mexicano", "mx", "mex", "aztec"],
    "united kingdom": ["uk", "united kingdom", "britain", "british", "great britain", "england", "english", "scotland", "scottish", "wales", "welsh", "northern ireland", "northern irish", "gb", "gbr", "brit", "albion", "blighty"],
    "ireland": ["ireland", "irish", "eire", "ie", "hibernia", "emerald isle"],
    "france": ["france", "french", "franÃ§ais", "francaise", "francophone", "fr", "hexagon", "gallia"],
    "germany": ["germany", "german", "deutschland", "deutsch", "de", "brd", "allemagne", "aleman"],
    "netherlands": ["netherlands", "dutch", "holland", "flemish", "nl", "nld", "low countries", "nederland"],
    "belgium": ["belgium", "belgian", "be", "belgique", "belgie"],
    "switzerland": ["switzerland", "swiss", "ch", "suisse", "schweiz", "svizzera", "helvetia"],
    "austria": ["austria", "austrian", "at", "osterreich"],
    "sweden": ["sweden", "swedish", "sverige", "svensk", "se", "swe"],
    "norway": ["norway", "norwegian", "norge", "norsk", "no", "nor"],
    "denmark": ["denmark", "danish", "danmark", "dansk", "dk", "dnk"],
    "finland": ["finland", "finnish", "suomi", "fi", "fin"],
    "iceland": ["iceland", "icelandic", "island", "is", "ice"],
    "spain": ["spain", "spanish", "espaÃ±a", "espanol", "castellano", "es", "iberia"],
    "portugal": ["portugal", "portuguese", "portugues", "luso", "pt", "lusitania"],
    "italy": ["italy", "italian", "italia", "italiano", "it", "azzurri"],
    "greece": ["greece", "greek", "ellada", "hellenic", "gr", "hellas"],
    "russia": ["russia", "russian", "rossiya", "russkij", "rus", "ru", "soviet"],
    "ukraine": ["ukraine", "ukrainian", "ua", "ukr", "ukrayina"],
    "poland": ["poland", "polish", "polska", "polski", "pl", "pol"],
    "czech republic": ["czech republic", "czech", "czechia", "cz", "bohemia"],
    "hungary": ["hungary", "hungarian", "magyar", "hu", "hun"],
    "romania": ["romania", "romanian", "ro", "rom"],
    "bulgaria": ["bulgaria", "bulgarian", "bg"],
    "serbia": ["serbia", "serbian", "rs", "srbija"],
    "croatia": ["croatia", "croatian", "hr", "hrvatska"],
    "bosnia": ["bosnia", "herzegovina", "bosnian", "ba", "bih"],
    "albania": ["albania", "albanian", "al", "shqiperia", "shqip"],
    "estonia": ["estonia", "estonian", "eesti", "ee"],
    "latvia": ["latvia", "latvian", "lv", "latvija"],
    "lithuania": ["lithuania", "lithuanian", "lt", "lietuva"],
    "turkey": ["turkey", "turkish", "tÃ¼rkiye", "turkce", "tr", "anatolian", "ottoman"],
    "japan": ["japan", "japanese", "nihon", "nippon", "jp", "jpn", "yamato"],
    "south korea": ["south korea", "korea", "korean", "hanguk", "kr", "kor", "rok", "joseon"],
    "china": ["china", "chinese", "mandarin", "cantonese", "cn", "chn", "prc", "zhongguo", "mainland china", "hk", "hong kong", "taiwan", "taiwanese", "roc"],
    "india": ["india", "indian", "in", "ind", "hindi", "bharat", "desi", "tamil", "telugu", "bhojpuri", "bengali", "malayalam"],
    "pakistan": ["pakistan", "pakistani", "pk", "pak", "urdu"],
    "bangladesh": ["bangladesh", "bengali", "bd", "bangla"],
    "philippines": ["philippines", "filipino", "pinoy", "tagalog", "ph", "phi", "pinas"],
    "indonesia": ["indonesia", "indonesian", "indo", "id", "idn", "nusantara"],
    "vietnam": ["vietnam", "vietnamese", "vn", "vnm", "kinh"],
    "thailand": ["thailand", "thai", "th", "tha", "siam"],
    "malaysia": ["malaysia", "malaysian", "my", "mas", "malay"],
    "singapore": ["singapore", "singaporean", "sg", "sgp", "lion city"],
    "brazil": ["brazil", "brazilian", "brasil", "brasileiro", "brasileira", "br", "bra"],
    "argentina": ["argentina", "argentinian", "argentine", "ar", "arg", "gaucho"],
    "colombia": ["colombia", "colombian", "co", "col", "cafetero"],
    "chile": ["chile", "chilean", "chileno", "cl", "chl"],
    "peru": ["peru", "peruvian", "pe", "per", "inca"],
    "venezuela": ["venezuela", "venezuelan", "ve", "ven"],
    "uruguay": ["uruguay", "uruguayan", "uy", "ury", "charrÃºa"],
    "puerto rico": ["puerto rico", "puerto rican", "boricua", "pr", "pri", "borinquen"],
    "cuba": ["cuba", "cuban", "cu", "cub"],
    "dominican republic": ["dominican republic", "dominican", "dr", "do", "dom", "quisqueya", "quisqueyano"],
    "jamaica": ["jamaica", "jamaican", "jm", "jam", "yardie", "yard"],
    "australia": ["australia", "australian", "aussie", "au", "aus", "oz", "straya", "down under"],
    "new zealand": ["new zealand", "nz", "kiwi", "aotearoa", "zealand"],
    "israel": ["israel", "israeli", "hebrew", "il", "isr", "zion"],
    "egypt": ["egypt", "egyptian", "eg", "egy", "misr"],
    "iran": ["iran", "iranian", "persian", "farsi", "ir", "irn", "Iranis", "irani"],
    "morocco": ["morocco", "moroccan", "ma", "mar", "maroc", "maghreb"],
    "algeria": ["algeria", "algerian", "dz", "dza", "algerie"],
    "nigeria": ["nigeria", "nigerian", "ng", "nga", "naija", "9ja"],
    "south africa": ["south africa", "south african", "za", "zaf", "rsa", "mzansi"],
    "ghana": ["ghana", "ghanaian", "gh", "gha", "gold coast"],
    "kenya": ["kenya", "kenyan", "ke", "ken", "254", "swahili"],
    "senegal": ["senegal", "senegalese", "sn", "sen", "wolof"]
  };

  const mainGenres = Object.keys(GENRE_MAPPINGS);

  async function showGenreFilterModal(tracks, initialTrackGenreMap, rawGenreData, sourceUri) {
    let trackGenreMap = initialTrackGenreMap;
    let allGenres = new Set();
    let genreCounts = new Map();
    let groupGenres = true;

    const refreshGenreStats = () => {
        allGenres.clear();
        genreCounts.clear();
        trackGenreMap.forEach(genres => {
            const uniqueNames = new Set(genres.map(g => g.name));
            uniqueNames.forEach(name => {
                allGenres.add(name);
                genreCounts.set(name, (genreCounts.get(name) || 0) + 1);
            });
        });
    };
    refreshGenreStats();

    const rebuildGenreMap = () => {
        trackGenreMap = new Map();
        tracks.forEach(track => {
            const rawData = rawGenreData.get(track.uri);
            if (rawData) {
                let combined = [
                    ...(rawData.spotify_artist_genres || []).map(g => ({ name: g, source: 'spotify' })),
                    ...(rawData.lastfm_track_genres || []).map(g => ({ name: g, source: 'lastfm_track' })),
                    ...(rawData.lastfm_artist_genres || []).map(g => ({ name: g, source: 'lastfm_artist' })),
                    ...(rawData.deezer_genres || []).map(g => ({ name: g, source: 'deezer' })),
                    ...(rawData.apple_music_genres || []).map(g => ({ name: g, source: 'apple_music' }))
                ];


                let finalUniqueGenres;
                if (groupGenres) {
                    const mapped = mapAndNormalizeGenres(combined);
                    finalUniqueGenres = Array.from(new Set(mapped.map(g => JSON.stringify(g)))).map(s => JSON.parse(s));
                } else {
                    const uniqueRaw = new Map();
                    combined.forEach(g => {
                        const name = g.name.toLowerCase().trim();
                        if (!uniqueRaw.has(name) || (g.source !== 'lastfm_track' && g.source !== 'lastfm_artist')) {
                            uniqueRaw.set(name, { name: name, source: g.source });
                        }
                    });
                    finalUniqueGenres = Array.from(uniqueRaw.values());
                }
                trackGenreMap.set(track.uri, finalUniqueGenres);
            } else {
                trackGenreMap.set(track.uri, []);
            }
        });
        
        refreshGenreStats();
        
        let tracksWithGenresCount = 0;
        trackGenreMap.forEach(genres => {
            if (genres.length > 0) tracksWithGenresCount++;
        });
        totalTracksStat.textContent = `Total tracks: ${tracksWithGenresCount} (${tracks.length})`;
    };

    const existingModal = document.getElementById('genre-filter-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement("div");
    overlay.id = "genre-filter-modal-overlay";
    overlay.className = "sort-play-font-scope";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        z-index: 2002; display: flex; justify-content: center; align-items: center;
        opacity: 0; transition: opacity 0.2s ease;
    `;

    const closeModal = () => {
        overlay.style.opacity = "0";
        setTimeout(() => overlay.remove(), 200);
    };
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            e.preventDefault();
            e.stopPropagation();
        }
    });

    const modalContainer = document.createElement("div");
    modalContainer.className = "genre-filter-modal main-embedWidgetGenerator-container";
    modalContainer.style.cssText = `
        width: 620px !important; 
        max-width: 620px !important;
        display: flex; 
        flex-direction: column;
        border-radius: 30px; 
        background-color: #181818 !important; 
        border: 2px solid #282828;
        max-height: 85vh;
    `;
    const shadowRoot = modalContainer.attachShadow({ mode: 'open' });
    modalContainer.querySelector = (sel) => shadowRoot.querySelector(sel);
    modalContainer.querySelectorAll = (sel) => shadowRoot.querySelectorAll(sel);

    shadowRoot.innerHTML = `
    <style>
    :host { font-family: 'SpotifyMixUI', sans-serif !important; color: #fff; }
    *, button, input, select, textarea { box-sizing: border-box; font-family: 'SpotifyMixUI', sans-serif !important; }
    h1 { margin: 0; line-height: normal; }
    .genre-filter-modal .main-trackCreditsModal-mainSection {
      overflow-y: hidden !important;
      padding: 17px 32px 32px 32px;
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }
    .genre-filter-modal .main-trackCreditsModal-header {
      padding: 29px 32px 19px 32px !important;
      border-bottom: 1px solid #282828 !important;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    .genre-filter-modal .main-trackCreditsModal-closeBtn { 
        background: transparent; 
        border: 0; 
        padding: 0; 
        color: #b3b3b3; 
        cursor: pointer; 
        transition: color 0.2s ease; 
    }
    .genre-filter-modal .main-trackCreditsModal-closeBtn:hover { 
        color: #ffffff; 
    }
    .genre-filter-modal .genre-button {
      padding: 6px 7px 6px 16px;
      margin: 4px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background-color: #303030;
      color: white;
      font-weight: 500;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
      z-index: 0;
      transition: background-color 0.2s ease, color 0.2s ease;
    }
    .genre-filter-modal .genre-button > * {
      position: relative;
      z-index: 2;
    }
    .genre-filter-modal .genre-button::before {
      content: "";
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: 1;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .genre-filter-modal .genre-button.related {
      background-color: rgb(52 123 77 / 30%);
      border: none;
      color: white;
    }
    .genre-filter-modal .genre-button.selected {
      border: none;
      color: #ffffff;
    }
    .genre-filter-modal .genre-button.selected::before {
      background: linear-gradient(to right, rgb(30 215 96 / 35%), rgb(30 215 96 / 80%));
      opacity: 1;
    }
    .genre-filter-modal .genre-button.excluded {
      color: #ffffff;
      border: none;
    }
    .genre-filter-modal .genre-button.excluded::before {
      background: linear-gradient(to right, rgb(169 33 33 / 45%), rgb(169 33 33 / 85%));
      opacity: 1;
    }
    .genre-filter-modal .genre-count-badge {
      background-color: #454545;
      color: #e0e0e0;
      padding: 1px 8px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 400;
      min-width: 22px;
      text-align: center;
      line-height: 1.5;
      transition: background-color 0.1s ease, color 0.1s ease;
    }
    .genre-filter-modal .genre-button.selected .genre-count-badge {
      background-color: rgb(20, 109, 52);
      color: #ffffff;
    }
    .genre-filter-modal .genre-button.excluded .genre-count-badge {
      background-color: rgb(91, 21, 21);
      color: #ffffff;
    }
    .genre-filter-modal .genre-button.related .genre-count-badge {
      background-color: rgb(59, 78, 66);
      color: #ffffff;
    }
    .genre-filter-modal .search-bar {
      width: 100%;
      padding-top: 10px;
      padding-right: 35px;
      padding-bottom: 10px;
      padding-left: 40px;
      border-radius: 12px;
      border: 1px solid #343434;
      background: #1e1e1e;
      color: white;
    }
    .genre-filter-modal .search-bar-container {
      position: relative;
      flex: 1;
      display: flex;
      align-items: center;
    }
    .genre-filter-modal .search-icon {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        pointer-events: none;
        color: #b3b3b3;
    }
    .genre-filter-modal .clear-search-button {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: #b3b3b3;
      cursor: pointer;
      font-size: 24px;
      padding: 0 5px;
      line-height: 1;
      display: none;
    }
    .genre-filter-modal .clear-search-button:hover {
      color: white;
    }
    .genre-filter-modal .sort-type-select {
      padding: 8px;
      border-radius: 10px;
      border: 1px solid #434343;
      background: #313131;
      color: white;
      width: 217px;
      cursor: pointer;
      transition: border-color 0.05s ease;
    }
    .genre-filter-modal .sort-type-select:hover {
      border: 1px solid #5b5b5b;
    }
    .genre-filter-modal .create-playlist-button {
      padding: 8px 18px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background-color: #1ED760;
      color: black;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.04s ease;
      margin-top: 5px;
      flex-shrink: 0;
    }
    .genre-filter-modal .create-playlist-button:hover {
      background-color: #3BE377;
    }
    .genre-filter-modal .genre-container {
      display: flex;
      flex-wrap: wrap;
      height: 100%;
      width: 100%;
      overflow-y: auto;
      background-color: #1e1e1e; 
      border: 1px solid #343434;
      padding: 10px 10px;
      box-sizing: border-box;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-top-left-radius: 12px;
      border-top-right-radius: 12px;
      scrollbar-width: auto;
      scrollbar-color: auto;
    }
    .genre-filter-modal .genre-scroll-wrapper {
        position: relative;
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
        margin-bottom: -15px; 
        margin-top: 2px;
        z-index: 0;
    }
    .genre-filter-modal .genre-scroll-wrapper::before,
    .genre-filter-modal .genre-scroll-wrapper::after {
        content: "";
        position: absolute;
        left: 1px;
        right: 8px;
        height: 26px;
        z-index: 10;
        pointer-events: none;
        transition: opacity 0.2s ease;
        opacity: 0;
    }
    .genre-filter-modal .genre-scroll-wrapper::before {
        top: 1px;
        border-top-left-radius: 12px;
        border-top-right-radius: 12px;
        background: linear-gradient(to bottom, #1e1e1e 0%, rgba(30, 30, 30, 0) 100%);
    }
    .genre-filter-modal .genre-scroll-wrapper::after {
        bottom: 1px;
        background: linear-gradient(to top, #1e1e1e 0%, rgba(30, 30, 30, 0) 100%);
    }
    .genre-filter-modal .genre-scroll-wrapper.no-transition::before,
    .genre-filter-modal .genre-scroll-wrapper.no-transition::after {
        transition: none !important;
    }
    .genre-filter-modal .genre-scroll-wrapper.can-scroll-top::before {
        opacity: 1;
    }
    .genre-filter-modal .genre-scroll-wrapper.can-scroll-bottom::after {
        opacity: 1;
    }
    .genre-filter-modal .genre-container::-webkit-scrollbar {
      width: 6px !important;
    }
    .genre-filter-modal .genre-container::-webkit-scrollbar-button {
      display: none !important;
      height: 0 !important;
      width: 0 !important;
    }
    .genre-filter-modal .genre-container::-webkit-scrollbar-track {
      background: transparent !important; 
      margin-top: 20px !important;
    }
    .genre-filter-modal .genre-container::-webkit-scrollbar-thumb {
      background-color: #343434 !important;
      border-radius: 20px !important;
    }
    .genre-filter-modal .genre-container::-webkit-scrollbar-thumb:hover {
      background-color: #777 !important;
    }
    .genre-filter-modal .genre-container::-webkit-scrollbar-corner {
      background: transparent !important;
    }
    .genre-filter-modal .select-all-button {
      padding: 10px;
      border-radius: 12px;
      border: 1px solid #343434;
      cursor: pointer;
      background-color: #252525; 
      color: white;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.4s ease;  
      display: flex;  
      align-items: center; 
      justify-content: center;
    }
    .genre-filter-modal .select-all-button:hover {
      filter: brightness(1.2); 
    }
    .genre-filter-modal .select-all-button:active {
      background-color: #B3B3B3;
      color: black;
      transition: none;
    }
    .genre-filter-modal .select-all-button svg {
      fill: #b3b3b3; 
    }
    .genre-filter-modal .genre-header {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-shrink: 0;
    }
    .genre-filter-modal .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2px 0;
      width: auto; 
    }
    .genre-filter-modal .switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 24px;
    }
    .genre-filter-modal .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .genre-filter-modal .sliderx {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #484848;
        border-radius: 24px;
        transition: .2s;
    }
    .genre-filter-modal .sliderx:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        border-radius: 50%;
        transition: .2s;
    }
    .genre-filter-modal input:checked + .sliderx {
        background-color: #1DB954;
    }
    .genre-filter-modal input:checked + .sliderx:before {
        transform: translateX(16px);
    }
    .genre-filter-modal .settings-container {
      display: flex;
      gap: 12px;
      flex-shrink: 0;
    }
    .genre-filter-modal .settings-box {
      flex: 1;
      background-color: #252525;
      border-radius: 12px;
      border: 1px solid #343434;
      padding: 12px 16px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 8px;
    }
    .genre-filter-modal .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .genre-filter-modal .setting-label {
      color: #ccc;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .genre-filter-modal .setting-label svg {
      margin-left: 0 !important;
      margin-bottom: 1px !important;
    }
    .genre-filter-modal .sort-type-select {
      padding: 6px 10px !important;
      border-radius: 6px !important;
      border: 1px solid #444 !important;
      background: #333 !important;
      color: white !important;
      width: 100% !important;
      cursor: pointer !important;
      font-size: 14px !important;
    }
    .tooltip-container {
      position: relative; 
      display: inline-block;
    }
    .custom-tooltip {
      visibility: hidden;
      position: absolute;
      z-index: 1;
      background-color: #373737;
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      max-width: 240px;
      width: max-content;
      bottom: 100%;   
      left: 50%;       
      transform: translateX(-50%);  
      margin-bottom: 5px;   
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      line-height: 1.4;
      word-wrap: break-word;
    }
    .custom-tooltip::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: #373737 transparent transparent transparent;
    }
    .tooltip-container:hover .custom-tooltip {
        visibility: visible;
    }
    .genre-filter-modal .genre-stats {
      display: flex;
      justify-content: center; 
      align-items: center;    
      color: #c1c1c1;
      font-size: 14px;
      background-color: #252525;
      padding: 10px 0;
      border: 1px solid #343434;
      border-top: none;
      border-bottom-left-radius: 12px;
      border-bottom-right-radius: 12px;
      margin-bottom: 5px; 
      position: relative;
      z-index: 1; 
      flex-shrink: 0;
    }
    .genre-filter-modal .genre-stats span {
      margin: 0 25px;
    }
    .genre-modal-title {
      font-size: 15px;
      font-weight: 400;
      color: white;
      flex-shrink: 0;
    }
    </style>
    <div class="genre-filter-modal" style="display: flex; flex-direction: column; height: 100%; overflow: hidden;">
    <div class="main-trackCreditsModal-header">
        <h1 style="font-size: 26px; font-weight: 700; color: white; margin:0;">Genre Filter</h1>
        <button id="closeGenreModalBtn" aria-label="Close" class="main-trackCreditsModal-closeBtn">
            <svg width="18" height="18" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M31.098 29.794L16.955 15.65 31.097 1.51 29.683.093 15.54 14.237 1.4.094-.016 1.508 14.126 15.65-.016 29.795l1.414 1.414L15.54 17.065l14.144 14.143" fill="currentColor" fill-rule="evenodd"></path></svg>
        </button>
    </div>

    <div class="main-trackCreditsModal-mainSection">
        <div style="display: flex; flex-direction: column; gap: 15px; flex: 1; min-height: 0;">
        <h2 class="genre-modal-title">
        Genres from Spotify, Last.fm, and Deezer
        <span style="font-size: 0.85em; font-weight: normal; opacity: 0.5; margin-left: 8px;">
        ðŸ’¡ Left-click to include â€¢ Right-click to exclude
        </span>
        </h2>
            <div class="genre-header">
            <div class="search-bar-container">
                    <svg class="search-icon" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path d="M 7 1.75 a 5.25 5.25 0 1 0 0 10.5 a 5.25 5.25 0 0 0 0 -10.5 M 0.25 7 a 6.75 6.75 0 1 1 12.096 4.12 l 3.184 3.185 a 0.75 0.75 0 1 1 -1.06 1.06 L 11.304 12.2 A 6.75 6.75 0 0 1 0.25 7"></path>
                    </svg>
                    <input type="text" class="search-bar" placeholder="Search genres...">
                    <button class="clear-search-button">&times;</button>
                </div>
                <button class="select-all-button" title="Select All">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18px" height="18px">
                        <path d="M 4 2 C 2.895 2 2 2.895 2 4 L 2 16 C 2 17.105 2.895 18 4 18 L 16 18 C 17.105 18 18 17.105 18 16 L 18 4 C 18 2.895 17.105 2 16 2 L 4 2 z M 4 4 L 16 4 L 16 16 L 4 16 L 4 4 z M 20 6 L 20 20 L 6 20 L 6 22 L 20 22 C 21.105 22 22 21.105 22 20 L 22 6 L 20 6 z M 13.292969 6.2929688 L 9 10.585938 L 6.7070312 8.2929688 L 5.2929688 9.7070312 L 9 13.414062 L 14.707031 7.7070312 L 13.292969 6.2929688 z"/>
                    </svg>
                </button>
            </div>
            <div class="genre-scroll-wrapper">
                <div class="genre-container"></div>
            </div>
            <div class="genre-stats">
                <span id="total-tracks-stat">Total tracks: 0</span>
                <span id="filtered-tracks-stat">Filtered tracks: 0</span>
            </div>
            <div class="settings-container">
                <div class="settings-box">
                    <div class="setting-row">
                        <span class="setting-label">Sort Order</span>
                    </div>
                    <div class="setting-row">
                        <select class="sort-type-select">
                            <option value="default">Default</option>
                            <option value="playCount">Play Count</option>
                            <option value="popularity">Popularity</option>
                            <option value="releaseDate">Release Date</option>
                            <option value="shuffle">Shuffle</option>
                            <option value="scrobbles">Scrobbles</option>
                            <option value="personalScrobbles">My Scrobbles</option>
                        </select>
                    </div>
                </div>
                <div class="settings-box">
                    <div class="setting-row">
                        <label class="setting-label" for="groupGenresToggle">
                            Group Similar
                            <span class="tooltip-container">
                                ${infoIconSvg}
                                <span class="custom-tooltip">Merges variations (e.g. 'electro' -> 'electronic').</span>
                            </span>
                        </label>
                        <label class="switch">
                            <input type="checkbox" id="groupGenresToggle" checked>
                            <span class="sliderx"></span>
                        </label>
                    </div>
                    <div class="setting-row">
                        <label class="setting-label" for="matchAllGenresToggle">
                            Match All
                            <span class="tooltip-container">
                                ${infoIconSvg}
                                <span class="custom-tooltip">Tracks must match ALL selected genres.</span>
                            </span>
                        </label>
                        <label class="switch">
                            <input type="checkbox" id="matchAllGenresToggle" ${matchAllGenres ? 'checked' : ''}>
                            <span class="sliderx"></span>
                        </label>
                    </div>
                </div>
            </div>
            <div id="genre-selection-error" style="color: #f15e6c; font-size: 13px; text-align: center; display: none;"></div>
            <button class="create-playlist-button">Create Playlist</button>
        </div>
    </div>
    </div>
  `;

    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);

    modalContainer.querySelector('#closeGenreModalBtn').addEventListener('click', closeModal);
    preventDragCloseModal();

    const matchAllGenresToggle = modalContainer.querySelector("#matchAllGenresToggle");
    const groupGenresToggle = modalContainer.querySelector("#groupGenresToggle");
    const genreContainer = modalContainer.querySelector(".genre-container");
    const genreScrollWrapper = modalContainer.querySelector(".genre-scroll-wrapper");
    const searchBar = modalContainer.querySelector(".search-bar");
    const clearSearchButton = modalContainer.querySelector(".clear-search-button");
    const sortTypeSelect = modalContainer.querySelector(".sort-type-select");
    const createPlaylistButton = modalContainer.querySelector(".create-playlist-button");
    const selectAllButton = modalContainer.querySelector(".select-all-button");
    const selectionErrorDiv = modalContainer.querySelector("#genre-selection-error");

    const totalTracksStat = modalContainer.querySelector("#total-tracks-stat");
    const filteredTracksStat = modalContainer.querySelector("#filtered-tracks-stat");

    const lastSelectedSort = localStorage.getItem(STORAGE_KEY_GENRE_FILTER_SORT) || "default";
    sortTypeSelect.value = lastSelectedSort;

    sortTypeSelect.addEventListener("change", () => {
      localStorage.setItem(STORAGE_KEY_GENRE_FILTER_SORT, sortTypeSelect.value);
    });

    const updateScrollFades = () => {
        const scrollTop = genreContainer.scrollTop;
        const scrollHeight = genreContainer.scrollHeight;
        const clientHeight = genreContainer.clientHeight;
        
        if (scrollTop > 0) {
            genreScrollWrapper.classList.add('can-scroll-top');
        } else {
            genreScrollWrapper.classList.remove('can-scroll-top');
        }

        if (scrollHeight > clientHeight && scrollTop + clientHeight < scrollHeight - 1) {
            genreScrollWrapper.classList.add('can-scroll-bottom');
        } else {
            genreScrollWrapper.classList.remove('can-scroll-bottom');
        }
    };

    genreContainer.addEventListener('scroll', updateScrollFades);
    
    new ResizeObserver(() => updateScrollFades()).observe(genreContainer);

    genreContainer.addEventListener('scroll', updateScrollFades);
    matchAllGenresToggle.addEventListener("change", () => {
      matchAllGenres = matchAllGenresToggle.checked;
      saveSettings();
      updateFilteredTracksCount();
    setTimeout(updateScrollFades, 50);
    });
    
    groupGenresToggle.addEventListener("change", () => {
        const oldSelectedSet = new Set(selectedGenres);
        const oldExcludedSet = new Set(excludedGenres);
        
        groupGenres = groupGenresToggle.checked;
        
        const newSelectedSet = new Set();
        const newExcludedSet = new Set();

        if (groupGenres) {
            
            const uniqueSelectedRawGenres = new Set();
            const uniqueExcludedRawGenres = new Set();

            tracks.forEach(track => {
                const rawData = rawGenreData.get(track.uri);
                if (!rawData) return;
                const rawGenres = [
                    ...(rawData.spotify_artist_genres || []),
                    ...(rawData.lastfm_track_genres || []),
                    ...(rawData.lastfm_artist_genres || []),
                    ...(rawData.deezer_genres || [])
                ];
                rawGenres.forEach(r => {
                    if (oldSelectedSet.has(r)) uniqueSelectedRawGenres.add(r);
                    if (oldExcludedSet.has(r)) uniqueExcludedRawGenres.add(r);
                });
            });

            const processVotes = (rawGenreSet) => {
                const sVotes = new Set();
                const wVotes = new Set();
                
                rawGenreSet.forEach(rawGenre => {
                    const mappedGroupObjects = mapAndNormalizeGenres([{ name: rawGenre, source: 'spotify' }]);
                    const groupNames = [...new Set(mappedGroupObjects.map(o => o.name))];
                    
                    if (groupNames.length === 1) {
                        sVotes.add(groupNames[0]);
                    } else {
                        groupNames.forEach(g => wVotes.add(g));
                    }
                });
                
                const finalSet = new Set();
                if (sVotes.size > 0) {
                    sVotes.forEach(g => finalSet.add(g));
                } else {
                    wVotes.forEach(g => finalSet.add(g));
                }
                return finalSet;
            };

            const selectedGroups = processVotes(uniqueSelectedRawGenres);
            const excludedGroups = processVotes(uniqueExcludedRawGenres);
            
            selectedGroups.forEach(g => newSelectedSet.add(g));
            excludedGroups.forEach(g => newExcludedSet.add(g));

        } else {
            tracks.forEach(track => {
                const rawData = rawGenreData.get(track.uri);
                if (!rawData) return;

                const rawGenres = [
                    ...(rawData.spotify_artist_genres || []),
                    ...(rawData.lastfm_track_genres || []),
                    ...(rawData.lastfm_artist_genres || []),
                    ...(rawData.deezer_genres || [])
                ];

                rawGenres.forEach(rawGenre => {
                    const mappedGroupObjects = mapAndNormalizeGenres([{ name: rawGenre, source: 'spotify' }]);
                    const groupNames = mappedGroupObjects.map(o => o.name);

                    const isGroupSelected = groupNames.some(g => oldSelectedSet.has(g));
                    const isGroupExcluded = groupNames.some(g => oldExcludedSet.has(g));
                    
                    if (isGroupSelected) newSelectedSet.add(rawGenre);
                    if (isGroupExcluded) newExcludedSet.add(rawGenre);
                });
            });
        }

        selectedGenres = Array.from(newSelectedSet);
        excludedGenres = Array.from(newExcludedSet);

        rebuildGenreMap();
        updateGenreButtons();
        updateFilteredTracksCount();
    });
    
    let selectedGenres = [];
    let excludedGenres = [];
    let tracksWithGenresCount = 0;
    trackGenreMap.forEach(genres => {
      if (genres.length > 0) tracksWithGenresCount++;
    });
    totalTracksStat.textContent = `Total tracks: ${tracksWithGenresCount} (${tracks.length})`;
    filteredTracksStat.textContent = `Filtered tracks: 0`;

    function updateFilteredTracksCount() {
      const filteredTracks = filterTracksByGenres(
        tracks,
        selectedGenres,
        excludedGenres,
        trackGenreMap  
      );
      filteredTracksStat.textContent = `Filtered tracks: ${filteredTracks.length}`;

      const relatedGenres = new Set();
      if (selectedGenres.length > 0) {
          filteredTracks.forEach(track => {
              const genresOnTrack = trackGenreMap.get(track.uri);
              if (genresOnTrack) {
                  genresOnTrack.forEach(genre => {
                      relatedGenres.add(genre.name);
                  });
              }
          });

          selectedGenres.forEach(genre => {
              relatedGenres.delete(genre);
          });
      }

      const genreButtons = genreContainer.querySelectorAll('.genre-button');
      genreButtons.forEach(button => {
          const genreName = button.querySelector('span:first-child').textContent;

          button.classList.remove('selected', 'excluded', 'related');

          if (selectedGenres.includes(genreName)) {
              button.classList.add('selected');
          } else if (excludedGenres.includes(genreName)) {
              button.classList.add('excluded');
          } else if (relatedGenres.has(genreName)) {
              button.classList.add('related');
          }
      });
    }

    function updateGenreButtons() {
      genreContainer.innerHTML = "";
      const searchTerm = searchBar.value.toLowerCase();
      const filteredGenres = Array.from(allGenres).filter((genre) =>
        genre.toLowerCase().includes(searchTerm)
      );
    
      const uriToArtistMap = new Map();
      const playlistArtistNames = new Set();
      tracks.forEach(t => {
          const name = t.artistName || (t.artists && t.artists[0]?.name) || "";
          if (name) {
              playlistArtistNames.add(name.toLowerCase());
              uriToArtistMap.set(t.uri, name.toLowerCase());
          }
      });
      const totalUniqueArtistsInPlaylist = playlistArtistNames.size;
    
      const genreDetails = new Map();
      trackGenreMap.forEach((genresOnTrack, trackUri) => {
        const trackArtist = uriToArtistMap.get(trackUri) || "";
        const uniqueGenreNamesOnTrack = new Set(genresOnTrack.map(g => g.name));
        
        uniqueGenreNamesOnTrack.forEach(genreName => {
            if (filteredGenres.includes(genreName)) {
                const genreData = genresOnTrack.find(g => g.name === genreName);
                if (!genreDetails.has(genreName)) {
                    const normalizedKey = getNormalizedGenreKey(genreName);
                    let isMapped = !!VARIANT_TO_MAIN_GENRE_MAP[normalizedKey] || !!VARIANT_TO_MAIN_COUNTRY_MAP[normalizedKey];
                    
                    if (!isMapped) {
                        isMapped = mainGenres.some(key => genreName.toLowerCase().includes(key.toLowerCase()));
                        
                        if (!isMapped) {
                             const countryKeys = Object.keys(COUNTRY_MAPPINGS);
                             isMapped = countryKeys.some(key => genreName.toLowerCase().includes(key.toLowerCase()));
                        }
                    }

                    genreDetails.set(genreName, {
                        name: genreName,
                        isTrusted: false,
                        count: 0,
                        artists: new Set(),
                        isMapped: isMapped,
                        isSelfTitle: false
                    });
                }
                const details = genreDetails.get(genreName);
                details.count++;
                if (trackArtist) details.artists.add(trackArtist);

                if (genreData?.source === 'spotify' || genreData?.source === 'deezer' || genreData?.source === 'apple_music') {
                    details.isTrusted = true;
                }
                
                if (trackArtist && genreName.toLowerCase() === trackArtist) {
                    details.isSelfTitle = true;
                }
            }
        });
      });
    
      const sortedGenres = filteredGenres.sort((a, b) => {
        const detailsA = genreDetails.get(a) || { count: 0, isTrusted: false, artists: new Set(), isMapped: false };
        const detailsB = genreDetails.get(b) || { count: 0, isTrusted: false, artists: new Set(), isMapped: false };

        const getTier = (details) => {
            if (details.isTrusted) return 1;
            if (details.isMapped) return 1;
            if (details.isSelfTitle) return 2;
            if (details.name.length < 2) return 2;
            if (details.artists.size >= 3) return 1;
            if (details.count >= 15 && details.artists.size >= 2) return 1;
            if (totalUniqueArtistsInPlaylist < 3) {
                const threshold = Math.min(4, Math.max(2, Math.ceil(tracks.length * 0.05)));
                if (details.count >= threshold) return 1;
            }
            return 2;
        };

        const tierA = getTier(detailsA);
        const tierB = getTier(detailsB);

        if (tierA !== tierB) {
            return tierA - tierB;
        }

        if (detailsB.count !== detailsA.count) {
            return detailsB.count - detailsA.count;
        }

        if (detailsA.isTrusted && !detailsB.isTrusted) return -1;
        if (!detailsA.isTrusted && detailsB.isTrusted) return 1;

        return a.localeCompare(b);
      });
    
      if (sortedGenres.length === 0) {
        const noGenreMessage = document.createElement("div");
        noGenreMessage.textContent = "No genre found";
        noGenreMessage.style.color = "#666";
        noGenreMessage.style.textAlign = "center";
        noGenreMessage.style.padding = "10px";
        genreContainer.appendChild(noGenreMessage);
      } else {
        sortedGenres.forEach((genre) => {
          const genreButton = document.createElement("button");
          genreButton.classList.add("genre-button");
          
          const genreNameSpan = document.createElement("span");
          genreNameSpan.textContent = genre;

          const countBadge = document.createElement("span");
          countBadge.classList.add("genre-count-badge");
          const count = genreCounts.get(genre) || 0;
          countBadge.textContent = count;

          genreButton.appendChild(genreNameSpan);
          genreButton.appendChild(countBadge);

          if (selectedGenres.includes(genre)) {
            genreButton.classList.add("selected");
          } else if (excludedGenres.includes(genre)) {
            genreButton.classList.add("excluded");
          }
    
          genreButton.addEventListener("click", () => {
            if (excludedGenres.includes(genre)) {
              excludedGenres = excludedGenres.filter((g) => g !== genre);
            }
            if (selectedGenres.includes(genre)) {
              selectedGenres = selectedGenres.filter((g) => g !== genre);
            } else {
              selectedGenres.push(genre);
            }
            updateFilteredTracksCount();
          });

          genreButton.addEventListener("contextmenu", (event) => {
            event.preventDefault();
            if (selectedGenres.includes(genre)) {
              selectedGenres = selectedGenres.filter((g) => g !== genre);
            }
            if (excludedGenres.includes(genre)) {
              excludedGenres = excludedGenres.filter((g) => g !== genre);
            } else {
              excludedGenres.push(genre);
            }
            updateFilteredTracksCount();
          });
    
          genreContainer.appendChild(genreButton);
        });
      }
    updateFilteredTracksCount();
    }

    searchBar.addEventListener("input", () => {
      updateGenreButtons();
      clearSearchButton.style.display = searchBar.value.length > 0 ? 'block' : 'none';
    });

    clearSearchButton.addEventListener("click", () => {
        searchBar.value = "";
        const event = new Event('input', { bubbles: true });
        searchBar.dispatchEvent(event);
        searchBar.focus();
    });
    
    selectAllButton.addEventListener("click", () => {
      const searchTerm = searchBar.value.toLowerCase();
      const filteredGenres = Array.from(allGenres).filter((genre) => 
        genre.toLowerCase().includes(searchTerm)
      );
      
      const allSelected = filteredGenres.every((genre) => selectedGenres.includes(genre));

      selectedGenres = selectedGenres.filter((genre) => !filteredGenres.includes(genre));
      excludedGenres = excludedGenres.filter((genre) => !filteredGenres.includes(genre));

      if (!allSelected) {
        filteredGenres.forEach((genre) => {
          if (!selectedGenres.includes(genre)) {
            selectedGenres.push(genre);
          }
        });
      }
      
      updateGenreButtons();
      updateFilteredTracksCount();
    });

    searchBar.addEventListener("input", updateGenreButtons);
    updateGenreButtons();

    genreScrollWrapper.classList.add('no-transition');
    
    updateScrollFades();

    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            overlay.style.opacity = "1";
            
            setTimeout(() => {
                genreScrollWrapper.classList.remove('no-transition');
            }, 200);
        });
    });

    createPlaylistButton.addEventListener("click", async () => {
      selectionErrorDiv.style.display = 'none';
      if (selectedGenres.length === 0 && excludedGenres.length === 0) {
          showNotification("Please select at least one genre to include or exclude.", true);
          return;
      }
    
      const filteredTracks = filterTracksByGenres(
          tracks,
          selectedGenres,
          excludedGenres,
          trackGenreMap
      );
    
      if (filteredTracks.length === 0) {
          showNotification("No tracks found for the selected genres.");
          return;
      }
    
      const sortType = sortTypeSelect.value;
      closeModal();
    
      let sortedTracks; 
    
      async function createAndPopulatePlaylist(sortedTracks, playlistName, playlistDescription) {
          try {
              mainButton.innerText = "Creating...";
              const newPlaylist = await createPlaylist(playlistName, playlistDescription);
              await new Promise(resolve => setTimeout(resolve, 1250));
              mainButton.innerText = "Saving...";
    
              const trackUris = sortedTracks.map((track) => track.uri);
              await addTracksToPlaylist(newPlaylist.id, trackUris);
    
              await addPlaylistToLibrary(newPlaylist.uri);
    
              const sortTypeInfo = {
                  default: { fullName: "default order", shortName: "Default" },
                  playCount: { fullName: "play count", shortName: "PlayCount" },
                  popularity: { fullName: "popularity", shortName: "Popularity" },
                  releaseDate: { fullName: "release date", shortName: "ReleaseDate" },
                  scrobbles: { fullName: "Last.fm scrobbles", shortName: "Scrobbles" },
                  personalScrobbles: { fullName: "Last.fm personal scrobbles", shortName: "My Scrobbles" },
                  shuffle: { fullName: "shuffle", shortName: "Shuffle" },
                  aiPick: { fullName: "AI pick", shortName: "AI Pick" },
                  averageColor: { fullName: "album color", shortName: "Color" },
              }[sortType];
              showNotification(
                  `Playlist created with ${sortTypeInfo.fullName} and genre filter!`
              );
              
              await navigateToPlaylist(newPlaylist);
    
          } catch (error) {
              console.error("Error creating or updating playlist:", error);
              showNotification(
                  `An error occurred while creating or updating the playlist. Please check your internet connection and try again.`
              );
          } finally {
              resetButtons();
          }
      }
    
    
      let sourceName = "Source";
      const sourceId = sourceUri.split(":")[2];

      try {
          if (URI.isArtist(sourceUri)) {
              const fetchArtistFallback = async () => {
                  const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, { uri: sourceUri, locale: "en", includePrerelease: false });
                  return res.data.artistUnion.profile.name;
              };

              if (isFallbackActive()) {
                  sourceName = await fetchArtistFallback();
              } else {
                  try {
                      const artistData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists/${sourceId}`);
                      sourceName = artistData.name;
                  } catch (e) {
                      if (registerWebApiFailure()) {
                          sourceName = await fetchArtistFallback();
                      } else { throw e; }
                  }
              }
          } else if (isLikedSongsPage(sourceUri)) {
              sourceName = "Liked Songs";
          } else if (URI.isAlbum(sourceUri)) {
              const fetchAlbumFallback = async () => {
                  const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: sourceUri, locale: "en", offset: 0, limit: 1 });
                  return res.data.albumUnion.name;
              };

              if (isFallbackActive()) {
                  sourceName = await fetchAlbumFallback();
              } else {
                  try {
                      const albumData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${sourceId}`);
                      sourceName = albumData.name;
                  } catch (e) {
                      if (registerWebApiFailure()) {
                          sourceName = await fetchAlbumFallback();
                      } else { throw e; }
                  }
              }
          } else {
              const fetchPlaylistFallback = async () => {
                  const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(sourceUri);
                  return meta.name;
              };

              if (isFallbackActive()) {
                  sourceName = await fetchPlaylistFallback();
              } else {
                  try {
                      const playlistData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${sourceId}`);
                      sourceName = playlistData.name;
                  } catch (e) {
                      if (registerWebApiFailure()) {
                          sourceName = await fetchPlaylistFallback();
                      } else { throw e; }
                  }
              }
          }
      } catch (e) {
          console.warn("Failed to fetch source name for Genre Filter playlist", e);
      }
    
      let suffixPattern = new RegExp(
          `\\s*(${possibleSuffixes.join("|")})\\s*`
      );
    
      while (suffixPattern.test(sourceName)) {
          sourceName = sourceName.replace(suffixPattern, "");
      }
    
    
      let baseDescription = `Filtered using Sort-Play by genres: `;
      if (URI.isArtist(sourceUri)) {
          baseDescription = `Tracks by ${sourceName} ` + baseDescription;
      } else if (URI.isAlbum(sourceUri)) {
          let artistName = "Unknown Artist";
          try {
              const fetchAlbumArtistFallback = async () => {
                  const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: sourceUri, locale: "en", offset: 0, limit: 1 });
                  return res.data.albumUnion.artists.items[0]?.profile?.name || "Unknown Artist";
              };

              if (isFallbackActive()) {
                  artistName = await fetchAlbumArtistFallback();
              } else {
                  try {
                      const albumDetails = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${sourceUri.split(":")[2]}`);
                      artistName = albumDetails.artists[0].name;
                  } catch (e) {
                      if (registerWebApiFailure()) {
                          artistName = await fetchAlbumArtistFallback();
                      } else { throw e; }
                  }
              }
          } catch (e) {}
          baseDescription = `Tracks from ${sourceName} by ${artistName} ` + baseDescription;
      }
    
      let playlistDescription = baseDescription;
      let genreList = "";
      let addedGenres = 0;
    
      for (const genre of selectedGenres) {
          const potentialGenreList = genreList ? `${genreList}, ${genre}` : genre;
          if ((playlistDescription.length + potentialGenreList.length) <= 247) { 
              genreList = potentialGenreList;
              addedGenres++;
          } else {
              break; 
          }
      }
      if (addedGenres < selectedGenres.length) {
          playlistDescription += genreList + ",...";
      } else {
          playlistDescription += genreList + ".";
      }
    
      const playlistName = `${sourceName} (Genre Filter)`; 
    
      if (sortType === "default") {
        sortedTracks = filteredTracks;
        setButtonProcessing(true);
        mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
        mainButton.style.color = buttonStyles.main.disabledColor;
        mainButton.style.cursor = "default";
        svgElement.style.fill = buttonStyles.main.disabledColor;
        menuButtons.forEach((button) => (button.disabled = true));
        mainButton.innerHTML = "100%";
        await createAndPopulatePlaylist(sortedTracks, playlistName, playlistDescription);
      } else if (sortType === "playCount" || sortType === "popularity" || sortType === "shuffle" || sortType === "releaseDate") {
          setButtonProcessing(true);
          mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
          mainButton.style.color = buttonStyles.main.disabledColor;
          mainButton.style.cursor = "default";
          svgElement.style.fill = buttonStyles.main.disabledColor;
          menuButtons.forEach((button) => (button.disabled = true));
          mainButton.innerHTML = "0%";
    
          const tracksWithPlayCounts = await enrichTracksWithPlayCounts(
              filteredTracks,
              (progress) => {
                  mainButton.innerText = `${Math.floor(progress * 0.20)}%`;
              }
          );
          const tracksWithIds = await processBatchesWithDelay(
              tracksWithPlayCounts,
              50,
              500,
              (progress) => {
                  mainButton.innerText = `${20 + Math.floor(progress * 0.20)}%`;
              },
              collectTrackIdsForPopularity
          );
          const tracksWithPopularity = await fetchPopularityForMultipleTracks(
              tracksWithIds,
              (progress) => {
                  mainButton.innerText = `${40 + Math.floor(progress * 0.20)}%`;
              }
          );
    
          let uniqueTracks;
    
          if (sortType === "releaseDate") {
              const tracksWithReleaseDates = await processBatchesWithDelay(
                  tracksWithPopularity,
                  50,
                  500,
                  (progress) => {
                      mainButton.innerText = `${60 + Math.floor(progress * 0.20)}%`;
                  },
                  getTrackDetailsWithReleaseDate
              );
              uniqueTracks = (await deduplicateTracks(
                  tracksWithReleaseDates, 
                  false, 
                  false,
                  (progress) => { mainButton.innerText = `Dedup ${progress}%`; }
              )).unique;
          } else {
              uniqueTracks = (await deduplicateTracks(
                  tracksWithPopularity, 
                  false, 
                  false,
                  (progress) => { mainButton.innerText = `Dedup ${progress}%`; }
              )).unique;
          }
    
          if (sortType === "playCount") {
            const getVal = (t) => (t.playCount === "N/A" || t.playCount == null) ? -1 : Number(t.playCount);
            sortedTracks = uniqueTracks.sort((a, b) => 
                sortOrderState.playCount ? getVal(a) - getVal(b) : getVal(b) - getVal(a)
            );
          } else if (sortType === "popularity") {
            const getVal = (t) => (t.popularity == null) ? -1 : Number(t.popularity);
            sortedTracks = uniqueTracks.sort((a, b) => 
                sortOrderState.popularity ? getVal(a) - getVal(b) : getVal(b) - getVal(a)
            );
        } else if (sortType === "releaseDate") {
          sortedTracks = uniqueTracks
            .sort((a, b) => {
              const valA = a.releaseDate ? new Date(a.releaseDate).getTime() : 0;
              const valB = b.releaseDate ? new Date(b.releaseDate).getTime() : 0;

              const dateComparison = sortOrderState.releaseDate
                ? valA - valB
                : valB - valA;
    
              if (dateComparison !== 0) {
                return dateComparison;
              }

              const albumA = (a.albumName || "").toLowerCase();
              const albumB = (b.albumName || "").toLowerCase();
              const albumCompare = albumA.localeCompare(albumB);
              if (albumCompare !== 0) return albumCompare;
              
              return (a.trackNumber || 0) - (b.trackNumber || 0);
            });
        } else if (sortType === "shuffle") {
          sortedTracks = shuffleArray(uniqueTracks);
        }
    
          mainButton.innerText = "100%";
    
          await createAndPopulatePlaylist(sortedTracks, playlistName, playlistDescription);
    
      } else if (sortType === "scrobbles" || sortType === "personalScrobbles") {
          try {
              setButtonProcessing(true);
              mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
              mainButton.style.color = buttonStyles.main.disabledColor;
              mainButton.style.cursor = "default";
              svgElement.style.fill = buttonStyles.main.disabledColor;
              menuButtons.forEach((button) => (button.disabled = true));
              mainButton.innerHTML = "0%";
    
              const result = await handleScrobblesSorting(
                  filteredTracks,
                  sortType,
                  (progress) => {
                      mainButton.innerText = `${Math.floor(progress * 0.90)}%`;
                  }
              );
              sortedTracks = result.sortedTracks; 
              const totalTracks = sortedTracks.length;
              sortedTracks.forEach((_, index) => {
                  const progress = 90 + Math.floor(((index + 1) / totalTracks) * 10);
                  mainButton.innerText = `${progress}%`;
              });
              mainButton.innerText = "100%";
    
              await createAndPopulatePlaylist(sortedTracks, playlistName, playlistDescription);
    
    
          } catch (error) {
              resetButtons();
              showNotification(error.message);
              return;
          }
      }
    });
  }

  
  function isTrackRecent(releaseDateString) {
    const releaseDate = new Date(releaseDateString);
    const twoWeeksAgo = new Date();
    twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);
  
    return releaseDate >= twoWeeksAgo;
  }
  
  const CONFIG = {
    concurrencyLimit: 20,
    batchDelay: 200,
    lastfm: {
      apiKey: '***REMOVED***',
      baseUrl: 'https://ws.audioscrobbler.com/2.0/',
      retryAttempts: 3,
      retryDelay: 1000,
    },
    spotify: {
      retryAttempts: 3,
      retryDelay: 1000,
    }
  };

  function canCallSpotifyApi() {
    const now = Date.now();
    const oneSecondAgo = now - 1000;

    spotifyApiLimits.requests = spotifyApiLimits.requests.filter(
        (timestamp) => timestamp > oneSecondAgo
    );

    return spotifyApiLimits.requests.length < spotifyApiLimits.maxRequestsPerSecond;
  }

  async function callSpotifyApiWithRateLimit(fn) {
    while (!canCallSpotifyApi()) {
        await new Promise((resolve) => setTimeout(resolve, 50)); 
    }

    spotifyApiLimits.requests.push(Date.now());
    return await fn();
  }

  async function withRetry(fn, retryAttempts, retryDelay) {
    let lastError;
    for (let attempt = 0; attempt < retryAttempts; attempt++) {
        try {
            const response = await callSpotifyApiWithRateLimit(fn);
            
            if (response?.code === 429) {
                const error = new Error("Too Many Requests");
                error.status = 429;
                throw error;
            }
            
            if (response?.error) {
                const error = new Error(response.message || response.error);
                error.status = response.code;
                throw error;
            }
            
            return response;
        } catch (error) {
            lastError = error;
            let waitTime = retryDelay * Math.pow(2, attempt); 
            waitTime += Math.random() * retryDelay;          
            waitTime = Math.min(waitTime, 60000);            

            if (error.status === 429) {
                waitTime = Math.max(5000, waitTime); 
            }
            
            console.warn(`Attempt ${attempt + 1}/${retryAttempts} failed. Waiting ${waitTime}ms before retry...`);
            
            if (attempt < retryAttempts - 1) {
                await new Promise((resolve) => setTimeout(resolve, waitTime));
            }
        }
    }
    throw lastError;
  }

  async function getLastfmGenres(artist, track) {
    const cacheKey = `${artist}-${track}`;
    if (lastfmCache.has(cacheKey)) {
        return lastfmCache.get(cacheKey);
    }
  
    const result = { track_genres: [], artist_genres: [] };
  
    try {
        const safeJson = async (response) => {
            try {
                const text = await response.text();
                return text ? JSON.parse(text) : null;
            } catch (e) {
                return null;
            }
        };

        const promises = [];

        promises.push((async () => {
            const params = new URLSearchParams({ method: 'track.getInfo', artist, track, format: 'json' });
            return fetchLfmWithGateway(params);
        })());

        let cachedArtistTags = null;
        if (lastfmArtistTagsCache.has(artist)) {
            cachedArtistTags = lastfmArtistTagsCache.get(artist);
        } else {
            promises.push((async () => {
                const params = new URLSearchParams({ method: 'artist.getInfo', artist, format: 'json' });
                return fetchLfmWithGateway(params);
            })());
        }

        const responses = await Promise.all(promises);
        const trackResponse = responses[0];
        const artistResponse = !cachedArtistTags && responses.length > 1 ? responses[1] : null;
  
        if (!trackResponse.ok && trackResponse.status !== 404) {
             throw new Error(`Last.fm track network error: ${trackResponse.status}`);
        }

        if (trackResponse.ok) {
            const trackData = await safeJson(trackResponse);
            if (trackData && trackData.error) {
                if (trackData.error !== 6) {
                    throw new Error(`Last.fm API error: ${trackData.message}`);
                }
            } else if (trackData?.track?.toptags?.tag) {
                result.track_genres = trackData.track.toptags.tag
                    .map(tag => tag.name.toLowerCase())
                    .filter(g => !/^\d+$/.test(g));
            }
        }
  
        if (cachedArtistTags) {
            result.artist_genres = cachedArtistTags;
        } else if (artistResponse) {
            if (!artistResponse.ok && artistResponse.status !== 404) {
                 throw new Error(`Last.fm artist network error: ${artistResponse.status}`);
            }

            if (artistResponse.ok) {
                const artistData = await safeJson(artistResponse);
                if (artistData && artistData.error) {
                    if (artistData.error !== 6) {
                        throw new Error(`Last.fm API error: ${artistData.message}`);
                    }
                } else if (artistData?.artist?.tags?.tag) {
                    const tags = artistData.artist.tags.tag
                        .map(tag => tag.name.toLowerCase())
                        .filter(g => !/^\d+$/.test(g));
                    
                    lastfmArtistTagsCache.set(artist, tags);
                    result.artist_genres = tags;
                }
            }
        }
  
        lastfmCache.set(cacheKey, result);
        return result; 
  
    } catch (error) {
        console.warn(`Last.fm fetch failed for ${artist} - ${track}:`, error.message);
        return null;
    }
  }

  async function getDeezerGenres(isrc, gatewayUrl = null) {
    const MAX_RETRIES = 3; 
    let retryDelay = 1500;

    let rawGatewayUrl = gatewayUrl || DEEZER_GATEWAY_URL;
    let baseUrl = rawGatewayUrl.split('?')[0]; 

    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
            const requestUrl = `${baseUrl}?isrc=${isrc}`;
            
            const response = await fetch(requestUrl);
            
            if (response.status === 429) throw new Error("Gateway Rate Limit");
            if (!response.ok) throw new Error(`Gateway Error: HTTP ${response.status}`);
            
            const result = await response.json();

            if (result.isNotFound) return [];

            if (result.error) {
                const msg = result.error.message || "";
                if (result.error.code === 800) return [];
                if (msg.includes("Quota")) throw new Error("Deezer API Quota");
                throw new Error(`Deezer API Error: ${msg}`);
            }

            const genreData = result.data?.genres?.data;
            if (genreData && Array.isArray(genreData)) {
                return genreData.flatMap(genre => 
                    genre.name.toLowerCase().split('/').map(g => g.trim()).filter(g => g.length > 0)
                );
            }

            return [];

        } catch (error) {
            if (error.message.includes("Gateway") || error.message.includes("Network") || error.message.includes("Quota")) {
                throw error;
            }
            
            if (attempt === MAX_RETRIES) throw error;
            await new Promise(resolve => setTimeout(resolve, retryDelay));
            retryDelay *= 1.5;
        }
    }
  }
  
  function containsYear(str) {
    return /(?:19|20)\d{2}|\d{2}s|\d{2}th/.test(str);
  }

  async function getGenresFromTurso(identifiers, type = 'ids') {
    if (identifiers.length === 0) return new Map();
  
    const results = new Map();
    const BATCH_SIZE = 200; 
    
    const cleanIds = type === 'ids' 
        ? identifiers.map(uri => uri.split(':').pop()) 
        : identifiers;
  
    for (let i = 0; i < cleanIds.length; i += BATCH_SIZE) {
      const batch = cleanIds.slice(i, i + BATCH_SIZE);
      
      const payload = type === 'isrcs' ? { isrcs: batch } : { ids: batch };

      try {
        const response = await fetch(`${TURSO_GATEWAY_URL}/genres/read`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`Gateway error (${response.status}):`, errorText);
            continue;
        }
        
        const data = await response.json();
        
        for (const key in data) {
          results.set(key, data[key]);
        }
      } catch (error) {
        console.error(`Error fetching genres from Turso gateway (${type}):`, error);
      }
    }
    return results;
  }
  
  
  async function saveGenresToTurso(newGenresData) {
    if (newGenresData.length === 0) return;

    const BATCH_SIZE = 70; 
    const MAX_RETRIES = 3;
    const RETRY_DELAY_BASE = 2000;

    for (let i = 0; i < newGenresData.length; i += BATCH_SIZE) {
      const batch = newGenresData.slice(i, i + BATCH_SIZE).map(data => ({
        isrc: data.isrc,
        track_id: data.track_uri.split(':').pop(),
        spotify_artist_genres: JSON.stringify(data.spotify_artist_genres || []),
        lastfm_track_genres: JSON.stringify(data.lastfm_track_genres || []),
        lastfm_artist_genres: JSON.stringify(data.lastfm_artist_genres || []),
        deezer_genres: JSON.stringify(data.deezer_genres || []),
        release_date: data.release_date,
        updated_at: Math.floor(Date.now() / 86400000),
        
        duration_ms: data.duration_ms || null,
        release_date_text: data.release_date_text || null,

        artist_name: JSON.stringify(data.artist_name || []),
        explicit: data.explicit,
        track_name: data.track_name || null,
        popularity: (data.popularity !== undefined && data.popularity !== null) ? data.popularity : null,
        popularity_updated_at: Math.floor(Date.now() / 86400000),

        audio_features: data.audio_features || {} 
      }));

      let success = false;
      for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
          const response = await fetch(`${TURSO_GATEWAY_URL}/genres`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(batch),
          });

          if (!response.ok) {
            const errorText = await response.text();
            if (response.status >= 500 || response.status === 429) {
              throw new Error(`Server responded ${response.status}: ${errorText}`);
            } else {
              console.error(`[Sort-Play] Client error saving genres (no retry): ${response.status}`, errorText);
              success = true;
              break; 
            }
          }
          
          success = true;
          break; 

        } catch (error) {
          if (attempt === MAX_RETRIES) {
            console.error(`[Sort-Play] Error saving batch ${i/BATCH_SIZE + 1} to Turso after ${MAX_RETRIES} attempts:`, error);
          } else {
            const delay = RETRY_DELAY_BASE * attempt;
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }
      
      if (success && (i + BATCH_SIZE < newGenresData.length)) {
          await new Promise(resolve => setTimeout(resolve, 300));
      }
    }
  }

  async function fetchAllTrackGenres(tracks, updateProgressCallback = null, onGenresReadyCallback = null) {
    const updateProgress = (msg) => {
        if (updateProgressCallback) updateProgressCallback(msg);
        else mainButton.innerText = msg;
    };

    if (sessionGenreCache.size > 30000) {
        sessionGenreCache.clear();
    }

    updateProgress("0%");

    const flattenAudioFeatures = (data) => {
        if (data && data.audio_features) {
            Object.assign(data, data.audio_features);
        }
        return data;
    };

    const safeVal = (val) => (val !== null && val !== undefined) ? val : -1;

    const justFetchedTrackIds = new Set();

    async function fetchSingleTrackGenresFromApis(trackUri, preFetchedTrackDetails = null, deezerGatewayUrl = null) {
        const trackId = trackUri.split(":")[2];
        let isCompleteSuccess = true; 

        try {
            let trackDetails = preFetchedTrackDetails;
            
            if (!trackDetails) {
                if (isFallbackActive()) {
                    trackDetails = await fetchInternalTrackMetadata(trackId);
                } else {
                    try {
                        trackDetails = await withRetry(
                            () => Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks/${trackId}`),
                            CONFIG.spotify.retryAttempts,
                            CONFIG.spotify.retryDelay
                        );
                    } catch (error) {
                        if (registerWebApiFailure()) {
                            trackDetails = await fetchInternalTrackMetadata(trackId);
                        } else {
                            throw error;
                        }
                    }
                }
            }
            
            if (!trackDetails || trackDetails.error) throw new Error("Failed to fetch track details");
            
            if (!trackDetails?.artists?.length) {
                return { 
                    success: true, 
                    isrc: null, 
                    canSave: false, 
                    data: { 
                        spotify_artist_genres: [], 
                        lastfm_track_genres: [], 
                        lastfm_artist_genres: [], 
                        deezer_genres: [], 
                        release_date: null,
                        duration_ms: -1,
                        release_date_text: "N/A",
                        audio_features: null 
                    } 
                };
            }
            
            const isrc = trackDetails.external_ids?.isrc || null;

            const artistIds = [...new Set(trackDetails.artists.map(artist => artist.uri.split(":")[2]))];
            const spotifyGenres = new Set();
            const artistIdsToFetch = [];
    
            artistIds.forEach(id => {
                if (artistGenreCache.has(id)) {
                    artistGenreCache.get(id).forEach(genre => spotifyGenres.add(genre));
                } else {
                    artistIdsToFetch.push(id);
                }
            });
    
            if (artistIdsToFetch.length > 0) {
                const artistBatches = [];
                for (let i = 0; i < artistIdsToFetch.length; i += 50) {
                    artistBatches.push(artistIdsToFetch.slice(i, i + 50));
                }
    
                await Promise.all(artistBatches.map(async (batch) => {
                    try {
                        let artistData;
                        const fetchWithClientToken = async () => {
                            const token = await get_S_Client_Token();
                            if (!token) throw new Error("No client token available");
                            const res = await fetch(`https://api.spotify.com/v1/artists?ids=${batch.join(',')}&locale=en`, {
                                headers: { "Authorization": `Bearer ${token}` }
                            });
                            if (!res.ok) throw new Error(`HTTP ${res.status}`);
                            return await res.json();
                        };

                        if (isFallbackActive()) {
                            artistData = await fetchWithClientToken();
                        } else {
                            try {
                                artistData = await withRetry(
                                    () => Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists?ids=${batch.join(',')}&locale=en`),
                                    CONFIG.spotify.retryAttempts,
                                    CONFIG.spotify.retryDelay
                                );
                            } catch (error) {
                                if (registerWebApiFailure()) {
                                    artistData = await fetchWithClientToken();
                                } else {
                                    throw error;
                                }
                            }
                        }
                        
                        if (artistData?.artists) {
                            artistData.artists.forEach(artist => {
                                if (!artist) return;
                                const genres = (artist.genres || []).map(g => g.toLowerCase()).filter(genre => !containsYear(genre) && !/^\d+$/.test(genre));
                                artistGenreCache.set(artist.id, genres);
                                genres.forEach(genre => spotifyGenres.add(genre));
                            });
                        }
                    } catch (error) {
                        console.warn(`Error fetching Spotify genres:`, error);
                        isCompleteSuccess = false;
                    }
                }));
            }
    
            const lastfmGenresData = await getLastfmGenres(trackDetails.artists[0].name, trackDetails.name);
            let lfmTrackGenres = [];
            let lfmArtistGenres = [];
            
            if (lastfmGenresData === null) {
                isCompleteSuccess = false; 
            } else {
                const artistNames = trackDetails.artists.map(artist => artist.name.toLowerCase());
                const filterGenres = (genres) => genres.filter(genre => !containsYear(genre) && !artistNames.some(artistName => genre.includes(artistName)));
                lfmTrackGenres = filterGenres(lastfmGenresData.track_genres);
                lfmArtistGenres = filterGenres(lastfmGenresData.artist_genres);
            }
    
            let deezer_genres = [];
            if (isrc && deezerGatewayUrl) {
                try {
                    deezer_genres = await getDeezerGenres(isrc, deezerGatewayUrl);
                } catch (e) {
                    throw e;
                }
            } else if (isrc && !deezerGatewayUrl) {
                isCompleteSuccess = false;
            }
    
            const releaseDateStr = trackDetails.album?.release_date;
            let releaseDateInDays = null;

            if (releaseDateStr) {
                const dateObj = new Date(releaseDateStr);
                if (!isNaN(dateObj.getTime())) {
                    releaseDateInDays = Math.floor(dateObj.getTime() / 86400000);
                }
            }
    
            const artistNamesList = trackDetails.artists.map(a => a.name);

            return { 
                success: true,
                isrc: isrc,
                canSave: isCompleteSuccess, 
                data: {
                    isrc: isrc,
                    spotify_artist_genres: Array.from(spotifyGenres), 
                    lastfm_track_genres: lfmTrackGenres,
                    lastfm_artist_genres: lfmArtistGenres,
                    deezer_genres: deezer_genres,
                    release_date: releaseDateInDays,
                    duration_ms: safeVal(trackDetails.duration_ms),
                    release_date_text: releaseDateStr || "N/A",
                    audio_features: null,
                    artist_name: artistNamesList,
                    explicit: trackDetails.explicit,
                    track_name: trackDetails.name,
                    popularity: trackDetails.popularity
                }
            };
    
        } catch (error) {
            throw error; 
        }
    }
  
    const trackUris = tracks.map(t => t.uri);
    updateProgress("Checking...");
    
    const finalGenresMap = new Map();
    const urisNotInSession = [];

    trackUris.forEach(uri => {
        if (sessionGenreCache.has(uri)) {
            finalGenresMap.set(uri, sessionGenreCache.get(uri));
        } else {
            urisNotInSession.push(uri);
        }
    });

    let cachedGenresByUri = new Map();
    if (urisNotInSession.length > 0) {
        cachedGenresByUri = await getGenresFromTurso(urisNotInSession, 'ids');
    }
    
    const missingUris = [];
    
    const todayInDays = Math.floor(Date.now() / 86400000);

    const isDataStale = (cached) => {
        if (!cached) return true;

        const daysSinceLastUpdate = cached.updated_at ? (todayInDays - cached.updated_at) : 9999;

        const allGenresEmpty = (!cached.spotify_artist_genres?.length) &&
                               (!cached.lastfm_track_genres?.length && !cached.lastfm_artist_genres?.length) &&
                               (!cached.deezer_genres?.length) &&
                               (!cached.apple_music_genres?.length);

        if (allGenresEmpty && daysSinceLastUpdate > 180) return true;

        if (!cached.release_date) return false;

        const daysSinceRelease = todayInDays - cached.release_date;
        
        let refetchCooldown = 5;
        if (daysSinceRelease <= 5) {
            refetchCooldown = 2;
        }

        if (daysSinceLastUpdate < refetchCooldown) return false;
        
        if (allGenresEmpty && daysSinceRelease < 70) return true;

        let sourceCount = 0;
        if (cached.spotify_artist_genres?.length > 0) sourceCount++;
        if ((cached.lastfm_track_genres?.length > 0) || (cached.lastfm_artist_genres?.length > 0)) sourceCount++;
        if (cached.deezer_genres?.length > 0) sourceCount++;
        if (cached.apple_music_genres?.length > 0) sourceCount++;

        if (sourceCount === 1 && daysSinceRelease < 40) return true;

        if (daysSinceRelease < 30) return true;

        return false;
    };

    urisNotInSession.forEach(uri => {
        let cached = cachedGenresByUri.get(uri);
        if (cached) cached = flattenAudioFeatures(cached);

        if (!cached || isDataStale(cached)) {
            missingUris.push(uri);
        } else {
            finalGenresMap.set(uri, cached);
            sessionGenreCache.set(uri, cached);
        }
    });

    const tracksToFetch = tracks.filter(t => missingUris.includes(t.uri));
    const tracksWithIsrcs = []; 
    
    if (tracksToFetch.length > 0) {
        updateProgress("Details...");
        const CHUNK_SIZE = 50;
        let processedCount = 0;
  
        for (let i = 0; i < tracksToFetch.length; i += CHUNK_SIZE) {
          const chunk = tracksToFetch.slice(i, i + CHUNK_SIZE);
          const chunkTrackIds = chunk.map(t => t.uri.split(':')[2]);
  
          try {
              let responseTracks = [];
  
              const fetchBatchInternal = async () => {
                  const promises = chunkTrackIds.map(id => fetchInternalTrackMetadata(id));
                  return await Promise.all(promises);
              };
  
              if (isFallbackActive()) {
                  responseTracks = await fetchBatchInternal();
              } else {
                  try {
                      const response = await withRetry(
                          () => Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${chunkTrackIds.join(',')}`),
                          CONFIG.spotify.retryAttempts,
                          CONFIG.spotify.retryDelay
                      );
                      responseTracks = response?.tracks || [];
                  } catch (error) {
                      if (registerWebApiFailure()) {
                          responseTracks = await fetchBatchInternal();
                      } else {
                          throw error;
                      }
                  }
              }
  
              responseTracks.forEach((td, idx) => {
                  if (td) {
                      tracksWithIsrcs.push({
                          uri: chunk[idx].uri,
                          isrc: td.external_ids?.isrc,
                          details: td
                      });
                  }
              });
          } catch (error) {
              console.error(`[Sort-Play] Failed to fetch track details for ISRC lookup:`, error);
          }
          processedCount += chunk.length;
          updateProgress(`Details ${Math.round((processedCount / tracksToFetch.length) * 100)}%`);
        }
      }

    const isrcsToCheck = [...new Set(tracksWithIsrcs.map(t => t.isrc).filter(Boolean))];
    let cachedGenresByIsrc = new Map();
    
    const isrcsNotInSession = [];
    isrcsToCheck.forEach(isrc => {
        if (sessionGenreCache.has(isrc)) {
            cachedGenresByIsrc.set(isrc, sessionGenreCache.get(isrc));
        } else {
            isrcsNotInSession.push(isrc);
        }
    });

    if (isrcsNotInSession.length > 0) {
        updateProgress("Linking...");
        const tursoResults = await getGenresFromTurso(isrcsNotInSession, 'isrcs');
        tursoResults.forEach((val, key) => {
            const flattenedVal = flattenAudioFeatures(val);
            cachedGenresByIsrc.set(key, flattenedVal);
            sessionGenreCache.set(key, flattenedVal);
        });
    }

    const tracksNeedingExternalFetch = [];
    const itemsToSaveMap = new Map();

    tracksWithIsrcs.forEach(item => {
        const { uri, isrc } = item;
        if (isrc && cachedGenresByIsrc.has(isrc)) {
            const cached = cachedGenresByIsrc.get(isrc);
            if (!isDataStale(cached)) {
                finalGenresMap.set(uri, cached);
                sessionGenreCache.set(uri, cached);
                return;
            }
        }
        tracksNeedingExternalFetch.push(item);
    });

    if (tracksNeedingExternalFetch.length > 0) {
        const uniqueArtistIds = new Set();
        tracksNeedingExternalFetch.forEach(item => {
            if (item.details && item.details.artists) {
                item.details.artists.forEach(artist => {
                    if (artist.uri) {
                        const artistId = artist.uri.split(':')[2];
                        if (artistId && !artistGenreCache.has(artistId)) {
                            uniqueArtistIds.add(artistId);
                        }
                    }
                });
            }
        });

        const artistIdsToFetch = Array.from(uniqueArtistIds);
        if (artistIdsToFetch.length > 0) {
            updateProgress("Artists...");
            for (let i = 0; i < artistIdsToFetch.length; i += 50) {
                const batch = artistIdsToFetch.slice(i, i + 50);
                try {
                    let artistData;
                    const fetchWithClientToken = async () => {
                        const token = await get_S_Client_Token();
                        if (!token) throw new Error("No client token available");
                        const res = await fetch(`https://api.spotify.com/v1/artists?ids=${batch.join(',')}&locale=en`, {
                            headers: { "Authorization": `Bearer ${token}` }
                        });
                        if (!res.ok) throw new Error(`HTTP ${res.status}`);
                        return await res.json();
                    };

                    if (isFallbackActive()) {
                        artistData = await fetchWithClientToken();
                    } else {
                        try {
                            artistData = await withRetry(
                                () => Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists?ids=${batch.join(',')}&locale=en`),
                                CONFIG.spotify.retryAttempts,
                                CONFIG.spotify.retryDelay
                            );
                        } catch (error) {
                            if (registerWebApiFailure()) {
                                artistData = await fetchWithClientToken();
                            } else {
                                throw error;
                            }
                        }
                    }

                    if (artistData?.artists) {
                        artistData.artists.forEach(artist => {
                            if (!artist) return;
                            const genres = (artist.genres || []).map(g => g.toLowerCase()).filter(genre => !containsYear(genre) && !/^\d+$/.test(genre));
                            artistGenreCache.set(artist.id, genres);
                        });
                    }
                } catch (error) {
                    console.warn(`[Sort-Play] Error pre-fetching artist genres:`, error);
                }
            }
        }

        const totalToFetch = tracksNeedingExternalFetch.length;
        let fetchedCount = 0;
        const sharedQueue = [...tracksNeedingExternalFetch];
        
        const gateways = [
            { url: DEEZER_GATEWAY_URL, active: true, failures: 0, rateLimitedUntil: 0 },
            { url: DEEZER_GATEWAY_URL_2, active: true, failures: 0, rateLimitedUntil: 0 },
            { url: DEEZER_GATEWAY_URL_3, active: true, failures: 0, rateLimitedUntil: 0 }
        ];
        
        for (let i = gateways.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [gateways[i], gateways[j]] = [gateways[j], gateways[i]];
        }

        const MAX_GATEWAY_FAILURES = 10; 
        const WORKERS_PER_GATEWAY = 3;

        const startGatewayWorkers = (gateway) => {
            const workers = [];
            for (let i = 0; i < WORKERS_PER_GATEWAY; i++) {
                workers.push(async () => {
                    while (sharedQueue.length > 0 && gateway.active) {
                        
                        if (gateway.rateLimitedUntil > Date.now()) {
                            const waitTime = gateway.rateLimitedUntil - Date.now();
                            if (waitTime > 0) {
                                await new Promise(resolve => setTimeout(resolve, waitTime + Math.random() * 500));
                            }
                        }

                        if (sharedQueue.length === 0 || !gateway.active) break;

                        const item = sharedQueue.shift(); 
                        if (!item) break; 

                        try {
                            const result = await fetchSingleTrackGenresFromApis(item.uri, item.details, gateway.url);
                            
                            const existing = cachedGenresByIsrc.get(item.isrc);
                            if (existing && (existing.tempo || existing.tempo === 0 || existing.tempo === -1)) {
                                result.data.audio_features = {
                                    danceability: existing.danceability,
                                    energy: existing.energy,
                                    valence: existing.valence,
                                    acousticness: existing.acousticness,
                                    instrumentalness: existing.instrumentalness,
                                    speechiness: existing.speechiness,
                                    liveness: existing.liveness,
                                    tempo: existing.tempo,
                                    key: existing.key,
                                    mode: existing.mode,
                                    time_signature: existing.time_signature,
                                    loudness: existing.loudness,
                                    duration_ms: result.data.duration_ms || existing.duration_ms
                                };
                                Object.assign(result.data, result.data.audio_features);
                            }

                            if (!result.data.isrc) result.data.isrc = item.isrc;

                            finalGenresMap.set(item.uri, result.data);
                            
                            itemsToSaveMap.set(item.uri, {
                                track_uri: item.uri,
                                isrc: item.isrc,
                                ...result.data
                            });
                            
                            fetchedCount++;
                            updateProgress(`Ext ${Math.round((fetchedCount / totalToFetch) * 100)}%`);
                            await new Promise(resolve => setTimeout(resolve, 250));

                        } catch (error) {
                            const errorMsg = error.message || "";
                            const isRateLimit = errorMsg.includes("Rate Limit") || errorMsg.includes("Quota") || errorMsg.includes("429") || errorMsg.includes("HTTP 5"); 
                            
                            if (isRateLimit) {
                                sharedQueue.push(item); 
                                const backoffTime = 5000 + (Math.random() * 3000);
                                const newRateLimit = Date.now() + backoffTime;
                                if (newRateLimit > gateway.rateLimitedUntil) {
                                    gateway.rateLimitedUntil = newRateLimit;
                                }
                            }
                            else if (errorMsg.includes("Gateway") || errorMsg.includes("Network")) {
                                gateway.failures++;
                                sharedQueue.push(item); 
                                if (gateway.failures >= MAX_GATEWAY_FAILURES) {
                                    gateway.active = false;
                                    break; 
                                }
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            } else {
                                fetchedCount++;
                            }
                        }
                    }
                });
            }
            return Promise.all(workers.map(w => w()));
        };

        const allPools = gateways.map(gw => startGatewayWorkers(gw));
        await Promise.all(allPools);

        if (sharedQueue.length > 0) {
            for (const item of sharedQueue) {
                try {
                    const result = await fetchSingleTrackGenresFromApis(item.uri, item.details, null);
                    if (!result.data.isrc) result.data.isrc = item.isrc;
                    finalGenresMap.set(item.uri, result.data);
                    itemsToSaveMap.set(item.uri, { track_uri: item.uri, isrc: item.isrc, ...result.data });
                } catch (e) {} finally {
                    fetchedCount++;
                    updateProgress(`Ext ${Math.round((fetchedCount / totalToFetch) * 100)}%`);
                }
            }
        }
    }

    finalGenresMap.forEach((data, uri) => {
        if ((data.release_date || data.release_date === 0) && !data.release_date_text && data.release_date_text !== "N/A") {
            const d = new Date(data.release_date * 86400000);
            if (!isNaN(d.getTime())) {
                const year = d.getUTCFullYear();
                const month = String(d.getUTCMonth() + 1).padStart(2, '0');
                const day = String(d.getUTCDate()).padStart(2, '0');
                data.release_date_text = `${year}-${month}-${day}`;
                
                if (data.isrc) {
                    const existing = itemsToSaveMap.get(uri);
                    itemsToSaveMap.set(uri, {
                        ...(existing || {}),
                        track_uri: uri,
                        isrc: data.isrc,
                        ...data
                    });
                }
            }
        }
    });

    if (onGenresReadyCallback) {
        updateProgress("Mapping...");
        const trackGenreMap = new Map();
        tracks.forEach(track => {
            let genres = finalGenresMap.get(track.uri);
            if (genres) {
                let combined = [
                    ...(genres.spotify_artist_genres || []).map(g => ({ name: g, source: 'spotify' })),
                    ...(genres.lastfm_track_genres || []).map(g => ({ name: g, source: 'lastfm_track' })),
                    ...(genres.lastfm_artist_genres || []).map(g => ({ name: g, source: 'lastfm_artist' })),
                    ...(genres.deezer_genres || []).map(g => ({ name: g, source: 'deezer' })),
                    ...(genres.apple_music_genres || []).map(g => ({ name: g, source: 'apple_music' }))
                ];
                const mappedAndNormalized = mapAndNormalizeGenres(combined);
                const finalUniqueGenres = Array.from(new Set(mappedAndNormalized.map(g => JSON.stringify(g)))).map(s => JSON.parse(s));
                trackGenreMap.set(track.uri, finalUniqueGenres);
            } else {
                trackGenreMap.set(track.uri, []);
            }
        });
        onGenresReadyCallback({ trackGenreMap, rawTrackGenres: finalGenresMap });
    }

    const trackIdsForMetadata = new Set();
    finalGenresMap.forEach((data, uri) => {
        const id = uri.split(':')[2];
        const needsText = !data.release_date_text && data.release_date_text !== "N/A";
        const needsDuration = !data.duration_ms && data.duration_ms !== 0 && data.duration_ms !== -1;
        
        const needsNewData = !data.artist_name || !data.track_name || data.popularity === undefined || data.popularity === null || data.explicit === undefined || data.explicit === null;

        if ((needsText || needsDuration || needsNewData) && !trackIdsForMetadata.has(id) && !justFetchedTrackIds.has(id)) {
            trackIdsForMetadata.add(id);
        }
    });

    if (trackIdsForMetadata.size > 0) {
        updateProgress("Meta...");
        const ids = Array.from(trackIdsForMetadata);
        const BATCH_SIZE = 50;

        for (let i = 0; i < ids.length; i += BATCH_SIZE) {
            const batch = ids.slice(i, i + BATCH_SIZE);
            try {
                let response = { tracks: [] };

                const fetchBatchInternal = async () => {
                    const promises = batch.map(id => fetchInternalTrackMetadata(id));
                    const results = await Promise.all(promises);
                    return { tracks: results };
                };

                if (isFallbackActive()) {
                    response = await fetchBatchInternal();
                } else {
                    try {
                        response = await withRetry(
                            () => Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${batch.join(',')}`),
                            CONFIG.spotify.retryAttempts,
                            CONFIG.spotify.retryDelay
                        );
                    } catch (error) {
                        if (registerWebApiFailure()) {
                            response = await fetchBatchInternal();
                        } else {
                            throw error;
                        }
                    }
                }

                if (response && response.tracks) {
                    response.tracks.forEach(track => {
                        if (track) {
                            const uri = track.uri || `spotify:track:${track.id}`;
                            const releaseDateText = track.album?.release_date || "N/A";
                            const durationMs = safeVal(track.duration_ms);
                            
                            const artistNames = track.artists ? track.artists.map(a => a.name) : [];
                            const isExplicit = (track.explicit !== undefined && track.explicit !== null) ? track.explicit : null;
                            const trackName = track.name;
                            const popularity = track.popularity;
                            const isrc = track.external_ids?.isrc;

                            const genreData = finalGenresMap.get(uri);
                            if (genreData) {
                                genreData.release_date_text = releaseDateText;
                                genreData.duration_ms = durationMs;
                                
                                genreData.artist_name = artistNames;
                                genreData.explicit = isExplicit;
                                genreData.track_name = trackName;
                                genreData.popularity = popularity;
                                
                                if (isrc && !genreData.isrc) {
                                    genreData.isrc = isrc;
                                }

                                if (genreData.isrc) {
                                    const existing = itemsToSaveMap.get(uri);
                                    itemsToSaveMap.set(uri, {
                                        ...(existing || {}),
                                        track_uri: uri,
                                        isrc: genreData.isrc,
                                        ...genreData
                                    });
                                }
                            }
                        }
                    });
                }
            } catch (e) {
                console.error("[Sort-Play] Error fetching batch metadata", e);
            }
            updateProgress(`Meta ${Math.round(((i + BATCH_SIZE) / ids.length) * 100)}%`);
        }
    }

    const trackIdsForFeatures = new Set();
    finalGenresMap.forEach((data, uri) => {
        if (!data.tempo && data.tempo !== 0 && data.tempo !== -1 && !trackIdsForFeatures.has(uri.split(':')[2])) {
            trackIdsForFeatures.add(uri.split(':')[2]);
        }
    });

    if (trackIdsForFeatures.size > 0 && !isFallbackActive()) {
        updateProgress("Audio...");
        const ids = Array.from(trackIdsForFeatures);
        const BATCH_SIZE = 100;

        for (let i = 0; i < ids.length; i += BATCH_SIZE) {
            const batch = ids.slice(i, i + BATCH_SIZE);
            try {
                const response = await withRetry(
                    () => Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/audio-features?ids=${batch.join(',')}`),
                    CONFIG.spotify.retryAttempts,
                    CONFIG.spotify.retryDelay
                );

                if (response && response.audio_features) {
                    response.audio_features.forEach((af, index) => {
                        const uri = `spotify:track:${batch[index]}`;
                        const genreData = finalGenresMap.get(uri);

                        if (af) {
                            const features = {
                                danceability: safeVal(af.danceability),
                                energy: safeVal(af.energy),
                                valence: safeVal(af.valence),
                                acousticness: safeVal(af.acousticness),
                                instrumentalness: safeVal(af.instrumentalness),
                                speechiness: safeVal(af.speechiness),
                                liveness: safeVal(af.liveness),
                                tempo: safeVal(af.tempo),
                                key: safeVal(af.key),
                                mode: safeVal(af.mode),
                                time_signature: safeVal(af.time_signature),
                                loudness: safeVal(af.loudness),
                                duration_ms: safeVal(af.duration_ms)
                            };

                            if (genreData) {
                                Object.assign(genreData, features);

                                if (genreData.isrc) {
                                    const existing = itemsToSaveMap.get(uri);
                                    const updatedEntry = {
                                        ...(existing || {}),
                                        track_uri: uri,
                                        isrc: genreData.isrc,
                                        ...genreData,
                                        audio_features: features
                                    };
                                    itemsToSaveMap.set(uri, updatedEntry);
                                }
                            }
                        } else {
                            if (genreData) {
                                const emptyFeatures = {
                                    danceability: -1, energy: -1, valence: -1, acousticness: -1,
                                    instrumentalness: -1, speechiness: -1, liveness: -1, tempo: -1,
                                    key: -1, mode: -1, time_signature: -1, loudness: -1
                                };
                                Object.assign(genreData, emptyFeatures);
                                
                                if (genreData.isrc) {
                                    const existing = itemsToSaveMap.get(uri);
                                    const updatedEntry = {
                                        ...(existing || {}),
                                        track_uri: uri,
                                        isrc: genreData.isrc,
                                        ...genreData,
                                        audio_features: emptyFeatures
                                    };
                                    itemsToSaveMap.set(uri, updatedEntry);
                                }
                            }
                        }
                    });
                }
            } catch (e) {
                console.error("[Sort-Play] Error fetching batch audio features", e);
            }
            updateProgress(`Audio ${Math.round(((i + BATCH_SIZE) / ids.length) * 100)}%`);
        }
    }

    finalGenresMap.forEach((data, uri) => {
        sessionGenreCache.set(uri, data);
        if (data.isrc) sessionGenreCache.set(data.isrc, data);
    });

    const dataToSave = Array.from(itemsToSaveMap.values());

    if (dataToSave.length > 0) {
        saveGenresToTurso(dataToSave).then(() => {
            console.log(`[Sort-Play] Background cloud genre/audio caching complete for ${dataToSave.length} items.`);
        }).catch(err => {
            console.error("[Sort-Play] Background cloud genre caching failed:", err);
            showNotification("[Sort-Play] Background cloud genre caching failed.", 'warning');
        });
    }

    updateProgress("Mapping...");
    const trackGenreMap = new Map();

    tracks.forEach(track => {
        let genres = finalGenresMap.get(track.uri);
        if (genres) {
            let combined = [
                ...(genres.spotify_artist_genres || []).map(g => ({ name: g, source: 'spotify' })),
                ...(genres.lastfm_track_genres || []).map(g => ({ name: g, source: 'lastfm_track' })),
                ...(genres.lastfm_artist_genres || []).map(g => ({ name: g, source: 'lastfm_artist' })),
                ...(genres.deezer_genres || []).map(g => ({ name: g, source: 'deezer' })),
                ...(genres.apple_music_genres || []).map(g => ({ name: g, source: 'apple_music' }))
            ];
            const mappedAndNormalized = mapAndNormalizeGenres(combined);
            const finalUniqueGenres = Array.from(new Set(mappedAndNormalized.map(g => JSON.stringify(g)))).map(s => JSON.parse(s));

            trackGenreMap.set(track.uri, finalUniqueGenres);
        } else {
            trackGenreMap.set(track.uri, []);
        }
    });

    return { trackGenreMap, rawTrackGenres: finalGenresMap };
  }
  
  function getNormalizedGenreKey(genre) {
    return genre
      .toLowerCase()
      .replace(/&/g, 'and')
      .replace(/[\s-]+/g, '');
  }

  Object.entries(GENRE_MAPPINGS).forEach(([mainGenre, variants]) => {
    const canonicalMainGenre = mainGenre;
    variants.forEach(variant => {
      const normalizedKey = getNormalizedGenreKey(variant);
      if (!VARIANT_TO_MAIN_GENRE_MAP[normalizedKey]) {
        VARIANT_TO_MAIN_GENRE_MAP[normalizedKey] = [];
      }
      if (!VARIANT_TO_MAIN_GENRE_MAP[normalizedKey].includes(canonicalMainGenre)) {
          VARIANT_TO_MAIN_GENRE_MAP[normalizedKey].push(canonicalMainGenre);
      }
    });
    const normalizedMainKey = getNormalizedGenreKey(mainGenre);
    if (!VARIANT_TO_MAIN_GENRE_MAP[normalizedMainKey]) {
        VARIANT_TO_MAIN_GENRE_MAP[normalizedMainKey] = [canonicalMainGenre];
    }
  });
  
  Object.entries(COUNTRY_MAPPINGS).forEach(([mainCountry, variants]) => {
    variants.forEach(variant => {
      const normalizedKey = getNormalizedGenreKey(variant);
      if (!VARIANT_TO_MAIN_COUNTRY_MAP[normalizedKey]) {
        VARIANT_TO_MAIN_COUNTRY_MAP[normalizedKey] = mainCountry;
      }
    });
    const normalizedMainKey = getNormalizedGenreKey(mainCountry);
    if (!VARIANT_TO_MAIN_COUNTRY_MAP[normalizedMainKey]) {
        VARIANT_TO_MAIN_COUNTRY_MAP[normalizedMainKey] = mainCountry;
    }
  });
  
  function mapAndNormalizeGenres(rawGenres) {
    const mappedGenres = new Set();
    if (!rawGenres) return [];

    const GENRE_CLEANUP_KEYWORDS = [
        "spotify", "deezer", "last.fm", "lastfm", 
        "my top", "favorite", "fave", "playlist", 
        "library", "seen live", "radio", "stream"
    ];

    rawGenres.forEach(genreObj => {
        const rawGenreName = typeof genreObj === 'string' ? genreObj : genreObj.name;
        const source = typeof genreObj === 'string' ? 'unknown' : genreObj.source;
        const lowerName = rawGenreName.toLowerCase().trim();

        if (GENRE_CLEANUP_KEYWORDS.some(keyword => lowerName.includes(keyword))) {
            return;
        }

        const normalizedKey = getNormalizedGenreKey(rawGenreName);
        
        if (VARIANT_TO_MAIN_COUNTRY_MAP[normalizedKey]) {
            const mainCountry = VARIANT_TO_MAIN_COUNTRY_MAP[normalizedKey];
            const formattedCountry = mainCountry.charAt(0).toUpperCase() + mainCountry.slice(1);
            mappedGenres.add(JSON.stringify({ name: formattedCountry, source: source }));
        }
        else if (VARIANT_TO_MAIN_GENRE_MAP[normalizedKey]) {
            VARIANT_TO_MAIN_GENRE_MAP[normalizedKey].forEach(mainGenre => {
                mappedGenres.add(JSON.stringify({ name: mainGenre, source: source }));
            });
        } 
        else {
            mappedGenres.add(JSON.stringify({ name: lowerName, source: source }));
        }
    });

    return Array.from(mappedGenres).map(item => JSON.parse(item));
  }

  function filterTracksByGenres(tracks, selectedGenres, excludedGenres, trackGenreMap, matchAll = null) {
    const effectiveMatchAll = matchAll !== null ? matchAll : matchAllGenres;

    if (selectedGenres.length === 0 && excludedGenres.length === 0) {
        return tracks;
    }
    let includedTracks;

    if (selectedGenres.length === 0) {
        includedTracks = tracks;
    } else if (effectiveMatchAll) {
        includedTracks = tracks.filter((track) => {
            const trackGenres = trackGenreMap.get(track.uri);
            if (!trackGenres) return false;
            const trackGenreNames = new Set(trackGenres.map(g => g.name));
            return selectedGenres.every((selectedGenre) => trackGenreNames.has(selectedGenre));
        });
    } else {
        includedTracks = tracks.filter((track) => {
            const trackGenres = trackGenreMap.get(track.uri);
            if (!trackGenres) return false;
            const trackGenreNames = new Set(trackGenres.map(g => g.name));
            return selectedGenres.some((selectedGenre) => trackGenreNames.has(selectedGenre));
        });
    }

    if (excludedGenres.length === 0) {
        return includedTracks;
    }

    return includedTracks.filter(track => {
        const trackGenres = trackGenreMap.get(track.uri);
        if (!trackGenres) return true;
        const trackGenreNames = new Set(trackGenres.map(g => g.name));
        return !excludedGenres.some(excludedGenre => trackGenreNames.has(excludedGenre));
    });
  }

  const styleElement = document.createElement("style");
  styleElement.innerHTML = `
    .sort-play-font-scope,
    .sort-play-font-scope * {
      font-family: 'SpotifyMixUI', sans-serif !important;
    }
    .sort-play-failed-cell {
      position: relative;
      cursor: help;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-decoration-color: var(--spice-subtext);
      text-underline-offset: 2px;
    }
    .sort-play-tooltip {
      visibility: hidden;
      width: max-content;
      max-width: 250px;
      background-color: #282828;
      color: #fff;
      text-align: center;
      border-radius: 4px;
      padding: 6px 10px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.2s;
      font-size: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      pointer-events: none;
      text-decoration: none;
    }
    .sort-play-failed-cell:hover .sort-play-tooltip {
      visibility: visible;
      opacity: 1;
    }
    .main-trackList-trackListRow .sort-play-like-button[aria-checked="true"],
    div[role="row"][aria-selected] .sort-play-like-button[aria-checked="true"] {
        opacity: 1 !important;
    }
    .loader {
      position: relative;
      width: 8px;
      height: 8px;
      border-radius: 5px;
      background-color: #b3b3b3;
      color: #b3b3b3;
      animation: 0.4s linear 0.2s infinite alternate none running loader;
    }
    
    .loader::before,
    .loader::after {
      content: "";
      display: inline-block;
      position: absolute;
      top: 0px;
    }
    
    .loader::before {
      left: -15px;
      width: 8px;
      height: 8px;
      border-radius: 5px;
      background-color: #b3b3b3;
      color: #b3b3b3;
      animation: 0.4s ease 0s infinite alternate none running loader;
    }
    
    .loader::after {
      left: 15px;
      width: 8px;
      height: 8px;
      border-radius: 5px;
      background-color: #b3b3b3;
      color: #b3b3b3;
      animation: 0.4s ease 0.4s infinite alternate none running loader;
    }
    
    @keyframes loader {
      0% {
        background-color: #8d8d8d;
      }
      50%,
      100% {
        background-color: #cccccc;
      }
    }
    .Button-sc-qlcn5g-0.Button-small-buttonTertiary-useBrowserDefaultFocusStyle {
      cursor: default;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 5px;
    }
    .sort-play-column {
      display: flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      text-overflow: ellipsis;
      width: 90px;
      color: var(--spice-text);
    }
    .main-trackList-row .sort-play-playcount {
        color: var(--spice-text);
        font-size: 13px;
        margin-left: 10px;
    }
    .main-trackList-row .sort-play-loading {
        color: var(--spice-subtext);
        font-size: 13px;
        margin-left: 10px;
    }
    .main-trackList-row .sort-play-playcount,
    .main-trackList-row .sort-play-loading {
        display: block;
        text-align: center;
        margin: auto;
    }
      div.main-trackList-trackList[aria-label="popular tracks"] .main-trackList-trackListHeaderRow .main-trackList-rowSectionVariable:nth-child(3) {
        justify-content: center;
    }
    div.main-trackList-trackList[aria-label="popular tracks"] .main-trackList-trackListRow .main-trackList-rowSectionVariable:nth-child(3) {
        justify-content: center;
    }
    #sort-play-now-playing-data {
        cursor: pointer;
    }
    #sort-play-now-playing-data:hover .sort-play-np-value {
        text-decoration: underline;
    }
    .sort-play-column-header {
        cursor: pointer !important;
    }
    .sort-play-column-header:hover span {
        color: #fff !important;
    }
  `;
  document.head.appendChild(styleElement);

  const excludedPlaylistNames = ["New Music Friday", "Discover Weekly", "Release Radar"];

  function getCurrentPlaylistName() {
    const playlistNameElement = document.querySelector(
      ".encore-text.encore-text-headline-large"
    );
    return playlistNameElement ? playlistNameElement.textContent.trim() : null;
  }

  function isLikedSongsPage(uri) {
    if (!uri || typeof uri !== 'string') return false;
    try {
      const uriObj = Spicetify.URI.fromString(uri);
      return uriObj && uriObj.type === Spicetify.URI.Type.COLLECTION && uriObj.category === "tracks";
    } catch (e) {
      return false;
    }
  }

  function isLocalFilesPage(uri) {
    if (!uri || typeof uri !== 'string') return false;
    return uri === "spotify:collection:local-files";
  }

  function getCurrentUri() {
    const path = Spicetify.Platform.History.location?.pathname;
    if (!path) return null;

    const segments = path.split('/').filter(segment => segment.length > 0);
    
    const albumIndex = segments.indexOf('album');
    if (albumIndex > -1 && segments[albumIndex + 1]) {
        return `spotify:album:${segments[albumIndex + 1]}`;
    }
    
    const artistIndex = segments.indexOf('artist');
    if (artistIndex > -1 && segments[artistIndex + 1]) {
        return `spotify:artist:${segments[artistIndex + 1]}`;
    }
    
    const playlistIndex = segments.indexOf('playlist');
    if (playlistIndex > -1 && segments[playlistIndex + 1]) {
        return `spotify:playlist:${segments[playlistIndex + 1]}`;
    }
    
    if (segments.includes('collection') && segments.includes('tracks')) {
        return "spotify:collection:tracks";
    }
    
    if (segments.includes('collection') && segments.includes('local-files')) {
        return "spotify:collection:local-files";
    }
    
    return null;
  }
  
  async function getLikedSongs() {
    try {
      const likedTracksData = await Spicetify.Platform.LibraryAPI.getTracks({
        limit: Number.MAX_SAFE_INTEGER,
      });

      if (!likedTracksData || !likedTracksData.items) {
        throw new Error("Failed to fetch liked songs data.");
      }

      const likedTracks = likedTracksData.items.map((item) => ({
        uri: item.uri,
        uid: item.uid,
        name: item.name,
        albumUri: item.album.uri,
        albumName: item.album.name,
        artistUris: item.artists.map((artist) => artist.uri),
        artistName: item.artists[0]?.name,
        allArtists: normalizeArtistNames(item.artists),
        durationMilis: item.duration.milliseconds,
        addedAt: item.addedAt,
        playCount: "N/A",
        popularity: null,
        releaseDate: null,
        track: {
            album: {
                id: item.album.uri.split(":")[2]
            },
            name: item.name,
            duration_ms: item.duration.milliseconds,
            id: item.uri.split(":")[2]
          }
      }));

      return likedTracks;

    } catch (error)      {
      console.error("Error fetching liked songs:", error);
      showNotification("Failed to fetch liked songs.", true);
      return [];
    }
  }
    
  async function getLocalFilesTracks() {
    try {
        const localTracksData = await Spicetify.Platform.LocalFilesAPI.getTracks();
        if (!localTracksData) {
            throw new Error("Failed to fetch local files data.");
        }

        return localTracksData.map((item) => ({
            uri: item.uri,
            uid: item.uid,
            name: item.name,
            albumUri: item.album.uri,
            albumName: item.album.name,
            artistUris: item.artists.map((artist) => artist.uri),
            artistName: item.artists[0]?.name,
            allArtists: normalizeArtistNames(item.artists),
            durationMilis: item.duration.milliseconds,
            playCount: "N/A",
            popularity: null,
            releaseDate: null,
            track: {
                album: {
                    id: item.album.uri.split(":")[2],
                    name: item.album.name,
                },
                name: item.name,
                duration_ms: item.duration.milliseconds,
                id: item.uri.split(":")[2]
            }
        }));
    } catch (error) {
        console.error("Error fetching local files:", error);
        showNotification("Failed to fetch local files.", true);
        return [];
    }
  }

  const fetchPlaylistContents = async (uri) => (await PlaylistAPI.getContents(uri)).items;

  const parsePlaylistAPITrack = (track) => ({
    uri: track.uri,
    uid: track.uid,
    name: track.name,
    albumUri: track.album.uri,
    albumName: track.album.name,
    artistUris: track.artists.map((artist) => artist.uri),
    allArtists: normalizeArtistNames(track.artists),
    artistName: track.artists[0]?.name,
    durationMilis: track.duration.milliseconds,
    playcount: 0,
    popularity: 0,
    releaseDate: 0,
    track: {
      album: {
        id: track.album.uri.split(":")[2]
      },
      name: track.name,
      duration_ms: track.duration.milliseconds,
      id: track.uri.split(":")[2]
    }
  });

  const getPlaylistTracksSpicetify = async (playlistId) => {
    const playlistUri = `spotify:playlist:${playlistId}`;
    const retries = 5;
    let delay = 1000;

    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            if (!Spicetify || !URI) {
                throw new Error('Spicetify is not properly initialized');
            }

            if (!playlistId) {
                throw new Error('Invalid playlist ID');
            }

            const playlistContents = await fetchPlaylistContents(playlistUri);
            
            if (!playlistContents || !Array.isArray(playlistContents)) {
                throw new Error('Failed to fetch playlist contents');
            }

            const parsedTracks = playlistContents
                .filter(track => {
                    if (!track || !track.uri) {
                        return false;
                    }
                    return track.uri.startsWith("spotify:track:") || Spicetify.URI.isLocal(track.uri);
                })
                .map(track => {
                    try {
                        return parsePlaylistAPITrack(track);
                    } catch (parseError) {
                        showNotification(
                            'Error processing some tracks. Please try again.',
                            true
                        );
                        return null;
                    }
                })
                .filter(track => track !== null);

            if (parsedTracks.length === 0) {
                throw new Error('No valid tracks found in playlist');
            }

            return parsedTracks;
        } catch (error) {
            console.error(
                `Error fetching playlist tracks (Attempt ${attempt}/${retries}):`,
                error
            );
            
            if (attempt < retries) {
                await new Promise((resolve) => setTimeout(resolve, delay));
                delay *= 2;
            } else {
                console.error(
                    `Failed to fetch playlist tracks after ${retries} attempts.`
                );
                throw error;
            }
        }
    }
  };

  async function getPlaylistTracks(playlistId) {
    try {
        if (!playlistId || typeof playlistId !== 'string') {
            throw new Error('Invalid playlist format');
        }

        const tracks = await getPlaylistTracksSpicetify(playlistId);
        
        if (!Array.isArray(tracks)) {
            throw new Error('Failed to process playlist tracks');
        }

        if (tracks.length > 0) {
            return tracks;
        } else {
            throw new Error('No tracks found in playlist');
        }
    } catch (error) {
        console.error('Error in getPlaylistTracks:', error);
        showNotification(
            `Failed to fetch playlist tracks: ${error.message}. Please try again.`,
            true
        );
    }

    return [];
  }

  async function getAlbumTracks(albumId) {
    const { CosmosAsync, GraphQL } = Spicetify;
    const albumUri = `spotify:album:${albumId}`;

    const fetchAlbumTracksGQL = async () => {
        const res = await GraphQL.Request(GraphQL.Definitions.queryAlbumTracks, {
            uri: albumUri,
            offset: 0,
            limit: 500,
            locale: "en"
        });

        const album = res.data?.albumUnion;
        const tracks = album?.tracksV2?.items || album?.tracks?.items;
        if (!tracks) throw new Error("GraphQL Album fetch failed");

        const releaseDate = album.date?.isoString || album.date?.year?.toString();

        return tracks.map(item => {
            const t = item.track;
            const artists = t.artists.items.map(a => ({
                name: a.profile.name,
                uri: a.uri,
                id: a.uri ? a.uri.split(':')[2] : null
            }));
            const rawPlaycount = t.playcount ? parseInt(t.playcount, 10) : 0;

            return {
                uri: t.uri,
                uid: null,
                name: t.name,
                songTitle: t.name,
                albumUri: albumUri,
                albumName: album.name,
                artistUris: artists.map(a => a.uri),
                allArtists: artists.map(a => a.name).join(", "),
                artistName: artists[0]?.name,
                durationMilis: t.duration.totalMilliseconds,
                durationMs: t.duration.totalMilliseconds,
                playcount: rawPlaycount,
                playCount: rawPlaycount > 0 ? rawPlaycount : "N/A",
                popularity: null,
                releaseDate: releaseDate,
                track: {
                    album: { 
                        id: albumId, 
                        name: album.name, 
                        release_date: releaseDate,
                        images: album.coverArt?.sources?.map(s => ({ url: s.url })) || []
                    },
                    name: t.name,
                    duration_ms: t.duration.totalMilliseconds, 
                    id: t.uri.split(':')[2],
                    artists: artists,
                    external_ids: {}
                }
            };
        });
    };

    if (isFallbackActive()) {
        try {
            return await fetchAlbumTracksGQL();
        } catch (e) {
            console.error("[Sort-Play] Fallback getAlbumTracks failed:", e);
            return [];
        }
    }

    try {
      const albumData = await CosmosAsync.get(`https://api.spotify.com/v1/albums/${albumId}`);
      if (!albumData || !albumData.tracks) {
        throw new Error("Failed to fetch initial album data.");
      }
  
      let allTracks = albumData.tracks.items;
      let nextUrl = albumData.tracks.next;
  
      while (nextUrl) {
        const nextPageData = await CosmosAsync.get(nextUrl);
        if (nextPageData && nextPageData.items) {
          allTracks.push(...nextPageData.items);
          nextUrl = nextPageData.next;
        } else {
          nextUrl = null; 
        }
      }

      return allTracks.map(track => ({
        uri: track.uri,
        uid: null,
        name: track.name,
        songTitle: track.name,
        albumUri: albumData.uri,
        albumName: albumData.name,
        artistUris: track.artists.map(artist => artist.uri),
        allArtists: track.artists.map(artist => artist.name).join(", "),
        artistName: track.artists[0].name,
        durationMilis: track.duration_ms,
        durationMs: track.duration_ms,
        playCount: "N/A",
        popularity: null,
        releaseDate: null,
        track: {
          album: { id: albumId, name: albumData.name },
          name: track.name,
          duration_ms: track.duration_ms,
          id: track.id,
        }
      }));
    } catch (error) {
      if (registerWebApiFailure()) {
          try {
              return await fetchAlbumTracksGQL();
          } catch (e) {
              return [];
          }
      }
      console.error(`Error fetching tracks for album ${albumId}:`, error);
      showNotification("Failed to fetch all album tracks.", true);
      return [];
    }
  }

  async function getArtistTracks(artistUri, isHeadless = false) {
    const { Locale, GraphQL, CosmosAsync } = Spicetify;
  
    const queryArtistOverview = Spicetify.GraphQL.Definitions.queryArtistOverview || {
      name: "queryArtistOverview",
      operation: "query",
      sha256Hash: "35648a112beb1794e39ab931365f6ae4a8d45e65396d641eeda94e4003d41497",
    };
  
    if (!isHeadless) {
        mainButton.innerHTML = '<div class="loader"></div>';
        setButtonProcessing(true);
    }
  
    try {
      const artistData = await GraphQL.Request(queryArtistOverview, {
        uri: artistUri,
        locale: Locale.getLocale(),
        includePrerelease: false,
      });
  
      if (artistData.errors) throw new Error(artistData.errors[0].message);
      const artistName = artistData.data.artistUnion.profile.name;
      const artistId = artistUri.split(":")[2];

      const allAlbumMetadata = new Map();

      const fetchAlbumIdsWeb = async () => {
          let nextUrl = `https://api.spotify.com/v1/artists/${artistId}/albums?include_groups=album,single,appears_on,compilation&limit=50`;
          while (nextUrl) {
            const albumRes = await CosmosAsync.get(nextUrl);
            if (!albumRes.items) break;
            albumRes.items.forEach((album) => {
                allAlbumMetadata.set(album.id, { type: album.album_type, date: album.release_date });
            });
            nextUrl = albumRes.next;
            if (nextUrl) await new Promise(resolve => setTimeout(resolve, 50)); 
          }
      };

      const fetchAlbumIdsGQL = async () => {
          let offset = 0;
          let limit = 100;
          let total = null;
          while (total === null || offset < total) {
              const res = await GraphQL.Request(GraphQL.Definitions.queryArtistDiscographyAll, {
                  uri: artistUri,
                  offset: offset,
                  limit: limit
              });
              const disc = res.data.artistUnion.discography.all;
              total = disc.totalCount;
              
              disc.items.forEach(group => {
                  if (group.releases && group.releases.items) {
                      group.releases.items.forEach(rel => {
                          const id = rel.uri.split(':')[2];
                          allAlbumMetadata.set(id, { 
                              type: rel.type || 'album',
                              date: rel.date?.isoString || rel.date?.year 
                          });
                      });
                  }
              });
              offset += limit;
          }
      };

      const fetchAppearsOnIdsGQL = async () => {
          let offset = 0;
          let limit = 100;
          let total = null;
          while (total === null || offset < total) {
              try {
                  const res = await GraphQL.Request(GraphQL.Definitions.queryArtistAppearsOn, {
                      uri: artistUri,
                      offset: offset,
                      limit: limit
                  });
                  const appearsOn = res?.data?.artistUnion?.relatedContent?.appearsOn;
                  if (!appearsOn) break;
                  
                  total = appearsOn.totalCount;
                  
                  if (appearsOn.items) {
                      appearsOn.items.forEach(item => {
                          const release = item.releases?.items?.[0];
                          if (release) {
                              const id = release.uri.split(':')[2];
                              if (!allAlbumMetadata.has(id)) {
                                  allAlbumMetadata.set(id, { 
                                      type: 'appears_on', 
                                      date: null 
                                  });
                              }
                          }
                      });
                  }
                  offset += limit;
              } catch (e) {
                  console.warn("Failed to fetch Appears On batch", e);
                  break;
              }
          }
      };

      if (isFallbackActive()) {
          await Promise.all([fetchAlbumIdsGQL(), fetchAppearsOnIdsGQL()]);
      } else {
          try {
              await fetchAlbumIdsWeb();
          } catch (e) {
              if (registerWebApiFailure()) {
                  await Promise.all([fetchAlbumIdsGQL(), fetchAppearsOnIdsGQL()]);
              } else {
                  throw e;
              }
          }
      }
  
      const allTracks = [];
      const allAlbumIdArray = Array.from(allAlbumMetadata.keys());

      const fetchTracksWeb = async () => {
          const batchSize = 20; 
          const batchPromises = [];
          
          for (let i = 0; i < allAlbumIdArray.length; i += batchSize) {
            const batch = allAlbumIdArray.slice(i, i + batchSize);
            const promise = withRetry(
                () => CosmosAsync.get(`https://api.spotify.com/v1/albums?ids=${batch.join(',')}`),
                CONFIG.spotify.retryAttempts,
                CONFIG.spotify.retryDelay
            ).catch(err => {
                console.warn(`[Sort-Play] Failed to fetch album batch for artist ${artistName} (skipped):`, err);
                return { albums: [] }; 
            });
            batchPromises.push(promise);
          }
          
          const albumDataBatches = await Promise.all(batchPromises);
          
          for (const batch of albumDataBatches) {
            if (!batch || !batch.albums) continue;

            const batchResults = await Promise.all(batch.albums.map(async (album) => {
                if (!album || !album.tracks || !album.tracks.items) return [];
                
                let rawTracks = [...album.tracks.items];
                const totalTracks = album.total_tracks || 0;

                if (totalTracks > 50) {
                    const isCompilation = album.album_type === 'compilation' || album.album_group === 'appears_on';
                    
                    let shouldFetchMore = true;
                    if (isCompilation) {
                        const foundInFirstPage = rawTracks.some(t => t.artists.some(a => a.uri === artistUri || a.name === artistName));
                        if (foundInFirstPage) {
                            shouldFetchMore = false;
                        }
                    }

                    if (shouldFetchMore) {
                        const pagePromises = [];
                        for (let offset = 50; offset < totalTracks; offset += 50) {
                            const url = `https://api.spotify.com/v1/albums/${album.id}/tracks?limit=50&offset=${offset}`;
                            pagePromises.push(CosmosAsync.get(url).catch(() => null));
                        }

                        const pageResults = await Promise.all(pagePromises);
                        pageResults.forEach(res => {
                            if (res && res.items) {
                                rawTracks.push(...res.items);
                            }
                        });
                    }
                }

                return rawTracks
                  .filter(track => track.artists.some(artist => artist.name === artistName || artist.uri === artistUri))
                  .map(track => ({
                    uri: track.uri,
                    uid: null, 
                    name: track.name,
                    albumUri: album.uri,
                    albumName: album.name,
                    artistUris: track.artists.map(artist => artist.uri),
                    allArtists: track.artists.map(artist => artist.name).join(", "),
                    artistName: track.artists[0].name,
                    durationMilis: track.duration_ms,
                    album_type: album.album_type,
                    playcount: 0, popularity: 0, releaseDate: 0,
                    track: {
                      album: { id: album.id },
                      name: track.name,
                      duration_ms: track.duration_ms,
                      id: track.id,
                    },
                  }));
            }));

            batchResults.forEach(albumTracks => allTracks.push(...albumTracks));
          }
      };

      const fetchTracksFallback = async () => {
          const albumIds = Array.from(allAlbumMetadata.keys());
          const BATCH_SIZE = 50;
          
          for (let i = 0; i < albumIds.length; i += BATCH_SIZE) {
              const batch = albumIds.slice(i, i + BATCH_SIZE);
              
              const promises = batch.map(async (id) => {
                  const meta = allAlbumMetadata.get(id);
                  const tracks = await getAlbumTracks(id);
                  
                  return tracks.filter(track => {
                      const hasArtistUri = track.artistUris && track.artistUris.includes(artistUri);
                      const hasArtistName = track.allArtists && track.allArtists.includes(artistName);
                      return hasArtistUri || hasArtistName;
                  }).map(track => {
                      if (track.track && track.track.album) {
                          track.track.album.album_type = meta.type;
                      }
                      return {
                          ...track,
                          albumType: meta.type, 
                          album_type: meta.type 
                      };
                  });
              });
              
              const results = await Promise.all(promises);
              results.forEach(tracks => allTracks.push(...tracks));
          }
      };

      if (isFallbackActive()) {
          await fetchTracksFallback();
      } else {
          try {
              await fetchTracksWeb();
          } catch (e) {
              if (registerWebApiFailure()) {
                  await fetchTracksFallback();
              } else {
                  throw e;
              }
          }
      }

      const coreTracks = [];
      const compilationTracks = [];

      for (const track of allTracks) {
        const type = (track.album_type || 'album').toLowerCase(); 
        if (type === 'album' || type === 'single') {
          coreTracks.push(track);
        } else {
          compilationTracks.push(track);
        }
      }

      const uniqueCompilationTracksMap = new Map();
      for (const track of compilationTracks) {
        const title = (track.name || "").toLowerCase().trim();
        const duration = track.durationMilis;
        const artistKey = (track.artistUris || []).sort().join(',');
        const compositeKey = `${title}|${duration}|${artistKey}`;

        if (!uniqueCompilationTracksMap.has(compositeKey)) {
          uniqueCompilationTracksMap.set(compositeKey, track);
        }
      }
      const uniqueCompilationTracks = Array.from(uniqueCompilationTracksMap.values());

      const finalTracks = [...coreTracks, ...uniqueCompilationTracks];
  
      return finalTracks;
  
    } catch (error) {
      console.error("Error fetching artist tracks:", error);
      throw error;
    }
  }

  async function getArtistTracksForShuffle(artistUri) {
    const { Locale, GraphQL, CosmosAsync } = Spicetify;
  
    const queryArtistOverview = Spicetify.GraphQL.Definitions.queryArtistOverview || {
      name: "queryArtistOverview",
      operation: "query",
      sha256Hash: "35648a112beb1794e39ab931365f6ae4a8d45e65396d641eeda94e4003d41497",
    };
  
    try {
      const artistData = await GraphQL.Request(queryArtistOverview, {
        uri: artistUri,
        locale: Locale.getLocale(),
        includePrerelease: false,
      });
  
      if (artistData.errors) throw new Error(artistData.errors[0].message);
      const artistName = artistData.data.artistUnion.profile.name;
      const artistId = artistUri.split(":")[2];

      const allAlbumIds = new Set();

      const fetchAlbumIdsWeb = async () => {
          let nextUrl = `https://api.spotify.com/v1/artists/${artistId}/albums?include_groups=album,single,appears_on,compilation&limit=50`;
          while (nextUrl) {
            const albumRes = await CosmosAsync.get(nextUrl);
            if (!albumRes.items) break;
            albumRes.items.forEach((album) => allAlbumIds.add(album.id));
            nextUrl = albumRes.next;
            if (nextUrl) await new Promise(resolve => setTimeout(resolve, 50)); 
          }
      };

      const fetchAlbumIdsGQL = async () => {
          let offset = 0;
          let limit = 100;
          let total = null;
          while (total === null || offset < total) {
              const res = await GraphQL.Request(GraphQL.Definitions.queryArtistDiscographyAll, {
                  uri: artistUri,
                  offset: offset,
                  limit: limit
              });
              const disc = res.data.artistUnion.discography.all;
              total = disc.totalCount;
              disc.items.forEach(group => {
                  group.releases.items.forEach(rel => {
                      allAlbumIds.add(rel.uri.split(':')[2]);
                  });
              });
              offset += limit;
          }
      };

      if (isFallbackActive()) {
          await fetchAlbumIdsGQL();
      } else {
          try {
              await fetchAlbumIdsWeb();
          } catch (e) {
              if (registerWebApiFailure()) {
                  await fetchAlbumIdsGQL();
              } else {
                  throw e;
              }
          }
      }
  
      const allTracks = [];
      const allAlbumIdArray = Array.from(allAlbumIds);

      const fetchTracksWeb = async () => {
          const batchSize = 20; 
          const batchPromises = [];
          
          for (let i = 0; i < allAlbumIdArray.length; i += batchSize) {
            const batch = allAlbumIdArray.slice(i, i + batchSize);
            const promise = withRetry(
                () => CosmosAsync.get(`https://api.spotify.com/v1/albums?ids=${batch.join(',')}`),
                CONFIG.spotify.retryAttempts,
                CONFIG.spotify.retryDelay
            ).catch(err => {
                console.warn(`[Sort-Play] Failed to fetch album batch for shuffle:`, err);
                return { albums: [] }; 
            });
            batchPromises.push(promise);
          }
          
          const albumDataBatches = await Promise.all(batchPromises);
          
          for (const batch of albumDataBatches) {
            if (!batch || !batch.albums) continue;

            const batchResults = await Promise.all(batch.albums.map(async (album) => {
                if (!album || !album.tracks || !album.tracks.items) return [];

                let rawTracks = [...album.tracks.items];
                const totalTracks = album.total_tracks || 0;

                if (totalTracks > 50) {
                    const isCompilation = album.album_type === 'compilation' || album.album_group === 'appears_on';
                    
                    let shouldFetchMore = true;
                    if (isCompilation) {
                        const foundInFirstPage = rawTracks.some(t => t.artists.some(a => a.uri === artistUri || a.name === artistName));
                        if (foundInFirstPage) {
                            shouldFetchMore = false;
                        }
                    }

                    if (shouldFetchMore) {
                        const pagePromises = [];
                        for (let offset = 50; offset < totalTracks; offset += 50) {
                            const url = `https://api.spotify.com/v1/albums/${album.id}/tracks?limit=50&offset=${offset}`;
                            pagePromises.push(CosmosAsync.get(url).catch(() => null));
                        }

                        const pageResults = await Promise.all(pagePromises);
                        pageResults.forEach(res => {
                            if (res && res.items) {
                                rawTracks.push(...res.items);
                            }
                        });
                    }
                }

                return rawTracks
                    .filter(track => track.artists.some(artist => artist.name === artistName || artist.uri === artistUri))
                    .map(track => ({
                      uri: track.uri,
                      uid: null, 
                      name: track.name,
                      albumUri: album.uri,
                      albumName: album.name,
                      artistUris: track.artists.map(artist => artist.uri),
                      allArtists: track.artists.map(artist => artist.name).join(", "),
                      artistName: track.artists[0].name,
                      durationMilis: track.duration_ms,
                      album_type: album.album_type,
                      playcount: 0, popularity: 0, releaseDate: 0,
                      track: {
                        album: { id: album.id },
                        name: track.name,
                        duration_ms: track.duration_ms,
                        id: track.id,
                      },
                    }));
            }));

            batchResults.forEach(tracks => allTracks.push(...tracks));
          }
      };

      const fetchTracksFallback = async () => {
          const promises = allAlbumIdArray.map(async (id) => {
              const tracks = await getAlbumTracks(id);
              return tracks.filter(track => {
                  const hasArtistUri = track.artistUris && track.artistUris.includes(artistUri);
                  const hasArtistName = track.allArtists && track.allArtists.includes(artistName);
                  return hasArtistUri || hasArtistName;
              }).map(track => ({
                  ...track,
                  album_type: 'album' 
              }));
          });
          const results = await Promise.all(promises);
          results.forEach(tracks => allTracks.push(...tracks));
      };

      if (isFallbackActive()) {
          await fetchTracksFallback();
      } else {
          try {
              await fetchTracksWeb();
          } catch (e) {
              if (registerWebApiFailure()) {
                  await fetchTracksFallback();
              } else {
                  throw e;
              }
          }
      }
  
      const uniqueTracksMap = new Map();
      const isCoreDiscography = (track) => 
          track.album_type === 'album' || track.album_type === 'single';

      for (const track of allTracks) {
        const title = (track.name || "").toLowerCase().trim();
        const duration = track.durationMilis;
        const artistKey = (track.artistUris || []).sort().join(',');
        const compositeKey = `${title}|${duration}|${artistKey}`;

        const existingTrack = uniqueTracksMap.get(compositeKey);

        if (!existingTrack) {
            uniqueTracksMap.set(compositeKey, track);
        } else {
            if (isCoreDiscography(track) && !isCoreDiscography(existingTrack)) {
                uniqueTracksMap.set(compositeKey, track);
            }
        }
      }

      const uniqueTracks = Array.from(uniqueTracksMap.values());
  
      return uniqueTracks;
  
    } catch (error) {
      console.error("Error fetching artist tracks for shuffle:", error);
      throw error;
    }
  }

  async function getArtistImageUrl(artistId) {
    const fetchWeb = async () => {
        const artistData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists/${artistId}`);
        return artistData.images[0]?.url;
    };

    const fetchGQL = async () => {
        const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, {
            uri: `spotify:artist:${artistId}`,
            locale: "en",
            includePrerelease: false
        });
        
        const sources = res.data.artistUnion.visuals.avatarImage?.sources;
        if (!sources || sources.length === 0) return null;

        const bestSource = sources.reduce((prev, curr) => (prev.width > curr.width ? prev : curr));
        return bestSource.url;
    };

    if (isFallbackActive()) {
        try { return await fetchGQL(); } catch(e) { return null; }
    }

    try {
        return await fetchWeb();
    } catch (e) {
        if (registerWebApiFailure()) {
            try { return await fetchGQL(); } catch(e) { return null; }
        }
        return null;
    }
  }
  
  function setPlaylistImage(playlistId, base64Image, maxRetries = 10, retryInterval = 4000) {
    (async () => {
        const playlistUri = `spotify:playlist:${playlistId}`;

        const setInternalImage = async () => {
            const bufferToHex = (buffer) => Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
            const getFileFromBase64 = async (b64) => {
                const res = await fetch(b64);
                const blob = await res.blob();
                return new File([blob], "cover.jpg", { type: "image/jpeg" });
            };

            const file = await getFileFromBase64(base64Image);
            const sessionToken = Spicetify.Platform.Session.accessToken;
            const uploadToken = await Spicetify.Platform.PlaylistAPI.uploadImage(file);
            
            if (!uploadToken) throw new Error("Upload failed: No token returned");

            const regRes = await fetch(`https://spclient.wg.spotify.com/playlist/v2/playlist/${playlistId}/register-image`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${sessionToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ uploadToken })
            });

            if (!regRes.ok) throw new Error(`Registration failed: ${regRes.status}`);

            const buffer = await regRes.arrayBuffer();
            const fullHex = bufferToHex(buffer);
            const cleanHexId = fullHex.startsWith('0a14') ? fullHex.slice(4) : fullHex;

            await Spicetify.Platform.PlaylistAPI.setAttributes(playlistUri, { picture: cleanHexId });
            if (typeof Spicetify.Platform.PlaylistAPI.resync === 'function') await Spicetify.Platform.PlaylistAPI.resync(playlistUri);
        };

        const setWebApiImage = async () => {
            try {
                await Spicetify.CosmosAsync.put(
                    `https://api.spotify.com/v1/playlists/${playlistId}/images`,
                    base64Image.split("base64,")[1]
                );
            } catch (putError) {
                const isExpectedJsonError = putError instanceof SyntaxError && putError.message.includes("Unexpected end of JSON input");
                if (!isExpectedJsonError) throw putError;
            }
        };

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                if (isFallbackActive()) {
                    await setInternalImage();
                } else {
                    try {
                        await setWebApiImage();
                    } catch (error) {
                        if (registerWebApiFailure()) {
                            await setInternalImage();
                        } else {
                            throw error;
                        }
                    }
                }

                await new Promise(resolve => setTimeout(resolve, 1500));

                const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(playlistUri);
                if (meta && meta.images && meta.images.length > 0 && !isDefaultMosaicCover(meta.images[0].url)) {
                    return;
                }
                
                throw new Error("Verification failed: Image not updated on Spotify side yet.");

            } catch (error) {                
                if (attempt < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, retryInterval));
                } else {
                    console.error(`[Sort-Play] Failed to set and verify playlist image for ${playlistId} after ${maxRetries} attempts.`, error);
                }
            }
        }
    })();
}

  async function imageUrlToBase64(url) {
    if (typeof url === 'string') {
        if (url.startsWith("spotify:image:")) {
            const imageId = url.split(":")[2];
            url = `https://i.scdn.co/image/${imageId}`;
        } else if (url.startsWith("spotify:")) {
            throw new Error("Unsupported URI scheme for image fetch");
        }
    }

    const response = await fetch(url);
    const blob = await response.blob();
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
  }
  
  async function toBase64(imageUrl) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "Anonymous";
      img.onload = () => {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const size = 640;
        canvas.width = size;
        canvas.height = size;

        const sourceWidth = img.naturalWidth;
        const sourceHeight = img.naturalHeight;

        const cropSize = Math.min(sourceWidth, sourceHeight);
        const sx = (sourceWidth - cropSize) / 2;
        const sy = (sourceHeight - cropSize) / 2;

        ctx.drawImage(img, sx, sy, cropSize, cropSize, 0, 0, size, size);

        const dataUrl = canvas.toDataURL("image/jpeg"); 
        resolve(dataUrl);
      };
      img.onerror = (error) => reject(error);
      img.src = imageUrl;
    });
  }

  async function getPlayCountsForAlbum(albumId, retries = 10, retryDelay = 2000) {
    if (albumDataCache[albumId]) {
      return albumDataCache[albumId];
    }
    if (!inFlightAlbumRequests[albumId]) {
      inFlightAlbumRequests[albumId] = new Promise(async (resolve, reject) => {
        const { Locale, GraphQL } = Spicetify;

        for (let attempt = 1; attempt <= retries; attempt++) {
          try {
            const res = await GraphQL.Request(GraphQL.Definitions.getAlbum, {
              uri: `spotify:album:${albumId}`,
              locale: Locale.getLocale(),
              offset: 0,
              limit: 500,
            });

            if (!res.data?.albumUnion) {
              throw new Error(
                `No albumUnion in response for album ID: ${albumId}`
              );
            }

            const tracks = res.data.albumUnion.tracksV2 || res.data.albumUnion.tracks;
            if (!tracks?.items) {
              throw new Error(
                `No track items found in album data for album ID: ${albumId}`
              );
            }

            const albumTracks = tracks.items
              .map((item) => {
                const track = item.track;
                if (!track) {
                  console.warn(
                    `Missing track data in item for album ID: ${albumId}`
                  );
                  return null;
                }

                return {
                  uri: track.uri,
                  name: track.name,
                  trackNumber: parseInt(track.trackNumber, 10) || 0,
                  playcount: parseInt(track.playcount, 10) || 0,
                };
              })
              .filter((track) => track !== null);

            if (albumTracks.length === 0) {
              throw new Error(
                `No valid tracks found in response for album ID: ${albumId}`
              );
            }
            albumDataCache[albumId] = albumTracks;
            resolve(albumTracks);
            return;
          } catch (error) {
            if (attempt < retries) {
              await new Promise((resolve) => setTimeout(resolve, retryDelay));
              retryDelay *= 2;
            } else {
              reject(error);
            }
          }
        }
      });
    } 

    try {
      return await inFlightAlbumRequests[albumId];
    } catch (error) {
      console.error(`Final failure for album ID ${albumId}:`, error);
      return [];
    } finally {
      delete inFlightAlbumRequests[albumId];
    }
  }

  async function getReleaseDatesForAlbum(albumId, retries = 10, retryDelay = 2000) {
    if (albumReleaseDateCache[albumId]) {
      return albumReleaseDateCache[albumId];
    }

    if (!inFlightAlbumReleaseDateRequests[albumId]) {
      inFlightAlbumReleaseDateRequests[albumId] = new Promise(async (resolve, reject) => {
        if (albumTracksDataCache[albumId]) {
          const releaseDate = albumTracksDataCache[albumId][0]?.releaseDate;
          if (releaseDate) {
            albumReleaseDateCache[albumId] = releaseDate;
            resolve(releaseDate);
            return;
          }
        }

        const { Locale, GraphQL } = Spicetify;

        for (let attempt = 1; attempt <= retries; attempt++) {
          try {
            const res = await GraphQL.Request(GraphQL.Definitions.getAlbum, {
              uri: `spotify:album:${albumId}`,
              locale: Locale.getLocale(),
              offset: 0,
              limit: 500,
            });

            if (!res.data?.albumUnion) {
              throw new Error(`No albumUnion in response for album ID: ${albumId}`);
            }

            const releaseDate = new Date(res.data.albumUnion.date.isoString).getTime();
            albumReleaseDateCache[albumId] = releaseDate;

            const tracks = res.data.albumUnion.tracksV2?.items || res.data.albumUnion.tracks?.items;
            if (tracks) {
              const albumTracks = tracks.map((item) => {
                const track = item.track;
                return {
                  uri: track.uri,
                  name: track.name,
                  releaseDate: releaseDate, 
                };
              });
              albumTracksDataCache[albumId] = albumTracks;
            }

            resolve(releaseDate);
            return;
          } catch (error) {
            if (attempt < retries) {
              await new Promise((resolve) => setTimeout(resolve, retryDelay));
              retryDelay *= 2;
            } else {
              reject(error);
              return;
            }
          }
        }
      });
    } 

    try {
      return await inFlightAlbumReleaseDateRequests[albumId];
    } catch (error) {
      console.error(`Final failure for release date for album ID ${albumId}:`, error);
      return null;
    } finally {
      delete inFlightAlbumReleaseDateRequests[albumId];
    }
  }

  async function getTrackDetailsWithPlayCount(track, retries = 10, retryDelay = 1000) {
    const trackId = track.track.id;
    const albumId = track.track.album.id;

    const cachedCount = await idb.get('playCounts', trackId, CACHE_EXPIRE_PLAYCOUNTS);
    
    if (cachedCount !== null && cachedCount !== undefined) {
        return {
            ...track,
            playCount: cachedCount,
            songTitle: track.name,
            albumName: track.albumName || (track.album && track.album.name) || "Unknown Album",
            trackId: trackId,
            albumId: albumId,
            uri: `spotify:track:${trackId}`,
            artistName: track.artistName,
            allArtists: track.allArtists
        };
    }

    try {
      const albumTracksWithPlayCounts = await getPlayCountsForAlbum(albumId);
      let playCount = "N/A";
      const foundTrack = albumTracksWithPlayCounts.find(
        (albumTrack) => albumTrack.uri === `spotify:track:${trackId}`
      );

      if (foundTrack) {
        playCount = foundTrack.playcount;
        if (playCount !== "N/A") {
            await idb.set('playCounts', trackId, playCount);
        }
      }

      return {
        trackNumber: foundTrack ? foundTrack.trackNumber : 0,
        songTitle: track.name, 
        albumName: track.albumName || (track.album && track.album.name) ||  "Unknown Album",
        trackId: trackId,
        albumId: albumId,
        durationMs: track.track.duration_ms,
        playCount: playCount,
        uri: `spotify:track:${trackId}`,
        artistName: track.artistName,
        allArtists: track.allArtists,
      };
    } catch (error) {
      console.error(`Error getting details for track ${track.name}:`, error);
      if (retries > 0) {
        await new Promise((resolve) => setTimeout(resolve, retryDelay));
        return getTrackDetailsWithPlayCount(track, retries - 1, retryDelay * 2);
      }
      return null;
    }
  }

  async function enrichTracksWithPlayCounts(tracks, updateProgress = () => {}) {
    const tracksWithIds = tracks.map(t => {
        const id = t.trackId || t.id || (t.track && t.track.id);
        const albumId = t.albumId || (t.album && t.album.id) || (t.track && t.track.album && t.track.album.id);
        return { ...t, _tempId: id, _tempAlbumId: albumId };
    });

    const trackIdsToCheck = tracksWithIds.map(t => t._tempId).filter(Boolean);

    const cachedPlayCounts = await idb.getMany('playCounts', trackIdsToCheck, CACHE_EXPIRE_PLAYCOUNTS);

    const albumGroups = new Map();
    const playCountMap = new Map(); 

    tracksWithIds.forEach(track => {
        if (!track._tempId) return;

        const cachedVal = cachedPlayCounts.get(track._tempId);
        
        if (cachedVal !== undefined && cachedVal !== null) {
            playCountMap.set(track._tempId, cachedVal);
        } else if (track._tempAlbumId) {
            if (!albumGroups.has(track._tempAlbumId)) {
                albumGroups.set(track._tempAlbumId, []);
            }
            albumGroups.get(track._tempAlbumId).push(track);
        }
    });

    const uniqueAlbumIds = Array.from(albumGroups.keys());
    
    if (uniqueAlbumIds.length > 0) {
        let processedAlbums = 0;
        const totalAlbums = uniqueAlbumIds.length;
        const CONCURRENCY_LIMIT = 10;

        async function worker(queue) {
            while (queue.length > 0) {
                const albumId = queue.shift();
                try {
                    const albumTracks = await getPlayCountsForAlbum(albumId);
                    
                    albumTracks.forEach(t => {
                        const tId = t.uri.split(":")[2];
                        if (t.playcount !== undefined) {
                            playCountMap.set(tId, t.playcount);
                            idb.set('playCounts', tId, t.playcount); 
                        }
                    });
                } catch (error) {
                    console.error(`Failed to process album ${albumId}`, error);
                } finally {
                    processedAlbums++;
                    if (totalAlbums > 0 && updateProgress) {
                        updateProgress(Math.floor((processedAlbums / totalAlbums) * 100));
                    }
                }
            }
        }

        const queue = [...uniqueAlbumIds];
        const workers = Array(Math.min(CONCURRENCY_LIMIT, uniqueAlbumIds.length)).fill(null).map(() => worker(queue));
        await Promise.all(workers);
    } else {
        if (updateProgress) updateProgress(100);
    }

    const enrichedTracks = tracks.map(track => {
        const albumId = track.albumId || (track.album && track.album.id) || (track.track && track.track.album && track.track.album.id) || track?.track?.album?.id;
        const trackId = track.trackId || track.id || (track.track && track.track.id) || track?.track?.id;

        const duration = track.durationMs || track.durationMilis || track.duration_ms || track?.track?.duration_ms || 0;

        if (!albumId || !trackId) {
            return { 
                ...track, 
                playCount: "N/A", 
                trackNumber: 0,
                songTitle: track.name || track.songTitle || "Unknown Title",
                trackId: trackId,
                albumId: albumId,
                durationMs: duration,
                uri: track.uri || (trackId ? `spotify:track:${trackId}` : undefined)
            };
        }

        const playCount = playCountMap.has(trackId) ? playCountMap.get(trackId) : "N/A";

        const enrichedData = {
            trackNumber: track.trackNumber || track.track_number || 0,
            songTitle: track.name || track.songTitle,
            albumName: track.albumName || track.album?.name || track?.track?.album?.name || "Unknown Album",
            trackId: trackId,
            albumId: albumId,
            durationMs: duration,
            playcount: playCount,
            playCount: playCount,
            uri: track.uri || `spotify:track:${trackId}`,
            artistName: track.artistName || track?.artists?.[0]?.name,
            allArtists: track.allArtists || track?.artists?.map(a => a.name).join(", "),
        };
        
        return { ...track, ...enrichedData };
    });

    return enrichedTracks;
  }

  async function refreshTrackAlbumInfo(tracks, updateProgress = () => {}) {
    const BATCH_SIZE = 50;
    const refreshedTracks = [];
    
    const uniqueTracks = new Map();
    tracks.forEach(t => {
        const id = t.id || t.track?.id || (t.uri ? t.uri.split(':')[2] : null);
        if (id && !uniqueTracks.has(id)) uniqueTracks.set(id, t);
    });

    const trackIds = Array.from(uniqueTracks.keys());
    
    const cachedMetadata = await idb.getMany('trackMetadata', trackIds, CACHE_EXPIRE_METADATA);
    const missingIds = [];

    trackIds.forEach(id => {
        if (!cachedMetadata.has(id)) {
            missingIds.push(id);
        }
    });

    const processRefreshInternal = async (id) => {
        const data = await fetchInternalTrackMetadata(id);
        if (data) {
            const cacheData = {
                name: data.name,
                album: {
                    name: data.album.name,
                    id: data.album.id,
                    uri: data.album.uri,
                    release_date: data.album.release_date,
                    album_type: 'album'
                },
                albumType: 'album',
                artists: data.artists.map(a => ({
                    id: a.id,
                    name: a.name,
                    uri: a.uri
                })),
                duration_ms: data.duration_ms,
                popularity: data.popularity,
                external_ids: data.external_ids,
                id: data.id,
                uri: data.uri
            };
            cachedMetadata.set(data.id, cacheData);
            idb.set('trackMetadata', data.id, cacheData);
        }
    };

    for (let i = 0; i < missingIds.length; i += BATCH_SIZE) {
        const batchIds = missingIds.slice(i, i + BATCH_SIZE);
        if (batchIds.length === 0) continue;

        if (isFallbackActive()) {
            await Promise.all(batchIds.map(id => processRefreshInternal(id)));
        } else {
            try {
                const trackDetailsResponse = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${batchIds.join(',')}`);
                if (trackDetailsResponse && trackDetailsResponse.tracks) {
                    trackDetailsResponse.tracks.forEach(detailedTrack => {
                        if (!detailedTrack) return;
                        
                        const cacheData = {
                            name: detailedTrack.name,
                            album: {
                                name: detailedTrack.album.name,
                                id: detailedTrack.album.id,
                                uri: detailedTrack.album.uri,
                                release_date: detailedTrack.album.release_date,
                                album_type: detailedTrack.album.album_type
                            },
                            albumType: detailedTrack.album.album_type,
                            artists: detailedTrack.artists.map(a => ({
                                id: a.id,
                                name: a.name,
                                uri: a.uri
                            })),
                            duration_ms: detailedTrack.duration_ms,
                            popularity: detailedTrack.popularity,
                            external_ids: detailedTrack.external_ids,
                            id: detailedTrack.id,
                            uri: detailedTrack.uri
                        };
                        
                        cachedMetadata.set(detailedTrack.id, cacheData);
                        idb.set('trackMetadata', detailedTrack.id, cacheData);
                    });
                }
            } catch (error) {
                if (registerWebApiFailure()) {
                    await Promise.all(batchIds.map(id => processRefreshInternal(id)));
                } else {
                    console.warn(`[Sort-Play] Failed to refresh a batch of track album info:`, error);
                }
            }
        }
        const progress = Math.min(100, Math.floor(((i + BATCH_SIZE) / missingIds.length) * 100));
        updateProgress(progress);
    }

    trackIds.forEach(id => {
        const meta = cachedMetadata.get(id);
        if (meta) {
            const newTrack = {
                uri: meta.uri,
                name: meta.name,
                albumName: meta.album.name,
                artistName: meta.artists[0]?.name,
                allArtists: meta.artists.map(a => a.name).join(", "),
                durationMs: meta.duration_ms,
                popularity: meta.popularity,
                releaseDate: meta.album.release_date,
                albumType: meta.albumType,
                trackId: meta.id,
                albumId: meta.album.id,
                track: {
                    id: meta.id,
                    name: meta.name,
                    uri: meta.uri,
                    duration_ms: meta.duration_ms,
                    album: meta.album,
                    artists: meta.artists,
                    external_ids: meta.external_ids
                }
            };
            refreshedTracks.push(newTrack);
        } else {
            refreshedTracks.push(uniqueTracks.get(id));
        }
    });

    return refreshedTracks;
  }
  
  async function collectTrackIdsForPopularity(track) {
    const trackId = track.uri.split(":")[2];
    return {
      ...track,
      trackId: trackId,
    };
  }

  async function fetchPopularityForMultipleTracks(
    tracks,
    updateProgress,
    totalProgressSteps = 1
  ) {
    const trackIds = tracks.map((track) => track.trackId || (track.uri ? track.uri.split(':')[2] : null)).filter((id) => id);
    const uniqueTrackIds = [...new Set(trackIds)];
    
    const cachedMetadata = await idb.getMany('trackMetadata', uniqueTrackIds, CACHE_EXPIRE_METADATA);
    const missingIds = uniqueTrackIds.filter(id => !cachedMetadata.has(id));

    const batchSize = 50;
    let tracksProcessed = 0;
    const maxRetries = 5;
    const initialDelay = 1000;

    const processInternalItem = async (id) => {
        const data = await fetchInternalTrackMetadata(id);
        if (data) {
            const cacheData = {
                name: data.name,
                album: {
                    name: data.album.name,
                    id: data.album.id,
                    uri: data.album.id ? `spotify:album:${data.album.id}` : null,
                    release_date: data.album.release_date
                },
                artists: data.artists.map(a => ({
                    id: a.id,
                    name: a.name,
                    uri: a.id ? `spotify:artist:${a.id}` : null
                })),
                duration_ms: data.duration_ms,
                popularity: data.popularity,
                external_ids: data.external_ids,
                id: data.id,
                uri: data.uri
            };
            cachedMetadata.set(data.id, cacheData);
            idb.set('trackMetadata', data.id, cacheData);
        }
    };

    for (let i = 0; i < missingIds.length; i += batchSize) {
      const batch = missingIds.slice(i, i + batchSize);
      
      if (isFallbackActive()) {
          await Promise.all(batch.map(id => processInternalItem(id)));
      } else {
          let retries = 0;
          let delay = initialDelay;
          let success = false;

          while (retries < maxRetries && !success) {
            try {
              const response = await Spicetify.CosmosAsync.get(
                `https://api.spotify.com/v1/tracks?ids=${batch.join(",")}`
              );

              if (response && response.tracks) {
                response.tracks.forEach((trackData) => {
                    if (trackData) {
                        const cacheData = {
                            name: trackData.name,
                            album: {
                                name: trackData.album.name,
                                id: trackData.album.id,
                                uri: trackData.album.uri,
                                release_date: trackData.album.release_date
                            },
                            artists: trackData.artists.map(a => ({
                                id: a.id,
                                name: a.name,
                                uri: a.uri
                            })),
                            duration_ms: trackData.duration_ms,
                            popularity: trackData.popularity,
                            external_ids: trackData.external_ids,
                            id: trackData.id,
                            uri: trackData.uri
                        };
                        cachedMetadata.set(trackData.id, cacheData);
                        idb.set('trackMetadata', trackData.id, cacheData);
                    }
                });
                success = true;
              }
            } catch (error) {
               if (registerWebApiFailure()) {
                   await Promise.all(batch.map(id => processInternalItem(id)));
                   success = true;
               }
            }

            if (!success) {
              retries++;
              if (retries < maxRetries) {
                await new Promise((resolve) => setTimeout(resolve, delay));
                delay *= 2;
              }
            }
          }
      }
      
      tracksProcessed += batch.length;
      const intermediateProgress = Math.round(
          ((tracksProcessed / missingIds.length) * 100) / totalProgressSteps
      );
      updateProgress(intermediateProgress);
    }

    return tracks.map(track => {
        const id = track.trackId || (track.uri ? track.uri.split(':')[2] : null);
        const meta = cachedMetadata.get(id);
        return {
            ...track,
            popularity: meta ? meta.popularity : (track.popularity || null)
        };
    });
  }

  async function getTrackDetailsWithReleaseDate(track) {
    const trackId = track.uri.split(":")[2];
    
    const cachedDate = await idb.get('releaseDates', trackId, CACHE_EXPIRE_RELEASE_DATE);
    if (cachedDate) {
        return { ...track, releaseDate: cachedDate };
    }

    let albumId;
    if (track.albumId) {
      albumId = track.albumId;
    } else if (track.albumUri) {
      albumId = track.albumUri.split(":")[2];
    } else {
      console.warn(`Could not determine album ID for track ${track.name}`);
      return { ...track, releaseDate: null };
    }

    try {
      if (albumTracksDataCache[albumId]) {
        const trackData = albumTracksDataCache[albumId].find(t => t.uri === track.uri);
        if (trackData && trackData.releaseDate) {
          await setCachedReleaseDate(trackId, trackData.releaseDate);
          return { ...track, releaseDate: trackData.releaseDate };
        }
      }

      const releaseDate = await getReleaseDatesForAlbum(albumId);
      if (releaseDate) {
          await setCachedReleaseDate(trackId, releaseDate);
      }

      return { ...track, releaseDate: releaseDate };
    } catch (error) {
      console.error(`Error getting release date for track ${track.name} (album ${albumId}):`, error);
      return { ...track, releaseDate: null };
    }
  }

  async function getTrackDetailsWithScrobbles(track, useFallback = false) {
    const maxRetries = 5;
    const initialDelay = 1000; 
    let retries = 0;
    let delay = initialDelay;
    const trackId = track.uri ? track.uri.split(":")[2] : (track.track ? track.track.id : null);

    while (retries < maxRetries) {
      try {
        let artistName, trackName;

        artistName = track.artistName;
        if (!artistName && track.artists && track.artists.length > 0) {
            artistName = track.artists[0]?.name;
        }
        if (!artistName && track.allArtists) {
            artistName = track.allArtists.split(',')[0].trim();
        }
        if (artistName && artistName.includes(';')) {
            artistName = artistName.split(';')[0].trim();
        }

        trackName = track.name;

        if (artistName) artistName = artistName.trim();
        if (trackName) trackName = trackName.trim();

        if (!artistName || !trackName) {
          return {
            ...track,
            scrobbles: null,
            error: "Missing track title or artist name",
            errorLabel: "No Meta"
          };
        }

        const params = new URLSearchParams({
            method: 'track.getInfo',
            artist: artistName,
            track: trackName,
            format: 'json'
        });

        if (lastFmAutocorrect) {
            params.set('autocorrect', '1');
        }
        
        let response = await fetchLfmWithGateway(params);

        if (!response.ok) {
          throw new Error(
            `Last.fm API request failed with status ${response.status}`
          );
        }

        let text = await response.text();
        if (!text || text.trim() === '') {
             throw new Error("Received empty response from Last.fm");
        }

        let data = JSON.parse(text);

        if (data.error === 6 && useFallback) {
            if (lastFmAutocorrect) {
                params.set('autocorrect', '0');
            } else {
                params.set('autocorrect', '1');
            }

            const responseRetry = await fetchLfmWithGateway(params);
            if (responseRetry.ok) {
                const textRetry = await responseRetry.text();
                if (textRetry && textRetry.trim() !== '') {
                    const dataRetry = JSON.parse(textRetry);
                    if (!dataRetry.error) {
                        data = dataRetry;
                    }
                }
            }
        }

        if (data.error) {
          if (data.error === 6) { 
            console.warn(
              `Track not found on Last.fm: ${trackName} by ${artistName}.`
            );
            if (trackId) {
                await setCachedScrobbles(trackId, -1);
            }
            return {
              ...track,
              scrobbles: -1,
              error: "Track not found on Last.fm",
              errorLabel: "N/A"
            };
          } else {
            throw new Error(`Last.fm API error: ${data.message}`);
          }
        }

        let scrobbles = 0;
        const rawCount = data.track?.playcount;
        if (rawCount !== undefined && rawCount !== null && rawCount !== '') {
             const parsed = parseInt(rawCount, 10);
             if (!isNaN(parsed)) {
                 scrobbles = parsed;
             }
        }

        return {
          ...track,
          scrobbles: scrobbles,
        };
      } catch (error) {
        console.error(
          `Error fetching scrobbles for track ${track.name} (Attempt ${
            retries + 1
          }):`,
          error
        );

        retries++;
        if (retries < maxRetries) {
          await new Promise((resolve) => setTimeout(resolve, delay));
          delay *= 2; 
        } else {
          console.error(
            `Failed to fetch scrobbles for track ${track.name} after ${maxRetries} attempts.`
          );
          return {
            ...track,
            scrobbles: null,
            error: `Failed to fetch from Last.fm after ${maxRetries} attempts.`,
            errorLabel: "Failed"
          };
        }
      }
    }
  }

  async function getTrackDetailsWithPersonalScrobbles(track, useFallback = false) {
    const trackId = track.uri ? track.uri.split(":")[2] : (track.track ? track.track.id : null);
    const isLocal = Spicetify.URI.isLocal(track.uri);
    
    if (isLocal && (!track.name || !track.artistName)) {
        return { ...track, personalScrobbles: null, error: "Local file missing metadata.", errorLabel: "No Meta" };
    }
    
    if (!trackId && !isLocal) {
        return { ...track, personalScrobbles: null, error: "Invalid track ID.", errorLabel: "Invalid" };
    }

    let trackName = track.name;
    let artistName = track.artistName;
    if (!artistName && track.artists && track.artists.length > 0) {
        artistName = track.artists[0]?.name;
    }
    if (!artistName && track.allArtists) {
        artistName = track.allArtists.split(',')[0].trim();
    }
    if (artistName && artistName.includes(';')) {
        artistName = artistName.split(';')[0].trim();
    }

    if (artistName) artistName = artistName.trim();
    if (trackName) trackName = trackName.trim();

    const isCurrentTrack = track.uri === currentTrackUriForScrobbleCache;
    const cachedData = isLocal ? null : await getCachedPersonalScrobbles(trackId);

    const LFM_UPDATE_LAG_COOLDOWN = 3 * 60 * 1000; 
    
    if (cachedData && !isCurrentTrack) {
        if (!cachedData.pendingUpdate) {
            return { ...track, personalScrobbles: cachedData.count };
        }
        if ((Date.now() - cachedData.ts) < LFM_UPDATE_LAG_COOLDOWN) {
            return { ...track, personalScrobbles: cachedData.count };
        }
    }

    const username = loadLastFmUsername();
    if (!username) {
      return { ...track, personalScrobbles: null, error: "Last.fm username not set.", errorLabel: "No User" };
    }

    const maxRetries = 5;
    const initialDelay = 1000; 
    let retries = 0;
    let delay = initialDelay;

    while (retries < maxRetries) {
      try {
        if (!artistName || !trackName) {
          return { ...track, personalScrobbles: null, error: "Missing track metadata.", errorLabel: "No Meta" };
        }

        const params = new URLSearchParams({
            method: 'track.getInfo',
            artist: artistName,
            track: trackName,
            username: username,
            format: 'json'
        });

        if (lastFmAutocorrect) {
            params.set('autocorrect', '1');
        }
        
        let response = await fetchLfmWithGateway(params);
        if (!response.ok) throw new Error(`Last.fm API request failed with status ${response.status}`);  
        
        let text = await response.text();
        if (!text || text.trim() === '') {
             throw new Error("Received empty response from Last.fm");
        }

        let data = JSON.parse(text);

        if (data.error === 6 && useFallback) {
            if (lastFmAutocorrect) {
                params.set('autocorrect', '0');
            } else {
                params.set('autocorrect', '1');
            }

            const responseRetry = await fetchLfmWithGateway(params);
            if (responseRetry.ok) {
                const textRetry = await responseRetry.text();
                if (textRetry && textRetry.trim() !== '') {
                    const dataRetry = JSON.parse(textRetry);
                    if (!dataRetry.error) {
                        data = dataRetry;
                    }
                }
            }
        }

        if (data.error) {
          if (data.error === 6) { 
            if (!isLocal) {
                await setCachedPersonalScrobbles(trackId, -1, false);
            }
            return { ...track, personalScrobbles: -1, error: "Track not found on Last.fm", errorLabel: "N/A" };
          } else {
            throw new Error(`Last.fm API error: ${data.message}`);
          }
        }
        
        let newScrobbleCount = 0;
        const rawCount = data.track?.userplaycount;
        if (rawCount !== undefined && rawCount !== null && rawCount !== '') {
             const parsed = parseInt(rawCount, 10);
             if (!isNaN(parsed)) {
                 newScrobbleCount = parsed;
             }
        }
        
        if (!isLocal && !isCurrentTrack) {
            const oldScrobbleCount = cachedData ? cachedData.count : -1;

            if (newScrobbleCount > oldScrobbleCount) {
                await setCachedPersonalScrobbles(trackId, newScrobbleCount, false);
            } else if (cachedData && cachedData.pendingUpdate) {
                await setCachedPersonalScrobbles(trackId, newScrobbleCount, true);
            } else {
                await setCachedPersonalScrobbles(trackId, newScrobbleCount, false);
            }
        }

        return { ...track, personalScrobbles: newScrobbleCount };

      } catch (error) {
        console.error(`Error fetching personal scrobbles for track ${trackName} (Attempt ${retries + 1}):`, error);
        retries++;
        if (retries < maxRetries) {
          await new Promise((resolve) => setTimeout(resolve, delay));
          delay *= 2;
        } else {
          return { ...track, personalScrobbles: null, error: `Failed to fetch after ${maxRetries} attempts.`, errorLabel: "Failed" };
        }
      }
    }
  }

  function showDefaultApiKeyWarning() {
    const modalContainer = document.createElement("div");
    modalContainer.innerHTML = `
      <style>
      .main-embedWidgetGenerator-container {
        width: 425px !important;
        border-radius: 30px;
        overflow: hidden; 
        background-color: #181818 !important;
        border: 2px solid #282828;
      }
      .GenericModal__overlay .GenericModal {
        border-radius: 30px;
        overflow: hidden;
      }
      .main-trackCreditsModal-mainSection {
        overflow-y: hidden !important;
      }
      .GenericModal > .main-embedWidgetGenerator-container {
        height: auto !important;
      } 
      .main-buttons-button:hover {
        filter: brightness(1.2); 
      }
      .main-trackCreditsModal-header {
        padding: 27px 32px 12px !important;
      }
      .main-trackCreditsModal-originalCredits{
        padding-bottom: 20px !important;
      }
      </style>
      <div style="display: flex; flex-direction: column; gap: 15px;">
        <div style="color: white; font-size: 16px; margin-bottom: 15px;">
          You are using the default API key for AI Pick. 
          For extended usage, please use your own API key.
        </div>
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
          <button id="continueAnyway" class="main-buttons-button" 
                  style="padding: 8px 16px; border-radius: 20px; border: none; cursor: pointer; background-color: #333333; font-weight: 500; font-size: 13px; text-transform: uppercase; transition: all 0.04s ease;">
            Continue Anyway
          </button>
          <button id="addApiKey" class="main-buttons-button main-button-primary" 
                  style="padding: 8px 18px; border-radius: 20px; border: none; cursor: pointer; background-color: #1ED760; color: black; font-weight: 600; font-size: 13px; text-transform: uppercase; transition: all 0.04s ease;">
            Set Free API Key
          </button>
        </div>
      </div>
    `;
  
    Spicetify.PopupModal.display({
      title: "<span style='font-size: 25px;'>API Key Warning</span>",
      content: modalContainer,
      isLarge: true,
    });
    tagActiveModalWithFontScope();
  
    const continueButton = document.getElementById("continueAnyway");
    const addApiKeyButton = document.getElementById("addApiKey");
  
    continueButton.addEventListener("click", async () => {
      Spicetify.PopupModal.hide();
      menuButtons.forEach((btn) => {
        if (btn.tagName.toLowerCase() === 'button' && !btn.disabled) {
          btn.style.backgroundColor = "transparent";
        }
      });
      await handleSortAndCreatePlaylist("aiPick");  
    });
  
    addApiKeyButton.addEventListener("click", () => {
      Spicetify.PopupModal.hide();  
      setTimeout(() => {
        showGeminiApiKeyModal();  
      }, 350);
    });
  }

  const ICON_PATHS = {
    sortAsc: "M.998 8.81A.749.749 0 0 1 .47 7.53L7.99 0l7.522 7.53a.75.75 0 1 1-1.06 1.06L8.74 2.87v12.38a.75.75 0 1 1-1.498 0V2.87L1.528 8.59a.751.751 0 0 1-.53.22z",
    sortDesc: "M.998 7.19A.749.749 0 0 0 .47 8.47L7.99 16l7.522-7.53a.75.75 0 1 0-1.06-1.06L8.74 13.13V.75a.75.75 0 1 0-1.498 0v12.38L1.528 7.41a.749.749 0 0 0-.53-.22z",
    groupAlbum: "M4 6.1c0-.56 0-.84.109-1.054a1 1 0 0 1 .437-.437C4.76 4.5 5.04 4.5 5.6 4.5h2.8c.56 0 .84 0 1.054.109a1 1 0 0 1 .437.437C10 5.26 10 5.54 10 6.1v2.8c0 .56 0 .84-.109 1.054a1 1 0 0 1-.437.437c-.214.109-.494.109-1.054.109H5.6c-.56 0-.84 0-1.054-.109a1 1 0 0 1-.437-.437C4 9.74 4 9.46 4 8.9V6.1zm9-.1c0-.466 0-.699.076-.883a1 1 0 0 1 .541-.541c.184-.076.417-.076.883-.076h4c.466 0 .699 0 .883.076a1 1 0 0 1 .541.541C20 5.301 20 5.534 20 6s0 .699-.076.883a1 1 0 0 1-.541.541c-.184.076-.417.076-.883.076h-4c-.466 0-.699 0-.883-.076a1 1 0 0 1-.541-.541C13 6.699 13 6.466 13 6zm0 6c0-.466 0-.699.076-.883a1 1 0 0 1 .541-.541c.184-.076.417-.076.883-.076h4c.466 0 .699 0 .883.076a1 1 0 0 1 .541.541c.076.184.076.417.076.883s0 .699-.076.883a1 1 0 0 1-.541.541c-.184.076-.417.076-.883.076h-4c-.466 0-.699 0-.883-.076a1 1 0 0 1-.541-.541C13 12.699 13 12.466 13 12zm0 6c0-.466 0-.699.076-.883a1 1 0 0 1 .541-.541c.184-.076.417-.076.883-.076h4c.466 0 .699 0 .883.076a1 1 0 0 1 .541.541c.076.184.076.417.076.883s0 .699-.076.883a1 1 0 0 1-.541.541c-.184.076-.417.076-.883.076h-4c-.466 0-.699 0-.883-.076a1 1 0 0 1-.541-.541C13 18.699 13 18.466 13 18zm-9-2.9c0-.56 0-.84.109-1.054a1 1 0 0 1 .437-.437C4.76 13.5 5.04 13.5 5.6 13.5h2.8c.56 0 .84 0 1.054.109a1 1 0 0 1 .437.437C10 14.26 10 14.54 10 15.1v2.8c0 .56 0 .84-.109 1.054a1 1 0 0 1-.437.437c-.214.109-.494.109-1.054.109H5.6c-.56 0-.84 0-1.054-.109a1 1 0 0 1-.437-.437C4 18.74 4 18.46 4 17.9v-2.8z",
    ungroupList: "M8 6L21 6.00078M8 12L21 12.0008M8 18L21 18.0007M3 6.5H4V5.5H3V6.5ZM3 12.5H4V11.5H3V12.5ZM3 18.5H4V17.5H3V18.5Z"
  };
  
  function getSortArrowSvg(reverse) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", "0 0 16 16");
    svg.setAttribute("width", "50%");
    svg.setAttribute("height", "50%");
    svg.style.fill = '#ffffffe6'; 
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", reverse ? ICON_PATHS.sortAsc : ICON_PATHS.sortDesc);

    svg.appendChild(path);
    return svg;
  }

  function getGroupingIconSvg(isGrouped) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", "0 0 24 24");
    svg.setAttribute("width", "19px");
    svg.setAttribute("height", "19px");
    svg.style.fill = 'none';
    svg.style.stroke = '#ffffffe6';
    svg.setAttribute("stroke-width", "2");
    svg.setAttribute("stroke-linecap", "round");
    svg.setAttribute("stroke-linejoin", "round");
    
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("fill", "none");
    path.setAttribute("d", isGrouped ? ICON_PATHS.groupAlbum : ICON_PATHS.ungroupList);
    svg.appendChild(path);
    return svg;
  }

  function createInnerButton(sortType, parentButton, svg) {
    const innerButton = document.createElement("button");
    const isFilterAlbums = sortType === 'filterAlbums';
    
    innerButton.removeAttribute("title");
    innerButton.appendChild(svg);

    innerButton.style.cssText = `
      background-color: transparent;
      border: none;
      border-radius: 2px;
      padding: 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: ${isFilterAlbums ? "35px" : "32px"};
      height: ${isFilterAlbums ? "35px" : "32px"};
      margin-left: 10px;
      margin-right: -10px;
      flex-shrink: 0;
    `;

    const updateTooltipPosition = (tooltip) => {
        if (!innerButton || !tooltip) return;
        const rect = innerButton.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const margin = 10;

        let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
        
        if (left + tooltipRect.width > viewportWidth - margin) {
            left = viewportWidth - tooltipRect.width - margin;
        }
        if (left < margin) {
            left = margin;
        }

        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${rect.top - tooltipRect.height - 8}px`;
    };

    innerButton.addEventListener("mouseenter", (e) => {
      if (isFilterAlbums) {
          svg.style.stroke = "#1ED760";
      } else {
          svg.style.fill = "#1ED760";
      }
      
      const tooltipText = isFilterAlbums 
        ? (sortOrderState[sortType] ? "Ungroup Albums" : "Group by Album")
        : "Toggle Order (Ascending/Descending)";

      const tooltip = document.createElement("div");
      tooltip.className = "sort-play-custom-tooltip";
      tooltip.innerText = tooltipText;
      tooltip.style.cssText = `
        position: fixed;
        background-color: #282828;
        color: #fff;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        z-index: 10000;
        pointer-events: none;
        white-space: nowrap;
        opacity: 0;
        transition: opacity 0.2s;
      `;
      
      document.body.appendChild(tooltip);
      updateTooltipPosition(tooltip);
      
      requestAnimationFrame(() => { 
          tooltip.style.opacity = "1"; 
      });
      
      innerButton._tooltip = tooltip;
    });

    innerButton.addEventListener("mouseleave", () => {
      if (isFilterAlbums) {
          svg.style.stroke = '#ffffffe6';
      } else {
          svg.style.fill = 'currentColor';
      }
      
      if (innerButton._tooltip) {
          innerButton._tooltip.remove();
          innerButton._tooltip = null;
      }
    });

    innerButton.addEventListener("click", (event) => {
      event.stopPropagation();
      sortOrderState[sortType] = !sortOrderState[sortType];
      localStorage.setItem(`sort-play-${sortType}-reverse`, sortOrderState[sortType]);
      
      const path = svg.querySelector("path");
      if (path) {
          const isReverse = sortOrderState[sortType];
          if (isFilterAlbums) {
              path.setAttribute("d", isReverse ? ICON_PATHS.groupAlbum : ICON_PATHS.ungroupList);
              
              if (innerButton._tooltip) {
                  innerButton._tooltip.innerText = isReverse ? "Ungroup Albums" : "Group by Album";
                  updateTooltipPosition(innerButton._tooltip);
              }
          } else {
              path.setAttribute("d", isReverse ? ICON_PATHS.sortAsc : ICON_PATHS.sortDesc);
          }
      }
    });

    return innerButton;
  }

  function createInnerPlayButton() {
    const plusIconSvg = `<svg width="17px" height="17px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 12H18M12 6V18" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`;

    const innerButton = document.createElement("button");
    innerButton.title = "Shuffle and Add to Queue";
    innerButton.innerHTML = plusIconSvg;

    const buttonBgColor = "rgba(var(--spice-rgb-selected-row), 0.03)";
    const buttonHoverBgColor = "rgba(var(--spice-rgb-selected-row), 0.2)";

    innerButton.style.cssText = `
      color: #ffffffe6;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 0;
      width: 35px;
      height: 25px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.1s ease;
      margin-left: auto;
      margin-right: -3px;
      flex-shrink: 0;
    `;

    innerButton.style.backgroundColor = buttonBgColor;

    innerButton.addEventListener("mouseenter", () => {
      innerButton.style.backgroundColor = buttonHoverBgColor;
    });

    innerButton.addEventListener("mouseleave", () => {
      innerButton.style.backgroundColor = buttonBgColor;
    });

    innerButton.addEventListener("click", async (event) => {
      event.stopPropagation();
      innerButton.style.backgroundColor = buttonBgColor;
      
      menuButtons.forEach((btn) => {
        if (btn.tagName.toLowerCase() === 'button' && !btn.disabled) {
            btn.style.backgroundColor = "transparent";
        }
      });

      setButtonProcessing(true);
      mainButton.innerHTML = '<div class="loader"></div>';
      closeAllMenus();

      try {
        await executeShuffleAndPlay(getCurrentUri());
      } catch (error) {
        console.error("Error during shuffle and play:", error);
        showNotification(error.message, true);
      } finally {
        resetButtons();
      }
    });

    return innerButton;
  }

  const buttonStyles = {
    main: {
      backgroundColor: "transparent",
      color: "#FFFFFFB3",
      clickBackgroundColor: "transparent",
      disabledBackgroundColor: "rgba(255, 255, 255, 0.25)",
      disabledColor: "rgba(255, 255, 255, 0.8)",
    },
    menuItems: [
      {
        type: "parent",
        text: "Sort By",
        sortType: "sortByParent", 
        children: [
          { backgroundColor: "transparent", color: "white", text: "Play Count", sortType: "playCount", hasInnerButton: true },
          { backgroundColor: "transparent", color: "white", text: "Popularity", sortType: "popularity", hasInnerButton: true },
          { backgroundColor: "transparent", color: "white", text: "Release Date", sortType: "releaseDate", hasInnerButton: true },
          { backgroundColor: "transparent", color: "white", text: "Scrobbles", sortType: "scrobbles", hasInnerButton: true },
          { backgroundColor: "transparent", color: "white", text: "My Scrobbles", sortType: "personalScrobbles", hasInnerButton: true },
          { backgroundColor: "transparent", color: "white", text: "Last Scrobbled", sortType: "lastScrobbled", hasInnerButton: true },
          { backgroundColor: "transparent", color: "white", text: "Liked Status", sortType: "sortByLiked", hasInnerButton: true },
          { backgroundColor: "transparent", color: "white", text: "Energy Wave", sortType: "energyWave", hasInnerButton: true },
          { backgroundColor: "transparent", color: "white", text: "Album Color", sortType: "averageColor", hasInnerButton: true },
          {
            type: "parent",
            text: "Audio Features",
            sortType: "audioFeaturesParent",
            children: [
              { backgroundColor: "transparent", color: "white", text: "Tempo (BPM)", sortType: "tempo", hasInnerButton: true },
              { backgroundColor: "transparent", color: "white", text: "Energy", sortType: "energy", hasInnerButton: true },
              { backgroundColor: "transparent", color: "white", text: "Danceability", sortType: "danceability", hasInnerButton: true },
              { backgroundColor: "transparent", color: "white", text: "Valence", sortType: "valence", hasInnerButton: true },
              { backgroundColor: "transparent", color: "white", text: "Acousticness", sortType: "acousticness", hasInnerButton: true },
              { backgroundColor: "transparent", color: "white", text: "Instrumentalness", sortType: "instrumentalness", hasInnerButton: true },
            ],
          },
        ],
      },
      {
        type: "parent",
        text: "Quick Filters",
        sortType: "quickFiltersParent",
        children: [
             { backgroundColor: "transparent", color: "white", text: "Remove Duplicates", sortType: "deduplicateOnly" },
             {
                type: "divider",
             },
             { backgroundColor: "transparent", color: "white", text: "Remove Liked", sortType: "filterLiked" },
             { backgroundColor: "transparent", color: "white", text: "Liked Only", sortType: "keepLiked" },
             {
                type: "divider",
             },
             { backgroundColor: "transparent", color: "white", text: "Singles Only", sortType: "filterSingles" },
             { backgroundColor: "transparent", color: "white", text: "Albums Only", sortType: "filterAlbums", hasInnerButton: true },
        ]
      },
      {
        backgroundColor: "transparent",
        color: "white",
        text: "Shuffle",
        sortType: "shuffle",
        hasInnerPlayButton: true,
      },
      {
        backgroundColor: "transparent",
        color: "white",
        text: "Convert to Spotify",
        sortType: "convertToSpotify",
      },
      {
        type: "divider",
      },
      {
        backgroundColor: "transparent",
        color: "white",
        text: "Create Playlist",
        sortType: "createNewPlaylist",
        onClick: (event) => {
          event.stopPropagation();
          menuButtons.forEach((btn) => {
            if (btn.tagName.toLowerCase() === 'button' && !btn.disabled) {
                btn.style.backgroundColor = "transparent";
            }
          });
          closeAllMenus();
          showCreatePlaylistModal();
        },
      },
      {
        backgroundColor: "transparent",
        color: "white",
        text: "Genre Filter",
        sortType: "genreFilter",
      },
      {
        backgroundColor: "transparent",
        color: "white",
        text: "Custom Filter",
        sortType: "customFilter",
      },
      {
        backgroundColor: "transparent",
        color: "white",
        text: "AI Pick",
        sortType: "aiPick",
        onClick: async function (event) {
          event.stopPropagation();
          const userApiKey = localStorage.getItem("sort-play-gemini-api-key");
          if (!userApiKey || Ge_mini_Key_Pool.includes(userApiKey)) {  
            showDefaultApiKeyWarning();
          } else {
            menuButtons.forEach((btn) => {
              if (btn.tagName.toLowerCase() === 'button' && !btn.disabled) {
                btn.style.backgroundColor = "transparent";
              }
            });
            await handleSortAndCreatePlaylist("aiPick");
          }
        },
      },
      {
        backgroundColor: "transparent",
        color: "white",
        text: "Dynamic Playlists",
        sortType: "dynamicPlaylists",
        onClick: (event) => {
          event.stopPropagation();
          menuButtons.forEach((btn) => {
            if (btn.tagName.toLowerCase() === 'button' && !btn.disabled) {
                btn.style.backgroundColor = "transparent";
            }
          });
          closeAllMenus();
          showDynamicPlaylistsWindow();
        },
      },
      {
        type: "divider",
      },
      {
        backgroundColor: "transparent",
        color: "white",
        text: "Settings",
        isSetting: true, 
      },
    ],
  };

  const buttonContainer = document.createElement("div");
  buttonContainer.style.position = "relative";
  buttonContainer.style.display = "inline-block";
  buttonContainer.style.width = "100px";
  const mainButton = document.createElement("button");
  mainButton.title = "sort-play extension";
  mainButton.className = "Button-sc-qlcn5g-0 Button-small-buttonTertiary-useBrowserDefaultFocusStyle";
  mainButton.innerText = "Sort Play"; 
  mainButton.style.backgroundColor = buttonStyles.main.backgroundColor;
  mainButton.style.color = 'var(--sort-play-text-color)';
  mainButton.style.borderRadius = "16px";
  mainButton.style.border = "none";
  mainButton.style.padding = "4px 10px";
  mainButton.style.fontWeight = "400";
  mainButton.style.fontSize = "14px";
  mainButton.style.height = "30px";  
  mainButton.style.overflow = "hidden";
  mainButton.style.width = "auto";
  mainButton.style.minWidth = "100px";
  mainButton.style.display = "flex";
  mainButton.style.justifyContent = "center";
  mainButton.style.alignItems = "center";
  mainButton.style.transition = "min-width 0.2s ease, background-color 0.1s ease, color 0.1s ease";

  const threeDotsSvg = `
    <svg width="15px" height="15px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
      <path d="M9.5 14a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
    </svg>`;

  const svgElement = new DOMParser().parseFromString(threeDotsSvg, "image/svg+xml").documentElement;
  svgElement.style.position = "relative";
  svgElement.style.marginLeft = "-2px";
  svgElement.style.bottom = "1px";
  mainButton.appendChild(svgElement);

  const originalFontSize = "14px";
  const originalLineHeight = "normal";
  mainButton.style.lineHeight = originalLineHeight;

  const buttonTextObserver = new MutationObserver(() => {
      if (isAdjustingStyle) return;
      isAdjustingStyle = true;

      if (mainButton.querySelector('.loader')) {
          mainButton.style.fontSize = originalFontSize;
          mainButton.style.lineHeight = originalLineHeight;
          requestAnimationFrame(() => { isAdjustingStyle = false; });
          return;
      }

      mainButton.style.fontSize = originalFontSize;
      mainButton.style.lineHeight = originalLineHeight;

      requestAnimationFrame(() => {
          if (mainButton.scrollHeight > mainButton.clientHeight) {
              mainButton.style.fontSize = "13px";
              mainButton.style.lineHeight = "1.0";
          }

          isAdjustingStyle = false;
      });
  });

  buttonTextObserver.observe(mainButton, {
      childList: true,
      characterData: true,
      subtree: true
  });

  mainButton.addEventListener("mouseenter", () => {
    mainButton.style.cursor = "pointer";
    if (!isProcessing) { 
      mainButton.style.filter = "brightness(1.5)";
    }
  });
  
  mainButton.addEventListener("mouseleave", () => {
    mainButton.style.cursor = "pointer"; 
    if (!isProcessing) {  
      if (!isButtonClicked) {
        mainButton.style.filter = "brightness(1)";
      }
    }
  });


  function getNativeMenuTextColor() {
    const primaryClass = 'niXChlbt7kxslMUdfwu9';
    const fallbackClass = 'main-contextMenu-menuItemButton';
    let tempContainer = null;

    try {
      tempContainer = document.createElement('div');
      tempContainer.className = 'main-contextMenu-menu';
      tempContainer.style.cssText = 'position: absolute; top: -9999px; left: -9999px; visibility: hidden;';
      
      const tempButton = document.createElement('button');
      tempButton.className = 'main-contextMenu-menuItemButton';
      tempContainer.appendChild(tempButton);
      document.body.appendChild(tempContainer);

      const tempSpan = document.createElement('span');
      tempSpan.className = "e-91000-text encore-text-body-small ellipsis-one-line m1hZc7vcFunpAF8jgPq6";
      tempSpan.innerText = "Add to queue";
      tempButton.appendChild(tempSpan);

      let textColor = window.getComputedStyle(tempSpan).color;
      tempButton.removeChild(tempSpan);

      if (textColor && textColor !== 'rgba(0, 0, 0, 0)' && textColor !== 'transparent') {
        return textColor;
      }

      tempButton.className = primaryClass;
      textColor = window.getComputedStyle(tempButton).color;

      if (textColor && textColor !== 'rgba(0, 0, 0, 0)' && textColor !== 'transparent') {
        return textColor;
      }

      tempButton.className = fallbackClass;
      textColor = window.getComputedStyle(tempButton).color;

      if (textColor && textColor !== 'rgba(0, 0, 0, 0)' && textColor !== 'transparent') {
        return textColor;
      }

      return '#b3b3b3'; 

    } catch (error) {
      console.warn("Sort-Play: Error detecting native menu text color.", error);
      return '#b3b3b3';
    } finally {
      if (tempContainer) {
        document.body.removeChild(tempContainer);
      }
    }
  }

  
  function getNativeTertiaryButtonColor() {
    const targetClass = 'Button-sc-qlcn5g-0 Button-buttonTertiary-large-iconOnly-useBrowserDefaultFocusStyle-condensed';
    const tempButton = document.createElement('button');
    tempButton.className = targetClass;
    tempButton.style.cssText = 'position: absolute; top: -9999px; left: -9999px; visibility: hidden;';
    document.body.appendChild(tempButton);
    const textColor = window.getComputedStyle(tempButton).color;
    document.body.removeChild(tempButton);
    return textColor;
  }


  const menuContainer = document.createElement("div");
  menuContainer.style.position = "fixed";
  menuContainer.style.display = "none";
  menuContainer.style.flexDirection = "column";
  menuContainer.style.zIndex = "1";
  menuContainer.style.padding = "4px 4px";
  menuContainer.style.transform = "translateX(-50%)";
  menuContainer.style.borderRadius = "4px";
  menuContainer.style.boxShadow = "0 16px 24px rgba(var(--spice-rgb-shadow), .3), 0 6px 8px rgba(var(--spice-rgb-shadow), .2)";
  menuContainer.style.backgroundColor = getNativeMenuBackgroundColor();
  menuContainer.style.backdropFilter = "blur(8px)";
  menuContainer.classList.add('main-contextMenu-menu');
  menuContainer.classList.add('sort-play-font-scope');
  
  const menuButtons = buttonStyles.menuItems.map((style) => {
    if (style.type === "divider") {
      const divider = document.createElement("hr");
      divider.style.cssText = `
        width: 100%;
        border: none;
        height: 1px;
        background-color: rgba(255, 255, 255, 0.1);
        margin: 0 auto;
      `;
      return divider;
    }

    if (style.type === "parent") {
      const parentButton = document.createElement("button");
      parentButton.style.backgroundColor = "transparent";
      parentButton.style.color = '#ffffffe6';
      parentButton.style.border = "none";
      parentButton.style.borderRadius = "2px";
      parentButton.style.margin = "0";
      parentButton.style.padding = "4px 10px 4px 8px";
      parentButton.style.fontWeight = "400";
      parentButton.style.fontSize = "0.875rem";
      parentButton.style.height = "39px";
      parentButton.style.width = "auto";
      parentButton.style.minWidth = "183px";
      parentButton.style.whiteSpace = "nowrap";
      parentButton.style.textAlign = "center";
      parentButton.style.opacity = "0";
      parentButton.style.transform = "translateY(-10px)";
      parentButton.style.position = "relative";
      parentButton.style.display = "flex";
      parentButton.style.alignItems = "center";
      parentButton.style.justifyContent = "space-between";
      parentButton.dataset.isParent = 'true';
      parentButton.dataset.sortType = style.sortType;

      const leftContainer = document.createElement("div");
      leftContainer.style.display = "flex";
      leftContainer.style.alignItems = "center";
      leftContainer.style.gap = "10px";

      let iconSvgString;
      if (style.text === "Quick Filters") {
        iconSvgString = quickFiltersIconSvg;
      } else {
        iconSvgString = sortIconSvg;
      }
      const icon = new DOMParser().parseFromString(iconSvgString, "image/svg+xml").documentElement;
      leftContainer.appendChild(icon);

      const buttonTextSpan = document.createElement("span");
      buttonTextSpan.innerText = style.text;
      leftContainer.appendChild(buttonTextSpan);
      parentButton.appendChild(leftContainer);
     
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", "0 0 16 16");
      svg.setAttribute("width", "16px");
      svg.setAttribute("height", "16px");
      svg.style.fill = 'var(--sort-play-icon-color)';
      svg.style.transform = "translateX(2px)";
    
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", "M6 14l6-6-6-6v12z");
      
      svg.appendChild(path);
      parentButton.appendChild(svg);
      
      parentButton.addEventListener("mouseenter", () => {
        if (!parentButton.disabled) {
          if (activeSubMenuParent && activeSubMenuParent !== parentButton) {
            activeSubMenuParent.style.backgroundColor = "transparent";
          }
          parentButton.style.backgroundColor = "rgba(var(--spice-rgb-selected-row), 0.1)";
          activeSubMenuParent = parentButton;
          showSubMenu(parentButton);
        }
      });
      
      parentButton.addEventListener("click", (event) => {
        event.preventDefault();
        event.stopPropagation();
        return false;
      });

      return parentButton;
    } else {
      const button = document.createElement("button");
      button.style.backgroundColor = "transparent";
      button.style.color = '#ffffffe6';
      button.style.border = "none";
      button.style.borderRadius = "2px";
      button.style.margin = "0"; 
      button.style.padding = "4px 10px 4px 8px";
      button.style.fontWeight = "400";
      button.style.fontSize = "0.875rem";
      button.style.height = "39px";
      button.style.width = "auto";
      button.style.minWidth = "183px";
      button.style.whiteSpace = "nowrap";
      button.style.textAlign = "left";
      button.style.opacity = "0";
      button.style.transform = "translateY(-10px)";
      button.style.position = "relative"; 
      button.style.display = "flex";  
      button.style.alignItems = "center";  
      button.style.justifyContent = "flex-start";
      button.style.gap = "10px";

      button.addEventListener("mouseenter", () => {
        button.style.backgroundColor = "rgba(var(--spice-rgb-selected-row), 0.1)";
        if (activeSubMenuParent) {
          activeSubMenuParent.style.backgroundColor = "transparent";
          activeSubMenuParent = null;
        }
        hideAllSubMenus();
      });
    
      button.addEventListener("mouseleave", () => {
        if (!button.disabled) {
          button.style.backgroundColor = "transparent";
        }
      });
      
      let iconSvgString;
      if (style.text === "Create Playlist") {
        iconSvgString = createPlaylistIconSvg;
      } else if (style.text === "Dynamic Playlists") {
        iconSvgString = dynamicPlaylistIconSvg;
      } else if (style.text === "Genre Filter") {
        iconSvgString = genreFilterIconSvg;
      } else if (style.text === "Custom Filter") {
        iconSvgString = customFilterIconSvg;
      } else if (style.text === "AI Pick") {
        iconSvgString = aiPickIconSvg;
      } else if (style.text === "Shuffle") {
        iconSvgString = shuffleIconSvg;
      } else if (style.text === "Convert to Spotify") {
        iconSvgString = convertToSpotifyIconSvg;
      } else if (style.isSetting) {
        iconSvgString = settingsIconSvg;
      } else {
        iconSvgString = sortIconSvg;
      }
      const icon = new DOMParser().parseFromString(iconSvgString, "image/svg+xml").documentElement;
      button.appendChild(icon);

      const buttonTextSpan = document.createElement("span");
      buttonTextSpan.innerText = style.text;
      button.appendChild(buttonTextSpan);

      if (style.isSetting) {
        button.addEventListener("click", () => {
          button.style.backgroundColor = "transparent";
        });
      }
      return button;
    }
  });

  menuButtons.forEach(button => menuContainer.appendChild(button));

  function toggleMenu() {
    isMenuOpen = !isMenuOpen;
    if (isMenuOpen) {
      if (!areSubMenusCreated) {
        const processMenuItems = (buttons, itemConfigs) => {
            buttons.forEach(button => {
                const sortType = button.dataset.sortType;
                if (sortType) {
                    const style = itemConfigs.find(item => item.sortType === sortType);
                    if (style && style.type === 'parent' && style.children) {
                        const width = style.sortType === 'quickFiltersParent' ? '170px' : '155px';
                        const subMenu = createSubMenu(style.children, width);
                        document.body.appendChild(subMenu);
                        button._submenu = subMenu;
                        
                        const subMenuParentButtons = Array.from(subMenu.querySelectorAll('button[data-is-parent]'));
                        processMenuItems(subMenuParentButtons, style.children);
                    }
                }
            });
        };
        processMenuItems(menuButtons, buttonStyles.menuItems);
        areSubMenusCreated = true;
      }

      menuContainer.style.backgroundColor = getNativeMenuBackgroundColor();

      const isLocalPage = isLocalFilesPage(getCurrentUri());

      menuButtons.forEach((button, index) => {
          const style = buttonStyles.menuItems[index];
          let shouldShow;

          if (isLocalPage) {
              shouldShow = true;
          } else {
              shouldShow = style.sortType !== 'convertToSpotify';
          }

          button.style.display = shouldShow ? (style.type === 'divider' ? 'block' : 'flex') : 'none';

          if (style.type === 'parent' && button._submenu) {
              const subMenuItems = Array.from(button._submenu.children);
              const subItemConfigs = style.children;

              subMenuItems.forEach((subItem, subIndex) => {
                  const subStyle = subItemConfigs[subIndex];
                  let shouldShowSub = true;
                  
                  subItem.style.display = shouldShowSub ? (subStyle && subStyle.type === 'divider' ? 'block' : 'flex') : 'none';
              });
          }
      });

      applyCurrentThemeColors();
      const buttonRect = mainButton.getBoundingClientRect();
      const { bottom: headerBottom } = getHeaderInfo();

      if (buttonRect.bottom <= headerBottom) {
        isMenuOpen = false;
        return;
      }
      
      menuContainer.style.top = '0px';
      menuContainer.style.left = '0px';
      menuContainer.style.transform = 'none';
      menuContainer.style.display = 'flex';
      document.body.appendChild(menuContainer);

      checkAndUpdateMenuPosition();
      
      menuButtons.forEach((button) => {
        button.style.opacity = "1";
        button.style.transform = "translateY(0)";
      });
    } else {
      closeAllMenus();
    }
  }

  function closeAllMenus() {
    isMenuOpen = false;
    menuContainer.style.display = "none";
    if (menuContainer.parentElement === document.body) {
      document.body.removeChild(menuContainer);
    }
    
    if (activeSubMenuParent) {
      activeSubMenuParent.style.backgroundColor = "transparent";
      activeSubMenuParent = null;
    }
    hideAllSubMenus();
    
    isButtonClicked = false;
    mainButton.style.filter = "brightness(1)";
  }
  
  function hideAllSubMenus() {
    document.querySelectorAll('.submenu').forEach(sm => {
      sm.style.display = 'none';
      if (sm._activeSubMenuParent) {
        sm._activeSubMenuParent.style.backgroundColor = 'transparent';
        sm._activeSubMenuParent = null;
      }
    });
  }

  function createSubMenu(items, width = "155px") {
    const subMenu = document.createElement("div");
    subMenu.classList.add("submenu", "main-contextMenu-menu", "sort-play-font-scope");
    const bgColor = getNativeMenuBackgroundColor();
    subMenu.style.cssText = `
      position: fixed;
      display: none;
      flex-direction: column;
      z-index: 2000;
      padding: 4px;
      border-radius: 4px;
      box-shadow: 0 16px 24px rgba(var(--spice-rgb-shadow), .3), 0 6px 8px rgba(var(--spice-rgb-shadow), .2);
      background-color: ${bgColor};
      backdrop-filter: blur(8px);
    `;

    subMenu._activeSubMenuParent = null;

    items.forEach((item) => {
      if (item.type === "divider") {
        const divider = document.createElement("hr");
        divider.style.cssText = `
          width: 100%;
          border: none;
          height: 1px;
          background-color: rgba(255, 255, 255, 0.1);
          margin: 0 auto;
        `;
        subMenu.appendChild(divider);
        return;
      }

      if (item.type === "title") {
        const titleElement = document.createElement("div");
        titleElement.innerText = item.text;
        titleElement.style.cssText = `
          color: #878787;
          font-size: 0.600rem;
          font-weight: 700;
          letter-spacing: .08em;
          line-height: 16px;
          text-transform: uppercase;
          padding: 8px 12px 4px;
          pointer-events: none;
          margin-left: -2px;
        `;
        subMenu.appendChild(titleElement);
        return;
      }

      if (item.type === "parent") {
        const parentButton = document.createElement("button");
        parentButton.style.cssText = `
          background-color: transparent;
          color: #ffffffe6;
          border: none;
          border-radius: 2px;
          margin: 0;
          padding: 4px 10px 4px 9px;
          font-weight: 400;
          font-size: 0.875rem;
          height: 39px;
          width: auto;
          min-width: ${width};
          white-space: nowrap;
          text-align: left;
          position: relative;
          display: flex;
          align-items: center;
          justify-content: space-between;
        `;
        parentButton.dataset.isParent = 'true';
        parentButton.dataset.sortType = item.sortType;

        const buttonTextSpan = document.createElement("span");
        buttonTextSpan.innerText = item.text;
        parentButton.appendChild(buttonTextSpan);
       
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("viewBox", "0 0 16 16");
        svg.setAttribute("width", "16px");
        svg.setAttribute("height", "16px");
        svg.style.fill = 'var(--sort-play-icon-color)';
        svg.style.transform = "translateX(2px)";
      
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", "M6 14l6-6-6-6v12z");
        
        svg.appendChild(path);
        parentButton.appendChild(svg);

        parentButton.addEventListener("mouseenter", () => {
          if (!parentButton.disabled) {
            if (subMenu._activeSubMenuParent && subMenu._activeSubMenuParent !== parentButton) {
              subMenu._activeSubMenuParent.style.backgroundColor = "transparent";
            }
            parentButton.style.backgroundColor = "rgba(var(--spice-rgb-selected-row), 0.1)";
            subMenu._activeSubMenuParent = parentButton;
            showSubMenu(parentButton);
          }
        });
        
        parentButton.addEventListener("click", (event) => {
          event.preventDefault();
          event.stopPropagation();
          return false;
        });

        subMenu.appendChild(parentButton);
        return;
      }

      const button = document.createElement("button");
      button.style.backgroundColor = item.backgroundColor;
      button.style.color = '#ffffffe6';
      button.style.border = "none";
      button.style.borderRadius = "2px";
      button.style.margin = "0";
      button.style.padding = "4px 10px";
      button.style.fontWeight = "400";
      button.style.fontSize = "0.875rem";
      button.style.height = "37px";
      button.style.width = "auto";
      button.style.minWidth = width;
      button.style.whiteSpace = "nowrap";
      button.style.textAlign = "center";
      button.style.position = "relative";
      button.style.display = "flex";
      button.style.alignItems = "center";
      button.style.justifyContent = "space-between";
      button.innerText = item.text;

      button.addEventListener("mouseenter", () => {
        if (!button.disabled) {
          button.style.backgroundColor = "rgba(var(--spice-rgb-selected-row), 0.1)";
          if (subMenu._activeSubMenuParent) {
            subMenu._activeSubMenuParent.style.backgroundColor = "transparent";
            if (subMenu._activeSubMenuParent._submenu) {
              subMenu._activeSubMenuParent._submenu.style.display = 'none';
            }
            subMenu._activeSubMenuParent = null;
          }
        }
      });
  
      button.addEventListener("mouseleave", () => {
        button.style.backgroundColor = item.backgroundColor;
      });
  
      if (item.hasInnerButton) {
        const svg = item.sortType === 'filterAlbums' 
            ? getGroupingIconSvg(sortOrderState[item.sortType]) 
            : getSortArrowSvg(sortOrderState[item.sortType]);
            
        const innerButton = createInnerButton(item.sortType, button, svg); 
        button.appendChild(innerButton);
      }
  
      button.addEventListener("click", async (event) => {
        event.stopPropagation();
        if (item.onClick) {
          await item.onClick(event);
        } else {
          await handleSortAndCreatePlaylist(item.sortType);
        }
        closeAllMenus();
      });
  
      subMenu.appendChild(button);
    });

    return subMenu;
  }

  function showSubMenu(parentButton) {
    const parentMenu = parentButton.parentElement;
    if (parentMenu) {
        parentMenu.querySelectorAll('button[data-is-parent]').forEach(siblingParent => {
            if (siblingParent !== parentButton && siblingParent._submenu) {
                siblingParent._submenu.style.display = 'none';
                siblingParent.style.backgroundColor = "transparent";
            }
        });
    }

    const subMenu = parentButton._submenu;
    if (!subMenu) return;

    subMenu.style.visibility = 'hidden';
    subMenu.style.display = 'flex';
    const subMenuHeight = subMenu.offsetHeight;
    const subMenuWidth = subMenu.offsetWidth;
    
    const parentRect = parentButton.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;
    const margin = 8;

    let finalTop;
    let finalLeft;

    const spaceRight = viewportWidth - parentRect.right;
    const spaceLeft = parentRect.left;

    if (spaceRight >= subMenuWidth + margin) {
        finalLeft = parentRect.right;
    } else if (spaceLeft >= subMenuWidth + margin) {
        finalLeft = parentRect.left - subMenuWidth;
    } else {
        finalLeft = (spaceRight > spaceLeft) 
            ? viewportWidth - subMenuWidth - margin 
            : margin;
    }
    const topAlignedTop = parentRect.top;
    if ((topAlignedTop + subMenuHeight) <= (viewportHeight - margin)) {
        finalTop = topAlignedTop;
    } 

    else {
        const centerAlignedTop = parentRect.top + (parentRect.height / 2) - (subMenuHeight / 2);
        if (centerAlignedTop >= margin && (centerAlignedTop + subMenuHeight) <= (viewportHeight - margin)) {
            finalTop = centerAlignedTop;
        } 
        else {
            finalTop = parentRect.bottom - subMenuHeight;
        }
    }

    finalTop = Math.max(margin, Math.min(finalTop, viewportHeight - subMenuHeight - margin));

    subMenu.style.left = `${finalLeft}px`;
    subMenu.style.top = `${finalTop}px`;
    subMenu.style.visibility = 'visible';
  }
  
  window.addEventListener('resize', closeAllMenus);

  window.addEventListener('scroll', closeAllMenus);

  let setButtonProcessing = (processing) => {
    isProcessing = processing;
    mainButton.style.cursor = "pointer"; 
    
    if (processing) {
      mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
      mainButton.style.color = buttonStyles.main.disabledColor;
      svgElement.style.fill = buttonStyles.main.disabledColor;
    } else {
      mainButton.style.backgroundColor = buttonStyles.main.backgroundColor;
      mainButton.style.color = buttonStyles.main.color;
      svgElement.style.fill = buttonStyles.main.color;
    }
  };
  
  const container = document.createElement("div");
  document.body.appendChild(container);

  mainButton.addEventListener("click", async (event) => {
    event.stopPropagation();
    if (isProcessing) {
      const confirmed = await showConfirmationModal({
        title: "Stop and Reload Spotify?",
        description: "This will stop the current Sort-Play operation and reload Spotify. Unsaved changes may be lost.",
        confirmText: "Confirm",
        cancelText: "Cancel",
      });

      if (confirmed === 'confirm') {
        closeAllMenus();
        mainButton.style.backgroundColor = buttonStyles.main.backgroundColor;
        mainButton.innerText = "Stopping...";
        setButtonProcessing(false);
        location.reload();
      }
      return;
    }
  
    isButtonClicked = !isMenuOpen; 
    
    if (!isMenuOpen) {
      toggleMenu();
    } else {
      closeAllMenus();
    }
  });
  
  document.addEventListener("click", (event) => {
    if (isMenuOpen && !mainButton.contains(event.target) && !menuContainer.contains(event.target)) {
      closeAllMenus(); 
    }
  });

  function getHeaderInfo() {
    const header = document.querySelector('[data-testid="topbar"]');
    if (!header) return { height: 0, bottom: 0 };
    const headerRect = header.getBoundingClientRect();
    return {
        height: headerRect.height,
        bottom: headerRect.bottom
    };
  }

  function checkAndUpdateMenuPosition() {
    if (!isMenuOpen) return;

    const buttonRect = mainButton.getBoundingClientRect();
    const { bottom: headerBottom } = getHeaderInfo();
    const menuHeight = menuContainer.offsetHeight;
    const menuWidth = menuContainer.offsetWidth;

    if (buttonRect.bottom <= headerBottom) {
        closeAllMenus();
        return;
    }

    const spaceBelow = window.innerHeight - buttonRect.bottom;
    const usableSpaceAbove = buttonRect.top - headerBottom;
    
    let topPosition;
    let leftPosition;

    if (spaceBelow >= menuHeight + 8) {
        topPosition = buttonRect.bottom + 8;
        leftPosition = buttonRect.right - menuWidth;
    } 
    else if (usableSpaceAbove >= menuHeight + 8) {
        topPosition = buttonRect.top - menuHeight - 8;
        leftPosition = buttonRect.right - menuWidth;
    } 
    else {
        topPosition = Math.max(headerBottom + 8, (window.innerHeight - menuHeight) / 2);
        leftPosition = Math.max(8, buttonRect.left - menuWidth - 8);
        
        if (leftPosition + menuWidth < 20 || topPosition + menuHeight > window.innerHeight) {
            closeAllMenus();
            return;
        }
    }

    menuContainer.style.top = `${topPosition}px`;
    menuContainer.style.left = `${leftPosition}px`;
    menuContainer.style.transform = "none";
  }

  window.addEventListener("scroll", checkAndUpdateMenuPosition, true);
  window.addEventListener("resize", checkAndUpdateMenuPosition);
  const menuPositionObserver = new MutationObserver(checkAndUpdateMenuPosition);
  menuPositionObserver.observe(document.body, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeFilter: ['style', 'class']
  });

  async function processBatchesWithDelay(
    tracks,
    batchSize = 200,
    delayMs = 1000,
    updateProgress = () => {},
    processTrack,
    totalProgressSteps = 1  
  ) {
    const results = [];
    const batches = [];
    let processedTrackCount = 0;
    for (let i = 0; i < tracks.length; i += batchSize) {
      batches.push(tracks.slice(i, i + batchSize));
    }
    for (let i = 0; i < batches.length; i++) {
      const batchResults = await Promise.all(batches[i].map(track => processTrack(track)));
  
      batchResults.forEach(result => {
        if (result !== null) {
          results.push(result);
          processedTrackCount++;
        }
      });
      const intermediateProgress = Math.round(
        ((processedTrackCount / tracks.length) * 100) / totalProgressSteps
      );
      updateProgress(intermediateProgress);
      if (i < batches.length - 1) {
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    }
  
    return results;
  }

  async function replacePlaylistTracks(playlistId, trackUris, maxRetries = 10, initialDelay = 2000) {
    const validUris = trackUris.filter(uri => typeof uri === 'string' && (uri.startsWith("spotify:track:") || Spicetify.URI.isLocal(uri)));
    const hasLocalTracks = validUris.some(uri => Spicetify.URI.isLocal(uri));
    const playlistUri = `spotify:playlist:${playlistId}`;

    const replaceInternal = async (uris) => {
        const content = await Spicetify.Platform.PlaylistAPI.getContents(playlistUri);
        if (content.items.length > 0) {
            const toRemove = content.items.map(i => ({ uri: i.uri, uid: i.uid }));
            for (let i = 0; i < toRemove.length; i += 100) {
                await Spicetify.Platform.PlaylistAPI.remove(playlistUri, toRemove.slice(i, i + 100));
            }
        }
        await addTracksToPlaylist(playlistId, uris, maxRetries, initialDelay);
    };

    if (hasLocalTracks || isFallbackActive()) {
        await replaceInternal(validUris);
    } else {
        const BATCH_SIZE = 100;
        const firstBatch = validUris.slice(0, BATCH_SIZE);
        const playlistUrl = `https://api.spotify.com/v1/playlists/${playlistId}/tracks`;
        
        let retries = 0;
        let currentDelay = initialDelay;
        let success = false;

        while (retries <= maxRetries && !success) {
            try {
                await Spicetify.CosmosAsync.put(playlistUrl, { uris: firstBatch });
                success = true;
            } catch (error) {
                if (registerWebApiFailure()) {
                    await replaceInternal(validUris);
                    return;
                }
                console.error(`[Sort-Play] Error replacing tracks in playlist ${playlistId} (Attempt ${retries + 1}):`, error);
                retries++;
                if (retries <= maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, currentDelay));
                    currentDelay *= 2;
                } else {
                    try { await replaceInternal(validUris); return; } catch(e) {}
                    throw new Error(`Failed to replace tracks in playlist ${playlistId}.`);
                }
            }
        }

        if (success && validUris.length > BATCH_SIZE) {
            const remainingUris = validUris.slice(BATCH_SIZE);
            await addTracksToPlaylist(playlistId, remainingUris);
        }
    }
  }

  async function addTracksToPlaylist(playlistId, trackUris, maxRetries = 10, initialDelay = 2000) {
    const playlistUri = `spotify:playlist:${playlistId}`;
    const validUris = trackUris.filter(uri => typeof uri === "string" && (Spicetify.URI.isLocal(uri) || uri.startsWith("spotify:track:")));
    const hasLocalTracks = validUris.some(uri => Spicetify.URI.isLocal(uri));
    const BATCH_SIZE = 100;

    const addInternal = async (uris) => {
        for (let i = uris.length; i > 0; i -= BATCH_SIZE) {
            const start = Math.max(0, i - BATCH_SIZE);
            const batch = uris.slice(start, i);
            await Spicetify.Platform.PlaylistAPI.add(playlistUri, batch, { before: 0 });
        }
    };

    if (hasLocalTracks || isFallbackActive()) {
        for (let i = validUris.length; i > 0; i -= BATCH_SIZE) {
            const start = Math.max(0, i - BATCH_SIZE);
            const batch = validUris.slice(start, i);
            
            let retries = 0;
            let success = false;
            let currentDelay = initialDelay;

            while (!success && retries <= maxRetries) {
                try {
                    await Spicetify.Platform.PlaylistAPI.add(playlistUri, batch, { before: 0 });
                    success = true;
                } catch (error) {
                    console.error(`[Sort-Play] Platform API Error adding batch to start (Attempt ${retries + 1}):`, error);
                    if (retries === maxRetries) {
                        showNotification("Failed to add some tracks.", 'warning');
                        break;
                    }
                    retries++;
                    await new Promise(resolve => setTimeout(resolve, currentDelay));
                    currentDelay *= 2;
                }
            }
        }
    } else {
        const playlistUrl = `https://api.spotify.com/v1/playlists/${playlistId}/tracks`;
        for (let i = 0; i < validUris.length; i += BATCH_SIZE) {
            const batch = validUris.slice(i, i + BATCH_SIZE);
            
            if (isFallbackActive()) {
                try { await addInternal(batch); continue; } catch(e) {}
            }

            let retries = 0;
            let currentDelay = initialDelay;
            let success = false;

            while (retries <= maxRetries) {
                try {
                    await Spicetify.CosmosAsync.post(playlistUrl, { uris: batch });
                    success = true;
                    break;
                } catch (error) {
                    if (registerWebApiFailure()) {
                        try {
                            await addInternal(batch);
                            success = true;
                            break;
                        } catch(e) {}
                    }
                    console.error(`[Sort-Play] CosmosAsync Error adding batch (Attempt ${retries + 1}):`, error);
                    if (retries === maxRetries) {
                        try { await addInternal(batch); success = true; break; } catch(e) {}
                        if(!success) showNotification("Failed to add some Spotify tracks.", 'warning');
                        break;
                    }
                    retries++;
                    await new Promise((resolve) => setTimeout(resolve, currentDelay));
                    currentDelay *= 2;
                }
            }
        }
    }
  }

  async function setPlaylistVisibility(playlist, visibleForAll) {
    await Spicetify.Platform.PlaylistPermissionsAPI.setBasePermission(
        playlist,
        visibleForAll ? "VIEWER" : "BLOCKED"
    );
  }

  async function movePlaylistToTop(playlistUri) {
    const { CosmosAsync } = Spicetify.Platform;
    if (!CosmosAsync) return;

    try {
        let moveRequestBody = {
            operation: "move",
            uris: [playlistUri],
        };

        if (placePlaylistsInFolder) {
            const folderUri = await findOrCreatePlaylistFolder(sortPlayFolderName);
            if (folderUri) {
                moveRequestBody.after = { uri: folderUri };
            } else {
                moveRequestBody.before = "start";
            }
        } else {
            moveRequestBody.before = "start";
        }

        await CosmosAsync.post("sp://core-playlist/v1/rootlist", moveRequestBody);
    } catch (error) {
        console.warn(`Could not move playlist ${playlistUri}.`, error);
    }
  }

  
  async function getActiveUserPlaylistUris() {
    try {
        const rootlist = await Spicetify.Platform.RootlistAPI.getContents();
        const playlistUris = new Set();

        function traverseItems(items) {
            for (const item of items) {
                if (item.type === 'playlist') {
                    playlistUris.add(item.uri);
                } else if (item.type === 'folder' && Array.isArray(item.items)) {
                    traverseItems(item.items);
                }
            }
        }

        traverseItems(rootlist.items);
        return playlistUris;

    } catch (error) {
        console.error("An error occurred while fetching user playlists from RootlistAPI:", error);
        try {
            const response = await Spicetify.CosmosAsync.get('https://api.spotify.com/v1/me/playlists?limit=50');
            return new Set(response.items.map(p => p.uri));
        } catch (fallbackError) {
            console.error("Fallback playlist fetch also failed:", fallbackError);
            return new Set();
        }
    }
  }

  function isDefaultMosaicCover(url) {
    if (!url) return false;
    return url.startsWith("spotify:mosaic:") || url.includes("mosaic.scdn.co");
  }
  
  async function generatePlaylistCover(titleText, subtitleText, userName, baseImageUrl, textColor) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const size = 640;
    canvas.width = size;
    canvas.height = size;

    try {
        const baseImage = new Image();
        baseImage.crossOrigin = 'Anonymous';
        baseImage.src = baseImageUrl;
        await new Promise((resolve, reject) => {
            baseImage.onload = resolve;
            baseImage.onerror = reject;
        });
        ctx.drawImage(baseImage, 0, 0, size, size);
    } catch (error) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, size, size);
    }

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = textColor || '#24bf70';

    let displayName = userName.length > 30 ? userName.substring(0, 30) + '...' : userName;
    let userNameFontSize = 48;
    ctx.font = `bold ${userNameFontSize}px 'SpotifyMixUI', sans-serif`;
    const maxUserNameWidth = size * 0.8;
    while (ctx.measureText(displayName).width > maxUserNameWidth && userNameFontSize > 20) {
        userNameFontSize -= 2;
        ctx.font = `bold ${userNameFontSize}px 'SpotifyMixUI', sans-serif`;
    }
    const userNameY = size * 0.76; 
    ctx.fillText(displayName, size / 2, userNameY);

    const contentCenterY = size * 0.42;
    const titleUpper = titleText.toUpperCase();
    const subUpper = subtitleText ? subtitleText.toUpperCase() : "";
    
    let titleFontSize = 90;
    ctx.font = `800 ${titleFontSize}px 'SpotifyMixUI', sans-serif`;
    while (ctx.measureText(titleUpper).width > (size * 0.90) && titleFontSize > 40) {
        titleFontSize -= 5;
        ctx.font = `800 ${titleFontSize}px 'SpotifyMixUI', sans-serif`;
    }
    
    let titleY = contentCenterY;
    if (subUpper) {
        titleY = contentCenterY - (titleFontSize * 0.20); 
    }
    
    ctx.fillText(titleUpper, size / 2, titleY);

    if (subUpper) {
        let subFontSize = titleFontSize * 0.7; 
        ctx.font = `bold ${subFontSize}px 'SpotifyMixUI', sans-serif`;
        const subY = titleY + (titleFontSize * 0.95); 
        ctx.fillText(subUpper, size / 2, subY);
    }

    return canvas.toDataURL('image/jpeg');
  }

  async function addPlaylistToLibrary(playlistUri) {
    const { CosmosAsync } = Spicetify;
    if (!playlistUri) return;

    try {
        await new Promise(resolve => setTimeout(resolve, 250));

        let moveRequestBody = {
            operation: "move",
            uris: [playlistUri],
        };

        if (placePlaylistsInFolder) {
            const folderUri = await findOrCreatePlaylistFolder(sortPlayFolderName);
            if (folderUri) {
                moveRequestBody.after = { uri: folderUri };
            } else {
                moveRequestBody.before = "start";
            }
        } else {
            moveRequestBody.before = "start";
        }
        
        await CosmosAsync.post("sp://core-playlist/v1/rootlist", moveRequestBody);

    } catch (error) {
    }
  }

  async function executeShuffleAndPlay(uri) {
    if (!uri) {
      throw new Error("No context URI provided for shuffling.");
    }

    let tracks;
    const isArtistPage = URI.isArtist(uri);
    let contextUri = uri; 

    if (URI.isPlaylistV1OrV2(uri)) {
        tracks = await getPlaylistTracks(uri.split(":")[2]);
    } else if (isArtistPage) {
        tracks = await getArtistTracksForShuffle(uri);
    } else if (isLikedSongsPage(uri)) {
        tracks = await getLikedSongs();
        contextUri = null; 
    } else if (isLocalFilesPage(uri)) {
        tracks = await getLocalFilesTracks();
        contextUri = null; 
    } else if (URI.isAlbum(uri)) {
        tracks = await getAlbumTracks(uri.split(":")[2]);
    } else {
        throw new Error('Invalid context for shuffling');
    }

    if (!tracks || tracks.length === 0) {
      throw new Error('No tracks found to shuffle');
    }

    const containsLocalFiles = tracks.some(track => Spicetify.URI.isLocal(track.uri));

    let tracksToProcess;

    if (isArtistPage) {
      const refreshedTracks = await refreshTrackAlbumInfo(tracks);
      const tracksWithPlayCounts = await enrichTracksWithPlayCounts(refreshedTracks);
      const tracksWithIds = await processBatchesWithDelay(tracksWithPlayCounts, 50, 500, () => {}, collectTrackIdsForPopularity);
      const tracksWithPopularity = await fetchPopularityForMultipleTracks(tracksWithIds, () => {});
      const { unique: uniqueTracks } = await deduplicateTracks(
          tracksWithPopularity, 
          false, 
          true,
          (progress) => { mainButton.innerText = `Dedup ${progress}%`; }
      );
      tracksToProcess = uniqueTracks;
    } else {
      tracksToProcess = tracks;
    }

    let finalSortedTracks;
    const fallbackActive = isFallbackActive();

    if (useEnergyWaveShuffle && !containsLocalFiles && !fallbackActive && tracks.length <= energyWaveShuffleLimit) {
        showNotification("Performing Randomized Energy Wave Shuffle...");
        
        const trackIds = tracksToProcess.map(t => t.trackId || t.uri.split(":")[2]);
        const allStats = await getBatchTrackStats(trackIds);
        const tracksWithData = tracksToProcess.map(track => ({
            ...track,
            features: allStats[track.trackId || track.uri.split(":")[2]]
        }));
    
        finalSortedTracks = await randomizedEnergyWaveSort(tracksWithData);
    } else {
        if (useEnergyWaveShuffle) {
            if (fallbackActive) {
                showNotification("Web API unavailable. Reverting to standard shuffle.", 'warning');
            } else if (containsLocalFiles) {
                showNotification("Local files detected. Reverting to standard shuffle.", 'warning');
            } else if (tracks.length > energyWaveShuffleLimit) {
                showNotification(`Playlist too large (>${energyWaveShuffleLimit}). Reverting to standard shuffle.`, 'warning');
            }
        }
        finalSortedTracks = shuffleArray(tracksToProcess);
    }

    await setQueueFromTracks(finalSortedTracks, contextUri, 'shuffle');
  }

  function shouldShowShufflePlayOption(uris) {
    if (uris.length !== 1) {
        return false;
    }
    const uri = Spicetify.URI.fromString(uris[0]);
    switch (uri.type) {
        case Spicetify.URI.Type.PLAYLIST:
        case Spicetify.URI.Type.PLAYLIST_V2:
        case Spicetify.URI.Type.ALBUM:
        case Spicetify.URI.Type.ARTIST:
        case Spicetify.URI.Type.COLLECTION:
            return true;
    }
    return false;
  }

  new Spicetify.ContextMenu.Item(
    "Shuffle with Sort-Play",
    async (uris) => {
        setButtonProcessing(true);
        mainButton.innerHTML = '<div class="loader"></div>';
        closeAllMenus();

        try {
            await executeShuffleAndPlay(uris[0]);
        } catch (error) {
            console.error("Error from context menu shuffle:", error);
            showNotification(error.message, true);
        } finally {
            resetButtons();
        }
    },
    shouldShowShufflePlayOption,
    "shuffle"
  ).register();

  async function convertLocalPlaylistToSpotify() {
    const BATCH_SIZE = 20; 
    const DELAY_BETWEEN_BATCHES = 2000;
    const MAX_RETRIES = 3;
    const RETRY_DELAYS = [1000, 3000, 5000];

    setButtonProcessing(true);
    mainButton.innerHTML = '<div class="loader"></div>';
    closeAllMenus();

    const logData = {
        summary: {},
        foundTracks: [],
        notFoundTracks: [],
        tracksWithMissingData: [],
        retryStats: {
            totalRetries: 0,
            rateLimitHits: 0,
            networkErrors: 0,
        },
    };

    async function retryOperation(operation, context = "", maxRetries = MAX_RETRIES) {
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                const isLastAttempt = attempt === maxRetries;
                const isRateLimit = error.status === 429 || error.message?.includes('429');
                const isNetworkError = !error.status || error.message?.includes('network') || error.message?.includes('fetch');
                
                if (isRateLimit) {
                    logData.retryStats.rateLimitHits++;
                } else if (isNetworkError) {
                    logData.retryStats.networkErrors++;
                }

                if (isLastAttempt) {
                    throw error;
                }

                logData.retryStats.totalRetries++;
                
                let delay = RETRY_DELAYS[attempt] || RETRY_DELAYS[RETRY_DELAYS.length - 1];
                if (isRateLimit && error.headers?.['retry-after']) {
                    delay = parseInt(error.headers['retry-after']) * 1000;
                }

                console.log(`[Sort-Play] Retry ${attempt + 1}/${maxRetries} for ${context} after ${delay}ms. Error:`, error.message);
                
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    let newPlaylist = null;

    try {
        mainButton.innerText = "Reading...";
        const allLocalTracks = await getLocalFilesTracks();
        if (!allLocalTracks || allLocalTracks.length === 0) {
            throw new Error("No local tracks found to convert.");
        }

        const localTracksToSearch = allLocalTracks.filter(track => {
            if (!track.name || !track.artistName) {
                logData.tracksWithMissingData.push({
                    reason: "Missing track name or artist name",
                    track: track,
                });
                return false;
            }
            return true;
        });

        for (let i = 0; i < localTracksToSearch.length; i += BATCH_SIZE) {
            const batch = localTracksToSearch.slice(i, i + BATCH_SIZE);
            mainButton.innerText = `${i}/${localTracksToSearch.length}`;

            const searchPromises = batch.map(async (track, idx) => {
                const artistQuery = track.artistName || "";
                const uniqueArtists = [...new Set(artistQuery.split(/[;,]/).map(a => a.trim()).filter(Boolean))];
                const artistSearchTerm = uniqueArtists.join(' ');
                
                const lenientQuery = `${track.name} ${artistSearchTerm}`;
                const strictQuery = `track:"${track.name}" artist:"${artistSearchTerm}"`;

                try {
                    let result = { tracks: { items: [] } };

                    const getFirstWord = (title) => {
                        if (!title) return "";
                        return title.toLowerCase().replace(/^[^a-z0-9]+/, '').split(/\s+/)[0];
                    };
                    const localFirstWord = getFirstWord(track.name);
                    const localArtistWords = (track.artistName || "").toLowerCase().split(/\s+/).filter(w => w.length > 1);

                    const verifyTrack = (spotifyTrack) => {
                        if (!spotifyTrack || !spotifyTrack.name) return false;
                        if (localFirstWord !== getFirstWord(spotifyTrack.name)) return false;
                        const spotifyArtistString = spotifyTrack.artists.map(a => a.name).join(' ').toLowerCase();
                        return localArtistWords.some(word => spotifyArtistString.includes(word));
                    };

                    const lenientResult = await retryOperation(
                        () => Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(lenientQuery)}&type=track&limit=5`),
                        `track ${i + idx + 1} (lenient)`
                    );

                    let verifiedTrack = null;
                    if (lenientResult.tracks && lenientResult.tracks.items.length > 0) {
                        verifiedTrack = lenientResult.tracks.items.find(verifyTrack);
                    }

                    if (!verifiedTrack) {
                        const strictResult = await retryOperation(
                            () => Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(strictQuery)}&type=track&limit=5`),
                            `track ${i + idx + 1} (strict)`
                        );
                        if (strictResult.tracks && strictResult.tracks.items.length > 0) {
                            verifiedTrack = strictResult.tracks.items.find(verifyTrack);
                        }
                    }

                    if (verifiedTrack) {
                        result = { tracks: { items: [verifiedTrack] } };
                    }
                    
                    return { success: true, result, originalTrack: track };
                } catch (err) {
                    return { success: false, error: err, originalTrack: track };
                }
            });

            const searchResults = await Promise.all(searchPromises);

            searchResults.forEach(res => {
                if (res.success && res.result.tracks && res.result.tracks.items.length > 0) {
                    logData.foundTracks.push({
                        localTrack: res.originalTrack,
                        spotifyTrack: res.result.tracks.items[0],
                    });
                } else {
                    logData.notFoundTracks.push({
                        reason: res.success ? "No items in search result" : `API Error: ${res.error.message}`,
                        track: res.originalTrack,
                    });
                }
            });
            
            if (i + BATCH_SIZE < localTracksToSearch.length) {
                await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_BATCHES));
            }
        }

        logData.summary = {
            totalLocalTracks: allLocalTracks.length,
            tracksWithMissingData: logData.tracksWithMissingData.length,
            tracksSearched: localTracksToSearch.length,
            tracksFound: logData.foundTracks.length,
            tracksNotFound: logData.notFoundTracks.length,
            totalRetries: logData.retryStats.totalRetries,
            rateLimitHits: logData.retryStats.rateLimitHits,
            networkErrors: logData.retryStats.networkErrors,
        };

        if (logData.foundTracks.length > 0) {
            mainButton.innerText = "Creating...";
            newPlaylist = await retryOperation(
                () => createPlaylist(
                    "Local Files (Spotify Version)",
                    `Converted ${logData.foundTracks.length} of ${allLocalTracks.length} local tracks to Spotify tracks. Created by Sort-Play.`
                ),
                "playlist creation"
            );

            mainButton.innerText = "Saving...";
            const trackUris = logData.foundTracks.map(item => item.spotifyTrack.uri);
            await retryOperation(
                () => addTracksToPlaylist(newPlaylist.id, trackUris),
                "adding tracks"
            );
            await retryOperation(
                () => addPlaylistToLibrary(newPlaylist.uri),
                "adding to library"
            );
        } else {
             showNotification("Could not find any matching tracks on Spotify.", 'warning');
        }

    } catch (error) {
        console.error("Error converting local playlist:", error);
        showNotification(error.message, true);
    } finally {
        resetButtons();
        showConversionReportModal(logData, newPlaylist);
    }
  }

  function showConversionReportModal(logData, playlistToNavigate) {
    const overlay = document.createElement("div");
    overlay.id = "sort-play-conversion-report-overlay";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        z-index: 2002;
        display: flex; justify-content: center; align-items: center;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container sort-play-font-scope";
    modalContainer.style.cssText = `
        z-index: 2003;
        width: 1100px !important;
        display: flex;
        flex-direction: column;
        border-radius: 30px;
    `;

    const allProcessedTracks = [];
    logData.notFoundTracks.forEach(item => {
        allProcessedTracks.push({
            status: 'not-found',
            localTrack: item.track,
            reason: item.reason
        });
    });
    logData.tracksWithMissingData.forEach(item => {
        allProcessedTracks.push({
            status: 'missing-data',
            localTrack: item.track,
            reason: item.reason
        });
    });
    logData.foundTracks.forEach(item => {
        allProcessedTracks.push({
            status: 'found',
            localTrack: item.localTrack,
            spotifyTrack: item.spotifyTrack
        });
    });

    const conversionListHTML = allProcessedTracks.map(item => {
        const localTitle = item.localTrack.name || 'N/A';
        const localArtist = item.localTrack.artistName || 'N/A';

        let spotifySideHTML = '';
        let statusClass = `status-${item.status}`;

        switch (item.status) {
            case 'found':
                const spotifyTitle = item.spotifyTrack.name || 'N/A';
                const spotifyArtist = item.spotifyTrack.artists.map(a => a.name).join(', ') || 'N/A';
                spotifySideHTML = `
                    <div class="track-text-wrapper">
                        <span class="track-item-title" title="${spotifyTitle}">${spotifyTitle}</span>
                        <span class="track-item-artist" title="${spotifyArtist}">${spotifyArtist}</span>
                    </div>
                    <button class="copy-track-button" data-title="${spotifyTitle}" data-artist="${spotifyArtist}" title="Copy 'Track - Artist'">
                        ${copyIconSVG}
                    </button>
                `;
                break;
            case 'not-found':
                spotifySideHTML = `<span class="status-text">Not Found</span>`;
                break;
            case 'missing-data':
                spotifySideHTML = `<span class="status-text">Missing Data</span>`;
                break;
        }

        return `
            <div class="conversion-row">
                <div class="track-item local-track">
                    <div class="track-text-wrapper">
                        <span class="track-item-title" title="${localTitle}">${localTitle}</span>
                        <span class="track-item-artist" title="${localArtist}">${localArtist}</span>
                    </div>
                    <button class="copy-track-button" data-title="${localTitle}" data-artist="${localArtist}" title="Copy 'Track - Artist'">
                        ${copyIconSVG}
                    </button>
                </div>
                <div class="arrow-separator">
                    ${arrowRightIconSVG}
                </div>
                <div class="track-item spotify-track ${statusClass}">
                    ${spotifySideHTML}
                </div>
            </div>
        `;
    }).join('');

    modalContainer.innerHTML = `
      <style>
        .report-layout { display: flex; gap: 24px; }
        .report-left-column { flex: 2; display: flex; flex-direction: column; min-width: 0; }
        .report-right-column { flex: 1; }
        .summary-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; background-color: #282828; border-radius: 8px; padding: 16px; }
        .summary-item { text-align: center; }
        .summary-value { font-size: 24px; font-weight: bold; color: white; }
        .summary-label { font-size: 12px; color: #b3b3b3; text-transform: uppercase; margin-top: 4px; }
        .conversion-list-header { display: flex; justify-content: space-between; padding: 0 10px 8px; border-bottom: 1px solid #3e3e3e; margin-bottom: 8px; }
        .column-title { color: white; font-size: 14px; font-weight: 500; flex-basis: 45%; text-align: center; }
        .conversion-list-container { max-height: 400px; overflow-y: auto; background-color: #282828; border-radius: 6px; padding: 8px; scrollbar-width: thin; scrollbar-color: #535353 #282828; }
        .conversion-list-container::-webkit-scrollbar { width: 8px; }
        .conversion-list-container::-webkit-scrollbar-track { background: #282828; }
        .conversion-list-container::-webkit-scrollbar-thumb { background-color: #535353; border-radius: 4px; }
        .conversion-row { display: flex; align-items: center; gap: 8px; }
        .conversion-row:not(:last-child) { margin-bottom: 4px; }
        .track-item { display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-radius: 4px; flex: 1; min-width: 0; }
        .track-item.local-track { border: 1px solid #ffffff24; }
        .track-text-wrapper { flex-grow: 1; overflow: hidden; display: flex; flex-direction: column; }
        .track-item-title { color: #e0e0e0; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .track-item-artist { color: #b3b3b3; font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .arrow-separator { flex-shrink: 0; color: #b3b3b3; }
        .arrow-separator svg { width: 16px; height: 16px; }
        .spotify-track { justify-content: space-between; }
        .status-found { background-color: rgba(30, 215, 96, 0.15); }
        .status-not-found { background-color: rgba(241, 94, 108, 0.15); }
        .status-missing-data { background-color: rgba(232, 160, 57, 0.15); }
        .status-text { color: #e0e0e0; font-size: 14px; font-style: italic; }
        .copy-track-button { background: none; border: none; cursor: pointer; color: #b3b3b3; padding: 4px; display: flex; align-items: center; flex-shrink: 0; }
        .copy-track-button:hover { color: white; }
        .copy-track-button svg { width: 14px; height: 14px; }
        .copy-track-button.copied { color: #1ED760; }
        .main-buttons-button.main-button-primary { background-color: #1ED760; color: black; transition: background-color 0.1s ease;}
        .main-buttons-button.main-button-primary:hover { background-color: #3BE377; }
        .main-buttons-button.main-button-secondary { background-color: #333333; color: white; transition: background-color 0.1s ease; }
        .main-buttons-button.main-button-secondary:hover { background-color: #444444; }
      </style>
      <div class="main-trackCreditsModal-header">
          <h1 class="main-trackCreditsModal-title"><span style='font-size: 25px;'>Conversion Report</span></h1>
      </div>
      <div class="main-trackCreditsModal-mainSection" style="padding: 22px 32px !important; overflow:auto">
        <div class="report-layout">
            <div class="report-left-column">
                <div class="conversion-list-header">
                    <div class="column-title">Original Local Track</div>
                    <div class="column-title">Found Spotify Track</div>
                </div>
                <div class="conversion-list-container">
                    ${conversionListHTML}
                </div>
            </div>
            <div class="report-right-column">
                <div class="summary-grid">
                    <div class="summary-item">
                        <div class="summary-value">${logData.summary.totalLocalTracks || 0}</div>
                        <div class="summary-label">Total Tracks</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-value" style="color: #1ED760;">${logData.summary.tracksFound || 0}</div>
                        <div class="summary-label">Found</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-value" style="color: #f15e6c;">${logData.summary.tracksNotFound || 0}</div>
                        <div class="summary-label">Not Found</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-value" style="color: #e8a039;">${logData.summary.tracksWithMissingData || 0}</div>
                        <div class="summary-label">Missing Data</div>
                    </div>
                </div>
            </div>
        </div>
      </div>
      <div class="main-trackCreditsModal-originalCredits" style="padding: 15px 24px !important; border-top: 1px solid #282828; flex-shrink: 0;">
        <div style="display: flex; justify-content: flex-end; gap: 10px;">
            <button id="exportReportData" class="main-buttons-button main-button-secondary" 
                    style="padding: 8px 24px; border-radius: 20px; font-weight: 550; font-size: 13px; text-transform: uppercase; border: none; cursor: pointer;">
                Export Data
            </button>
            <button id="closeReportModal" class="main-buttons-button main-button-primary" 
                    style="padding: 8px 18px; border-radius: 20px; font-weight: 550; font-size: 13px; text-transform: uppercase; border: none; cursor: pointer;">
                ${playlistToNavigate ? 'Go to Playlist' : 'Done'}
            </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);

    modalContainer.querySelectorAll('.copy-track-button').forEach(button => {
        button.addEventListener('click', () => {
            const title = button.dataset.title || '';
            const artist = button.dataset.artist || '';
            let textToCopy;

            if (title && artist) {
                textToCopy = `${title} - ${artist}`;
            } else if (title) {
                textToCopy = title;
            } else if (artist) {
                textToCopy = artist;
            } else {
                return;
            }

            navigator.clipboard.writeText(textToCopy).then(() => {
                button.classList.add('copied');
                setTimeout(() => button.classList.remove('copied'), 1000);
            });
        });
    });

    modalContainer.querySelector("#exportReportData").addEventListener("click", async () => {
        const exportData = {
            summary: logData.summary,
            results: []
        };

        logData.notFoundTracks.forEach(item => {
            exportData.results.push({
                status: 'not-found',
                local: {
                    title: item.track.name || 'N/A',
                    artist: item.track.artistName || 'N/A'
                },
                reason: item.reason
            });
        });

        logData.tracksWithMissingData.forEach(item => {
            exportData.results.push({
                status: 'missing-data',
                local: {
                    title: item.track.name || 'N/A',
                    artist: item.track.artistName || 'N/A'
                },
                reason: item.reason
            });
        });

        logData.foundTracks.forEach(item => {
            exportData.results.push({
                status: 'found',
                local: {
                    title: item.localTrack.name || 'N/A',
                    artist: item.localTrack.artistName || 'N/A'
                },
                spotify: {
                    title: item.spotifyTrack.name || 'N/A',
                    artist: item.spotifyTrack.artists.map(a => a.name).join(', ') || 'N/A',
                    link: item.spotifyTrack.uri.replace('spotify:track:', 'https://open.spotify.com/track/')
                }
            });
        });

        const jsonString = JSON.stringify(exportData, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });

        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: 'sort-play_conversion_report.json',
                    types: [{
                        description: 'JSON Files',
                        accept: { 'application/json': ['.json'] },
                    }],
                });
                const writable = await handle.createWritable();
                await writable.write(blob);
                await writable.close();
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Error saving file:', err);
                    showNotification("Failed to export data.", true);
                }
            }
        } else {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sort-play_conversion_report.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    });

    const closeModal = () => {
        overlay.remove();
        if (playlistToNavigate) {
            navigateToPlaylist(playlistToNavigate, true);
        }
    };
    
    modalContainer.querySelector("#closeReportModal").addEventListener("click", closeModal);
    overlay.addEventListener("click", (e) => { 
        if (e.target === overlay) {
            e.preventDefault();
            e.stopPropagation();
        }
    });
  }

  async function getOrCreateDedicatedPlaylist(sortType, name, description, maxRetries = 5, initialDelay = 1000) {
    const dedicatedPlaylistBehavior = JSON.parse(localStorage.getItem(STORAGE_KEY_DEDICATED_PLAYLIST_BEHAVIOR) || '{}');
    const behavior = dedicatedPlaylistBehavior[sortType] || 'createOnce';
    const isUpdateEnabled = behavior === 'replace' || behavior === 'autoUpdate';

    let finalPlaylistName = name;
    let coverTitle = name;
    let coverSubtitle = "";

    const textMapping = {
        'topThisMonth': { title: "Top Tracks", sub: "This Month" },
        'topLast6Months': { title: "Top Tracks", sub: "Last 6 Months" },
        'topAllTime': { title: "Top Tracks", sub: "All-Time" },
        'followedReleasesChronological': { title: "New Releases", sub: "Followed", playlistName: "New Releases: Followed" },
        'recommendRecentVibe': { title: "Discovery", sub: "Recent Vibe" },
        'recommendAllTime': { title: "Discovery", sub: "All-Time" },
        'pureDiscovery': { title: "Discovery", sub: "Pure" },
        'genreTreeExplorer': { title: "Genre Explorer", sub: "" },
        'randomGenreExplorer': { title: "Genre Explorer", sub: "Random" },
        'infiniteVibe': { title: "Infinite Vibe", sub: "Last.fm" },
        'neighborsMix': { title: "Neighbors Mix", sub: "Last.fm" }
    };

    if (textMapping[sortType]) {
        coverTitle = textMapping[sortType].title;
        coverSubtitle = textMapping[sortType].sub;
        if (textMapping[sortType].playlistName) {
            finalPlaylistName = textMapping[sortType].playlistName;
        }
    }

    const releasePlaylistColor = '#3798a5';
    const discoveryPlaylistColor = '#8f46d7';
    const lastFmPlaylistColor = '#D1170E';
    const defaultUsernameColor = '#24bf70';

    const releasePlaylistTypes = playlistCardsData
        .find(section => section.title === 'New Releases')?.cards
        .map(card => card.id) || [];

    const discoveryPlaylistTypes = playlistCardsData
        .find(section => section.title === 'Discovery')?.cards
        .map(card => card.id) || [];
    
    const lastFmPlaylistTypes = playlistCardsData
        .find(section => section.title === 'Last.fm')?.cards
        .map(card => card.id) || [];
    
    let usernameColor;
    if (discoveryPlaylistTypes.includes(sortType)) {
        usernameColor = discoveryPlaylistColor;
    } else if (releasePlaylistTypes.includes(sortType)) {
        usernameColor = releasePlaylistColor;
    } else if (lastFmPlaylistTypes.includes(sortType)) {
        usernameColor = lastFmPlaylistColor;
    } else {
        usernameColor = defaultUsernameColor;
    }

    if (isUpdateEnabled) {
        let dedicatedPlaylistMap = JSON.parse(localStorage.getItem(STORAGE_KEY_DEDICATED_PLAYLIST_MAP) || '{}');
        const playlistUri = dedicatedPlaylistMap[sortType];

        if (playlistUri) {
            const activePlaylistsSet = await getActiveUserPlaylistUris();

            if (activePlaylistsSet.has(playlistUri)) {
                const playlistId = playlistUri.split(':')[2];

                try {
                    await Spicetify.CosmosAsync.put(`https://api.spotify.com/v1/playlists/${playlistId}`, {
                        name: finalPlaylistName,
                        description: description
                    });
                } catch (updateError) {
                }

                if (setDedicatedPlaylistCovers) {
                    (async () => {
                        try {
                            const user = await Spicetify.Platform.UserAPI.getUser();
                            const baseImageUrl = DEDICATED_PLAYLIST_COVERS[sortType] || DEDICATED_PLAYLIST_COVERS['default'];
                            const coverBase64 = await generatePlaylistCover(coverTitle, coverSubtitle, user.displayName, baseImageUrl, usernameColor);
                            setPlaylistImage(playlistId, coverBase64);
                        } catch (coverError) {
                            console.error("Failed to update custom playlist cover:", coverError);
                        }
                    })();
                }

                await movePlaylistToTop(playlistUri);

                const minimalPlaylistData = { id: playlistId, uri: playlistUri, name: finalPlaylistName };
                fetch(`${STATS_URL}/increment?key=${sortType}`, { method: 'POST', mode: 'no-cors' }).catch(() => {});
                return { playlist: minimalPlaylistData, wasUpdated: true };

            } else {
                console.log(`[Sort-Play] Linked playlist ${playlistUri} is no longer in the user's library. A new one will be created.`);
                delete dedicatedPlaylistMap[sortType];
                localStorage.setItem(STORAGE_KEY_DEDICATED_PLAYLIST_MAP, JSON.stringify(dedicatedPlaylistMap));
            }
        }
    }

    const newPlaylist = await createPlaylist(finalPlaylistName, description, maxRetries, initialDelay);

    if (newPlaylist) {
        await new Promise(resolve => setTimeout(resolve, 250));

        if (setDedicatedPlaylistCovers) {
            (async () => {
                try {
                    const user = await Spicetify.Platform.UserAPI.getUser();
                    const baseImageUrl = DEDICATED_PLAYLIST_COVERS[sortType] || DEDICATED_PLAYLIST_COVERS['default'];
                    const coverBase64 = await generatePlaylistCover(coverTitle, coverSubtitle, user.displayName, baseImageUrl, usernameColor);
                    setPlaylistImage(newPlaylist.id, coverBase64);
                } catch (coverError) {
                    console.error("Failed to generate or set custom playlist cover:", coverError);
                }
            })();
        }
        
        await addPlaylistToLibrary(newPlaylist.uri);

        if (isUpdateEnabled) {
            let dedicatedPlaylistMap = JSON.parse(localStorage.getItem(STORAGE_KEY_DEDICATED_PLAYLIST_MAP) || '{}');
            dedicatedPlaylistMap[sortType] = newPlaylist.uri;
            localStorage.setItem(STORAGE_KEY_DEDICATED_PLAYLIST_MAP, JSON.stringify(dedicatedPlaylistMap));
        }
        
        fetch(`${STATS_URL}/increment?key=${sortType}`, { method: 'POST', mode: 'no-cors' }).catch(() => {});
    }

    return { playlist: newPlaylist, wasUpdated: false };
  }

  async function createPlaylist(
    name = "Sorted by Play Count",
    description = "Created with Spotify Playlist Sorter",
  ) {
    const { CosmosAsync, Platform } = Spicetify;
    if (!CosmosAsync || !Platform) {
        console.error("Spicetify APIs not available.");
        throw new Error("Spicetify APIs not available.");
    }

    let newPlaylist;
    try {
        const { RootlistAPI } = Platform;
        if (!RootlistAPI) throw new Error("RootlistAPI not available for folder creation.");

        if (placePlaylistsInFolder) {
            const folderUri = await findOrCreatePlaylistFolder(sortPlayFolderName);
            if (folderUri) {
                const uri = await RootlistAPI.createPlaylist(name, { after: { uri: folderUri } });
                newPlaylist = { uri: uri };
            } else {
                showNotification("Failed to find/create folder. Creating playlist at the top.", true);
                const uri = await RootlistAPI.createPlaylist(name, { before: "start" });
                newPlaylist = { uri: uri };
            }
        } else {
            const uri = await RootlistAPI.createPlaylist(name, { before: "start" });
            newPlaylist = { uri: uri };
        }

    } catch (error) {
        console.warn("Internal playlist creation failed, using Web API fallback:", error);
        const user = await Spicetify.Platform.UserAPI.getUser();
        const createPlaylistUrl = `https://api.spotify.com/v1/users/${user.username}/playlists`;
        newPlaylist = await Spicetify.CosmosAsync.post(createPlaylistUrl, { name, description, public: !createPlaylistPrivate });
    }

    if (!newPlaylist || !newPlaylist.uri) {
        throw new Error("Failed to create playlist after all attempts.");
    }
    
    const playlistId = newPlaylist.uri.split(':')[2];

    await new Promise(resolve => setTimeout(resolve, 500));

    await Promise.all([
        setPlaylistVisibility(newPlaylist.uri, !createPlaylistPrivate),
        updatePlaylistDescription(playlistId, description)
    ]);
    
    return { ...newPlaylist, id: newPlaylist.uri.split(':')[2] };
  }

  function updatePlaylistDescription(playlistId, description, maxRetries = 12, retryInterval = 5000) {
    (async () => {
        const playlistUri = `spotify:playlist:${playlistId}`;

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                await Spicetify.Platform.PlaylistAPI.setAttributes(playlistUri, { description: description });

                await new Promise(resolve => setTimeout(resolve, 1000));

                const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(playlistUri);
                
                if (meta && meta.description === description) {
                    return;
                }
                
                throw new Error("Verification failed: Description not updated on Spotify's side yet.");

            } catch (error) {
                if (attempt < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, retryInterval));
                } else {
                    console.error(`[Sort-Play] Failed to set and verify playlist description for ${playlistId} after ${maxRetries} attempts.`, error);
                }
            }
        }
    })();
  }
  
  async function navigateToPlaylist(playlistObject, force = false) {
    if ((openPlaylistAfterSortEnabled || force) && playlistObject && playlistObject.uri) { 
        const tempPath = "/library"; 
        Spicetify.Platform.History.push(tempPath);
        await new Promise(resolve => setTimeout(resolve, 500)); 
        const newPlaylistPath = Spicetify.URI.fromString(playlistObject.uri).toURLPath(true);
        if (newPlaylistPath) {
          Spicetify.Platform.History.push(newPlaylistPath);
        } else {
          console.warn("Could not determine path for new playlist URI:", playlistObject.uri);
        }
    }
  }

  async function findOrCreatePlaylistFolder(folderName) {
      const { RootlistAPI } = Spicetify.Platform;
      if (!RootlistAPI) {
          console.error("Spicetify.Platform.RootlistAPI is not available.");
          showNotification("Error: Cannot manage folders.", true);
          return null;
      }
      try {
          const rootlist = await RootlistAPI.getContents();
          const existingFolder = rootlist.items.find(
              item => item.type === 'folder' && item.name === folderName
          );
          if (existingFolder) {
              return existingFolder.uri;
          }
          const newFolder = await RootlistAPI.createFolder(folderName, { before: "start" });
          if (newFolder && newFolder.uri) {
              return newFolder.uri;
          } else {
              throw new Error("Folder creation did not return a valid URI.");
          }
      } catch (error) {
          console.error(`Error in findOrCreatePlaylistFolder for "${folderName}":`, error);
          showNotification(`Error managing folder: ${folderName}`, true);
          return null;
      }
  }


  async function getTopItems(type, time_range, totalLimit) {
    let allItems = [];
    let offset = 0;
    const limitPerRequest = 50;

    while (allItems.length < totalLimit) {
        const res = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/me/top/${type}`, {
            time_range: time_range,
            limit: limitPerRequest,
            offset: offset
        });

        if (!res.items || res.items.length === 0) {
            break;
        }

        allItems = allItems.concat(res.items);
        offset += limitPerRequest;

        if (res.items.length < limitPerRequest) {
            break;
        }
    }
    return allItems.slice(0, totalLimit);
  }

  async function getAllFollowedArtists() {
    if (isFallbackActive()) {
        try {
            if (Spicetify.Platform?.LibraryAPI?.getContents) {
                const res = await Spicetify.Platform.LibraryAPI.getContents({ limit: 50000, sort: { field: "NAME", order: "ASC" } });
                const items = res.items || [];
                const artists = items
                    .filter(item => item.type === 'artist' || (item.uri && item.uri.includes(':artist:')))
                    .map(a => ({ 
                        uri: a.uri, 
                        name: a.name, 
                        id: a.uri.split(':')[2] 
                    }));
                return artists;
            }
        } catch (e) {
            console.warn("[Sort-Play] LibraryAPI.getContents fallback failed", e);
        }
        return [];
    }

    let allArtists = [];
    let nextUrl = 'https://api.spotify.com/v1/me/following?type=artist&limit=50';

    try {
        while (nextUrl) {
            const response = await Spicetify.CosmosAsync.get(nextUrl);
            if (response?.artists?.items) {
                allArtists.push(...response.artists.items);
                nextUrl = response.artists.next;
            } else {
                nextUrl = null;
            }
        }
    } catch (error) {
        if (registerWebApiFailure()) {
            return getAllFollowedArtists();
        }
        console.error("Failed to fetch all followed artists:", error);
    }
    return allArtists;
  }

  async function getComprehensiveKnownArtistsSet(options = {}) {
    const { isHeadless = false } = options;
    if (!isHeadless) {
        mainButton.innerText = "Filtering...";
    }
    
    const [longTerm, mediumTerm, shortTerm, followedArtists] = await Promise.all([
        getTopItems('artists', 'long_term', 300),
        getTopItems('artists', 'medium_term', 150),
        getTopItems('artists', 'short_term', 150),
        getAllFollowedArtists()
    ]);

    const knownArtistIds = new Set([
        ...longTerm.map(a => a.id),
        ...mediumTerm.map(a => a.id),
        ...shortTerm.map(a => a.id),
        ...followedArtists.map(a => a.id)
    ]);

    return knownArtistIds;
  }
  
  function calculateAudioStatistics(tracksWithFeatures) {
    const features = ['energy', 'valence', 'danceability', 'acousticness', 'tempo'];
    const stats = {
        averages: {},
        ranges: {}
    };

    const validTracks = tracksWithFeatures.filter(t => t.features && t.features.energy != null);
    if (validTracks.length === 0) return null;

    features.forEach(feature => {
        const sum = validTracks.reduce((acc, t) => acc + (t.features[feature] || 0), 0);
        stats.averages[feature] = sum / validTracks.length;

        const sorted = validTracks.map(t => t.features[feature] || 0).sort((a, b) => a - b);
        const p10Index = Math.floor(sorted.length * 0.1);
        const p90Index = Math.floor(sorted.length * 0.9);
        
        stats.ranges[feature] = {
            min: sorted[p10Index],
            max: sorted[p90Index]
        };
    });

    return stats;
  }

  async function generateSpotifyRecommendations(vibeType, options = {}) {
    const { isHeadless = false } = options;
    let playlistName = "";
    let playlistDescription = "";

    if (!isHeadless) {
        setButtonProcessing(true);
        mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
        mainButton.style.color = buttonStyles.main.disabledColor;
        mainButton.style.cursor = "default";
        svgElement.style.fill = buttonStyles.main.disabledColor;
        menuButtons.forEach((button) => (button.disabled = true));
        toggleMenu();
        closeAllMenus();
    }

    try {
        if (!isHeadless) mainButton.innerText = "Get library...";
        const allLikedSongs = await getLikedSongs();
        const completeLikedSongUrisSet = new Set(allLikedSongs.map(song => song.uri));
        
        const likedSongsFingerprintMap = new Map();
        allLikedSongs.forEach(song => {
            const title = song.name.toLowerCase().trim();
            if (!likedSongsFingerprintMap.has(title)) {
                likedSongsFingerprintMap.set(title, new Set());
            }
            const artistUrisForTitle = likedSongsFingerprintMap.get(title);
            song.artistUris.forEach(uri => artistUrisForTitle.add(uri));
        });

        if (vibeType === 'pureDiscovery') {
            playlistName = "Pure Discovery";
            playlistDescription = "Discover new music from artists completely new to you. Created by Sort-Play.";

            mainButton.innerText = "Filtering...";
            
            const knownArtistIds = await getComprehensiveKnownArtistsSet();
            const userMarket = await fetchUserMarket() || 'US';
            
            allLikedSongs.forEach(song => {
                if (song.artistUris) {
                    song.artistUris.forEach(uri => {
                        if (uri) knownArtistIds.add(uri.split(':')[2]);
                    });
                }
            });

            if (!isHeadless) mainButton.innerText = "Profiling...";
            
            const shortTermArtists = await getTopItems('artists', 'short_term', 50);
            
            const recentLikedArtists = allLikedSongs.slice(0, 50).map(song => {
                if (song.artistUris && song.artistUris.length > 0) {
                    return { id: song.artistUris[0].split(':')[2] };
                }
                return null;
            }).filter(Boolean);

            const combinedSeeds = new Map();
            [...shortTermArtists, ...recentLikedArtists].forEach(a => combinedSeeds.set(a.id, a));
            let topArtistsForSeeding = Array.from(combinedSeeds.values());

            if (topArtistsForSeeding.length === 0) {
                throw new Error("Need more listening history or liked songs to build a discovery profile.");
            }
            
            const fetchRelatedBatch = async (artists, sampleSize) => {
                const shuffled = shuffleArray(artists).slice(0, sampleSize);
                const results = new Map();
                const promises = shuffled.map(async (artist) => {
                    try {
                        const relatedData = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists/${artist.id}/related-artists`);
                        if (relatedData && relatedData.artists) {
                            relatedData.artists.forEach(rel => results.set(rel.id, rel));
                        }
                    } catch (e) {}
                });
                await Promise.all(promises);
                return Array.from(results.values());
            };

            if (!isHeadless) mainButton.innerText = "Related...";
            const level1Raw = await fetchRelatedBatch(topArtistsForSeeding, 20);
            const level1 = level1Raw.filter(a => !knownArtistIds.has(a.id));

            if (level1.length < 10) {
                const additionalLevel1 = await fetchRelatedBatch(topArtistsForSeeding, 30);
                const additionalUnknowns = additionalLevel1.filter(a => !knownArtistIds.has(a.id));
                const existingIds = new Set(level1.map(a => a.id));
                additionalUnknowns.forEach(a => {
                    if (!existingIds.has(a.id)) { level1.push(a); existingIds.add(a.id); }
                });
            }

            const level2Raw = await fetchRelatedBatch(level1, 15);
            const level2 = level2Raw.filter(a => !knownArtistIds.has(a.id));

            if (level2.length < 10 && level1.length > 0) {
                const additionalLevel2 = await fetchRelatedBatch(level1, 30);
                const additionalUnknowns = additionalLevel2.filter(a => !knownArtistIds.has(a.id));
                const existingIds = new Set(level2.map(a => a.id));
                additionalUnknowns.forEach(a => {
                    if (!existingIds.has(a.id)) { level2.push(a); existingIds.add(a.id); }
                });
            }

            const level3Raw = await fetchRelatedBatch(level2, 15);
            const level3 = level3Raw.filter(a => !knownArtistIds.has(a.id));

            if (level3.length < 10 && level2.length > 0) {
                const additionalLevel3 = await fetchRelatedBatch(level2, 30);
                const additionalUnknowns = additionalLevel3.filter(a => !knownArtistIds.has(a.id));
                const existingIds = new Set(level3.map(a => a.id));
                additionalUnknowns.forEach(a => {
                    if (!existingIds.has(a.id)) { level3.push(a); existingIds.add(a.id); }
                });
            }

            const directPickCount = Math.floor(discoveryPlaylistSize / 2);
            const directPool = [...level3, ...level2];
            const uniqueDirectPool = Array.from(new Map(directPool.map(a => [a.id, a])).values());
            
            if (uniqueDirectPool.length < directPickCount) uniqueDirectPool.push(...level1);

            if (!isHeadless) mainButton.innerText = "Picking...";
            const chosenDirectArtists = shuffleArray(uniqueDirectPool).slice(0, directPickCount + 15); 
            const directTracks = [];
            const processedArtistIds = new Set(); 

            const directBatches = [];
            while(chosenDirectArtists.length) directBatches.push(chosenDirectArtists.splice(0, 5));

            for (const batch of directBatches) {
                if (directTracks.length >= directPickCount) break;

                await Promise.all(batch.map(async (artist) => {
                    if (knownArtistIds.has(artist.id) || processedArtistIds.has(artist.id)) return;

                    try {
                        const topTracksRes = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists/${artist.id}/top-tracks?market=${userMarket}`);
                        if (topTracksRes && topTracksRes.tracks && topTracksRes.tracks.length > 0) {
                            const validTracks = [];
                            for (const t of topTracksRes.tracks) {
                                if (!completeLikedSongUrisSet.has(t.uri) && t.popularity > 0 && await isTrackAvailable(t)) {
                                    validTracks.push(t);
                                }
                            }

                            if (validTracks.length > 0) {
                                let trackToPick;
                                
                                let poolSize = 1;
                                const maxPool = Math.min(5, validTracks.length);
                                
                                for (let i = 0; i < maxPool - 1; i++) {
                                    if ((validTracks[i].popularity - validTracks[i+1].popularity) > 4) {
                                        break;
                                    }
                                    poolSize++;
                                }
                                
                                const pickIndex = Math.floor(Math.random() * poolSize);
                                trackToPick = validTracks[pickIndex];
                                
                                directTracks.push(trackToPick);
                                processedArtistIds.add(artist.id);
                                trackToPick.artists.forEach(a => knownArtistIds.add(a.id));
                            }
                        }
                    } catch (e) {}
                }));
                await new Promise(r => setTimeout(r, 100));
            }

            if (!isHeadless) mainButton.innerText = "Get recs...";
            
            const makeRecRequest = async (seeds) => {
                const finalSeeds = (seeds && seeds.length > 0) ? seeds : shuffleArray(topArtistsForSeeding).slice(0, 3);
                const seedIds = finalSeeds.map(a => a.id);
                
                const params = new URLSearchParams({ 
                    limit: 35,
                    min_popularity: '5',
                    market: userMarket,
                    seed_artists: seedIds.join(',')
                });
                
                try {
                    const res = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/recommendations?${params.toString()}`);
                    return res?.tracks || [];
                } catch (e) { return []; }
            };

            const seedsL1 = shuffleArray(level1).slice(0, 3);
            const seedsL2 = shuffleArray(level2).slice(0, 3);
            const seedsL3 = shuffleArray(level3).slice(0, 3);

            const [recsL1, recsL2, recsL3] = await Promise.all([
                makeRecRequest(seedsL1),
                makeRecRequest(seedsL2),
                makeRecRequest(seedsL3)
            ]);

            const rawApiTracks = [...recsL1, ...recsL2, ...recsL3];
            
            let apiRecommendedTracks = [];
            if (rawApiTracks.length > 0) {
                const availabilityChecks = await Promise.all(rawApiTracks.map(track => isTrackAvailable(track)));
                
                const seenApiUris = new Set();
                apiRecommendedTracks = rawApiTracks.filter((track, index) => {
                    if (!availabilityChecks[index]) return false;
                    if (seenApiUris.has(track.uri)) return false;
                    seenApiUris.add(track.uri);
                    
                    if (completeLikedSongUrisSet.has(track.uri)) return false;
                    
                    const hasKnownArtist = track.artists.some(a => knownArtistIds.has(a.id));
                    if (hasKnownArtist) return false;

                    track.artists.forEach(a => knownArtistIds.add(a.id));
                    return true;
                });
            }

            if (!isHeadless) mainButton.innerText = "Combining...";
            
            const finalDirect = directTracks.slice(0, directPickCount);
            const neededApi = discoveryPlaylistSize - finalDirect.length;
            const finalApi = apiRecommendedTracks.slice(0, neededApi);
            
            let allCandidates = [...finalDirect, ...finalApi];
            
            const uniqueUriSet = new Set();
            allCandidates = allCandidates.filter(t => {
                if(uniqueUriSet.has(t.uri)) return false;
                uniqueUriSet.add(t.uri);
                return true;
            });

            if (allCandidates.length === 0) throw new Error("Could not find enough tracks matching discovery criteria.");
            
            if (!isHeadless) mainButton.innerText = "Sorting...";
            const trackIds = allCandidates.map(t => t.id);
            const stats = await getBatchTrackStats(trackIds);
            const tracksWithFeatures = allCandidates.map(t => ({ ...t, features: stats[t.id] }));
            
            const validForWave = tracksWithFeatures.filter(t => t.features && t.features.energy != null);
            const others = tracksWithFeatures.filter(t => !t.features || t.features.energy == null);
            
            const sortedTracks = await energyWaveSort(validForWave, 'discovery');
            const finalTracks = [...sortedTracks, ...others];
            
            const trackUris = finalTracks.map(track => track.uri);
            
            if (!isHeadless) mainButton.innerText = "Creating...";
            const { playlist: newPlaylist, wasUpdated } = await getOrCreateDedicatedPlaylist(vibeType, playlistName, playlistDescription);
            
            if (wasUpdated) {
                await replacePlaylistTracks(newPlaylist.id, trackUris);
            } else {
                await addTracksToPlaylist(newPlaylist.id, trackUris);
            }
            
            showNotification(`Playlist "${playlistName}" ${wasUpdated ? 'updated' : 'created'} successfully!`);
            await navigateToPlaylist(newPlaylist);
            return;
        }

        let time_range = 'medium_term';
        let contrast_time_range = 'long_term';
        let top_pool_size = 100;

        if (vibeType === 'recommendRecentVibe') {
            playlistName = "Discovery: Recent Taste";
            playlistDescription = "A diverse mix based on your recent taste. Created by Sort-Play.";
            time_range = 'short_term';
            contrast_time_range = 'long_term';
        } else if (vibeType === 'recommendAllTime') {
            playlistName = "Discovery: All-Time Taste";
            playlistDescription = "A diverse mix based on your all-time taste. Created by Sort-Play.";
            time_range = 'long_term';
            contrast_time_range = 'short_term';
        }

        if (!isHeadless) mainButton.innerText = "Get top...";
        let [topArtists, topTracks, contrastTopTracks] = await Promise.all([
            getTopItems('artists', time_range, top_pool_size),
            getTopItems('tracks', time_range, top_pool_size),
            getTopItems('tracks', contrast_time_range, 1)
        ]);

        if (topArtists.length < 2 || topTracks.length < 2) {
             [topArtists, topTracks] = await Promise.all([
                getTopItems('artists', 'short_term', top_pool_size),
                getTopItems('tracks', 'short_term', top_pool_size)
            ]);
        }

        if (topArtists.length < 1 || topTracks.length < 1) {
            throw new Error("Not enough listening history for diverse recommendations.");
        }

        if (!isHeadless) mainButton.innerText = "Profiling...";

        let primarySeedTracks = [];
        let primarySeedArtistIds = new Set();
        let likedSample = [];

        if (vibeType === 'recommendAllTime') {
            const shuffledLiked = shuffleArray(allLikedSongs).slice(0, 200);
            likedSample = shuffledLiked;
            
            const mappedLiked = shuffledLiked.map(t => ({
                id: t.uri.split(':')[2],
                uri: t.uri,
                name: t.name,
                artists: (t.artistUris || []).map(u => ({ id: u.split(':')[2], uri: u })),
                popularity: t.popularity || 50,
                _isLikedSong: true
            }));
            
            const likedPortion = Math.ceil(top_pool_size * 0.7);
            const topPortion = Math.floor(top_pool_size * 0.3);
            
            primarySeedTracks = [
                ...shuffleArray(mappedLiked).slice(0, likedPortion),
                ...shuffleArray(topTracks).slice(0, topPortion)
            ];
            
            mappedLiked.forEach(t => t.artists.forEach(a => primarySeedArtistIds.add(a.id)));
            
        } else if (vibeType === 'recommendRecentVibe') {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - 28);
            
            const recentLikes = allLikedSongs.filter(t => new Date(t.addedAt) >= cutoffDate);
            
            if (recentLikes.length < 10) {
                likedSample = [...allLikedSongs]
                    .sort((a, b) => new Date(b.addedAt) - new Date(a.addedAt))
                    .slice(0, 30);
            } else {
                const now = Date.now();
                const weightedTracks = recentLikes.map(t => {
                    const daysAgo = (now - new Date(t.addedAt).getTime()) / (1000 * 60 * 60 * 24);
                    const weight = Math.exp(-0.05 * Math.max(0, daysAgo)); 
                    return { track: t, weight };
                });

                const selected = [];
                const pool = [...weightedTracks];
                
                for (let i = pool.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [pool[i], pool[j]] = [pool[j], pool[i]];
                }

                const sampleSize = Math.min(pool.length, 80);
                
                for (let i = 0; i < sampleSize && pool.length > 0; i++) {
                    let totalWeight = pool.reduce((sum, item) => sum + item.weight, 0);
                    let r = Math.random() * totalWeight;
                    let idx = 0;
                    for (let j = 0; j < pool.length; j++) {
                        r -= pool[j].weight;
                        if (r <= 0) { idx = j; break; }
                    }
                    selected.push(pool[idx].track);
                    pool.splice(idx, 1);
                }
                likedSample = selected;
            }
            
            const mappedRecent = likedSample.map(t => ({
                id: t.uri.split(':')[2],
                uri: t.uri,
                name: t.name,
                artists: (t.artistUris || []).map(u => ({ id: u.split(':')[2], uri: u })),
                popularity: t.popularity || 50,
                _isLikedSong: true
            }));
            
            const likedPortion = Math.ceil(top_pool_size * 0.8);
            const topPortion = Math.floor(top_pool_size * 0.2);
            
            primarySeedTracks = [
                ...mappedRecent.slice(0, likedPortion),
                ...shuffleArray(topTracks).slice(0, topPortion)
            ];
            
            mappedRecent.forEach(t => t.artists.forEach(a => primarySeedArtistIds.add(a.id)));
            
        } else {
            likedSample = shuffleArray(allLikedSongs).slice(0, 50);
            primarySeedTracks = [...topTracks];
        }

        const originalTopTracks = [...topTracks];
        topTracks = primarySeedTracks.length > 0 ? primarySeedTracks : topTracks;

        if (primarySeedArtistIds.size > 0) {
            const additionalArtistIds = Array.from(primarySeedArtistIds)
                .filter(id => !topArtists.some(a => a.id === id));
            
            const additionalArtists = additionalArtistIds.slice(0, 50).map(id => ({ 
                id, 
                genres: [],
                _fromLikedSongs: true 
            }));
            
            if (vibeType === 'recommendRecentVibe') {
                topArtists = [...additionalArtists, ...topArtists].slice(0, 150);
            } else {
                topArtists = shuffleArray([...topArtists, ...additionalArtists]).slice(0, 150);
            }
        }

        const tracksToProfile = [...originalTopTracks];
        if (likedSample.length > 0) {
            tracksToProfile.push(...likedSample.map(t => ({...t, id: t.uri.split(':')[2]})));
        }

        const profileTrackIds = [...new Set(tracksToProfile.map(t => t.id))];
        const allAudioStats = await getBatchTrackStats(profileTrackIds);

        originalTopTracks.forEach(t => t.features = allAudioStats[t.id]);
        topTracks.forEach(t => {
            if (!t.features) t.features = allAudioStats[t.id];
        });

        const profilingSource = primarySeedTracks.length > 0 ? primarySeedTracks : originalTopTracks;
        const tracksWithFeatures = profilingSource.filter(t => t.features);
        const userAudioProfile = calculateAudioStatistics(tracksWithFeatures);


        const allGenres = new Set(topArtists.flatMap(a => a.genres));
        const shuffledGenres = shuffleArray(Array.from(allGenres));
        let genreBridgeSeeds = [];
        let genreBridgeTargets = {};

        if (shuffledGenres.length >= 2) {
            const genre1 = shuffledGenres[0];
            const genre2 = shuffledGenres[1];
            
            const artistsForGenre1 = shuffleArray(topArtists.filter(a => a.genres.includes(genre1))).slice(0, 3);
            const artistsForGenre2 = shuffleArray(topArtists.filter(a => a.genres.includes(genre2))).slice(0, 2);
            genreBridgeSeeds = [...artistsForGenre1, ...artistsForGenre2].map(a => a.id);

            const getGenreTracks = (g) => topTracks.filter(t => t.features && t.artists.some(a => {
                const artistObj = topArtists.find(ta => ta.id === a.id);
                return artistObj && artistObj.genres.includes(g);
            }));

            const tracksG1 = getGenreTracks(genre1);
            const tracksG2 = getGenreTracks(genre2);
            
            if (tracksG1.length > 0 && tracksG2.length > 0) {
                const stat1 = calculateAudioStatistics(tracksG1).averages;
                const stat2 = calculateAudioStatistics(tracksG2).averages;
                
                genreBridgeTargets = {
                    target_energy: (stat1.energy + stat2.energy) / 2,
                    target_valence: (stat1.valence + stat2.valence) / 2,
                    target_danceability: (stat1.danceability + stat2.danceability) / 2,
                };
            }
        }

        const sortedByPopAsc = [...topTracks].sort((a, b) => a.popularity - b.popularity);
        const deepCutPool = sortedByPopAsc.slice(0, 50);
        const deepCutSeeds = shuffleArray(deepCutPool).slice(0, 5).map(t => t.id);
        
        let deepCutTargets = {};
        const deepCutTracksWithFeatures = deepCutPool.filter(t => t.features);
        if (deepCutTracksWithFeatures.length > 0) {
            const dcStats = calculateAudioStatistics(deepCutTracksWithFeatures).averages;
            deepCutTargets = {
                target_energy: dcStats.energy,
                target_valence: dcStats.valence,
                target_acousticness: dcStats.acousticness,
                max_popularity: 40
            };
        } else {
            deepCutTargets = { max_popularity: 40 };
        }

        let likedSongSeedUris = [];
        if (vibeType === 'recommendRecentVibe') {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - 28);
            
            const recentLikes = allLikedSongs.filter(t => new Date(t.addedAt) >= cutoffDate);
            
            if (recentLikes.length < 10) {
                const recentPool = [...allLikedSongs]
                    .sort((a, b) => new Date(b.addedAt) - new Date(a.addedAt))
                    .slice(0, 15);
                likedSongSeedUris = shuffleArray(recentPool).slice(0, 5).map(t => t.uri.split(':')[2]);
            } else {
                const now = Date.now();
                const weightedTracks = recentLikes.map(t => {
                    const daysAgo = (now - new Date(t.addedAt).getTime()) / (1000 * 60 * 60 * 24);
                    const weight = Math.exp(-0.08 * Math.max(0, daysAgo));
                    return { track: t, weight };
                });

                const selectedSeeds = [];
                const pool = [...weightedTracks];
                for (let i = pool.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [pool[i], pool[j]] = [pool[j], pool[i]];
                }

                const seedCount = Math.min(5, pool.length);

                for (let i = 0; i < seedCount; i++) {
                    let totalWeight = pool.reduce((sum, item) => sum + item.weight, 0);
                    let r = Math.random() * totalWeight;
                    let idx = 0;
                    for (let j = 0; j < pool.length; j++) {
                        r -= pool[j].weight;
                        if (r <= 0) { idx = j; break; }
                    }
                    selectedSeeds.push(pool[idx].track);
                    pool.splice(idx, 1);
                }
                likedSongSeedUris = selectedSeeds.map(t => t.uri.split(':')[2]);
            }
        } else if (vibeType === 'recommendAllTime') {
            likedSongSeedUris = shuffleArray(allLikedSongs).slice(0, 5).map(t => t.uri.split(':')[2]);
        } else {
            likedSongSeedUris = shuffleArray(allLikedSongs.slice(-100)).slice(0, 5).map(t => t.uri.split(':')[2]);
        }

        const smartSongSeeds = new Set();
        if (vibeType === 'recommendAllTime') smartSongSeeds.add(shuffleArray(topTracks.slice(0, 20))[0]);
        else smartSongSeeds.add(shuffleArray(topTracks.slice(0, 5))[0]);
        
        if (topTracks.length > 0) smartSongSeeds.add([...topTracks].sort((a, b) => b.popularity - a.popularity)[0]);
        if (deepCutPool.length > 0) smartSongSeeds.add(deepCutPool[0]);
        if (contrastTopTracks.length > 0) smartSongSeeds.add(contrastTopTracks[0]);
        const randomLikedTopTrackPool = topTracks.filter(t => completeLikedSongUrisSet.has(t.uri));
        if(randomLikedTopTrackPool.length > 0) smartSongSeeds.add(shuffleArray(randomLikedTopTrackPool)[0]);
        
        const finalSmartSeeds = Array.from(smartSongSeeds).filter(Boolean);
        let seedIdx = 0;
        while (finalSmartSeeds.length < 5 && seedIdx < topTracks.length) {
            if (!finalSmartSeeds.some(s => s.uri === topTracks[seedIdx].uri)) finalSmartSeeds.push(topTracks[seedIdx]);
            seedIdx++;
        }
        const smartSeedUris = finalSmartSeeds.slice(0, 5).map(t => t.id);

        let edgeExplorerTargets = {};
        let edgeExplorerSeeds = shuffleArray(topTracks).slice(0, 5).map(t => t.id);
        
        if (userAudioProfile) {
            const featuresToPush = ['energy', 'valence', 'acousticness'];
            const featureToPush = featuresToPush[Math.floor(Math.random() * featuresToPush.length)];
            const range = userAudioProfile.ranges[featureToPush];
            const isHighPush = Math.random() > 0.5;

            const safeParams = {};
            featuresToPush.forEach(f => {
                if (f !== featureToPush) {
                    safeParams[`min_${f}`] = Math.max(0, userAudioProfile.ranges[f].min / 100);
                    safeParams[`max_${f}`] = Math.min(1, userAudioProfile.ranges[f].max / 100);
                }
            });

            if (isHighPush) {
                edgeExplorerTargets = {
                    ...safeParams,
                    [`min_${featureToPush}`]: Math.min(0.95, userAudioProfile.ranges[featureToPush].max / 100),
                    [`max_${featureToPush}`]: 1.0
                };
            } else {
                edgeExplorerTargets = {
                    ...safeParams,
                    [`min_${featureToPush}`]: 0.0,
                    [`max_${featureToPush}`]: Math.max(0.05, userAudioProfile.ranges[featureToPush].min / 100)
                };
            }
        }

        if (!isHeadless) mainButton.innerText = "Get recs...";
        
        const trackArtistMap = new Map();
        const addToLookup = (t) => {
            const tid = t.id || (t.uri ? t.uri.split(':')[2] : null);
            if (tid && !trackArtistMap.has(tid)) {
                const aIds = new Set();
                if (t.artists) t.artists.forEach(a => aIds.add(a.id || (a.uri ? a.uri.split(':')[2] : null)));
                if (t.artistUris) t.artistUris.forEach(u => aIds.add(u.split(':')[2]));
                trackArtistMap.set(tid, aIds);
            }
        };
        topTracks.forEach(addToLookup);
        allLikedSongs.forEach(addToLookup);

        const recommendationBatches = [];
        const NUM_CALLS = 7;
        
        for (let i = 0; i < NUM_CALLS; i++) {
            let params = new URLSearchParams({ limit: 100 });
            let seed_artists = [], seed_tracks = [];
            const forbiddenArtistIds = new Set();

            if (i < 2) {
                seed_artists = shuffleArray(topArtists).slice(0, 3).map(a => a.id);
                seed_tracks = shuffleArray(topTracks).slice(0, 2).map(t => t.id);
            } 
            else if (i === 2) {
                seed_artists = genreBridgeSeeds;
                Object.keys(genreBridgeTargets).forEach(key => params.append(key, (genreBridgeTargets[key] / 100).toFixed(2)));
            } 
            else if (i === 3) {
                seed_tracks = deepCutSeeds;
                Object.keys(deepCutTargets).forEach(key => {
                    if (key === 'max_popularity') params.append(key, deepCutTargets[key]);
                    else params.append(key, (deepCutTargets[key] / 100).toFixed(2));
                });
            } 
            else if (i === 4) {
                seed_tracks = likedSongSeedUris;
            } 
            else if (i === 5) {
                seed_tracks = smartSeedUris;
            } 
            else if (i === 6) {
                seed_tracks = edgeExplorerSeeds;
                Object.keys(edgeExplorerTargets).forEach(key => params.append(key, edgeExplorerTargets[key].toFixed(2)));
            }

            if (seed_artists.length > 0) {
                seed_artists.forEach(id => forbiddenArtistIds.add(id));
            }

            if (seed_tracks.length > 0) {
                seed_tracks.forEach(tid => {
                    const aIds = trackArtistMap.get(tid);
                    if (aIds) aIds.forEach(id => forbiddenArtistIds.add(id));
                });
            }

            if (seed_artists.length > 0) params.append('seed_artists', [...new Set(seed_artists)].join(','));
            if (seed_tracks.length > 0) params.append('seed_tracks', [...new Set(seed_tracks)].join(','));

            try {
                if (seed_artists.length > 0 || seed_tracks.length > 0) {
                    const recsResponse = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/recommendations?${params.toString()}`);
                    if (recsResponse?.tracks?.length > 0) {
                        const filteredRecs = recsResponse.tracks.filter(t => {
                            if (!t.artists) return true;
                            return !t.artists.some(a => forbiddenArtistIds.has(a.id));
                        });

                        if (filteredRecs.length > 0) {
                            recommendationBatches.push(filteredRecs);
                        }
                    }
                }
            } catch (e) { console.warn(`Recommendation call ${i+1} failed.`, e); }
            await new Promise(resolve => setTimeout(resolve, 250));
        }

        if (recommendationBatches.length === 0) {
            throw new Error("Spotify didn't return any recommendations. Try again!");
        }

        if (!isHeadless) mainButton.innerText = "Mixing...";
        let interleavedTracks = [];
        const maxBatchLength = Math.max(...recommendationBatches.map(batch => batch.length));
        for (let i = 0; i < maxBatchLength; i++) {
            for (let j = 0; j < recommendationBatches.length; j++) {
                if (recommendationBatches[j][i]) {
                    interleavedTracks.push(recommendationBatches[j][i]);
                }
            }
        }
        
        const seenUris = new Set();
        const uniqueMixedTracks = interleavedTracks.filter(track => {
            if (seenUris.has(track.uri)) return false;
            seenUris.add(track.uri);
            return true;
        });

        if (!isHeadless) mainButton.innerText = "Excluding...";
        const availabilityChecks = await Promise.all(uniqueMixedTracks.map(track => isTrackAvailable(track)));
        let newRecommendedTracks = uniqueMixedTracks.filter((track, index) => {
            if (!availabilityChecks[index]) return false;
            if (completeLikedSongUrisSet.has(track.uri)) return false;
            
            const title = track.name.toLowerCase().trim();
            const likedArtistUrisForTitle = likedSongsFingerprintMap.get(title);
            if (!likedArtistUrisForTitle) return true;
            
            const recommendedArtistUris = track.artists.map(a => a.uri);
            return !recommendedArtistUris.some(uri => likedArtistUrisForTitle.has(uri));
        });

        const uniqueMainArtists = new Set();
        newRecommendedTracks = newRecommendedTracks.filter(track => {
            const mainArtistId = track.artists?.[0]?.id;
            if (mainArtistId) {
                if (uniqueMainArtists.has(mainArtistId)) return false;
                uniqueMainArtists.add(mainArtistId);
            }
            return true;
        });

        if (newRecommendedTracks.length === 0) throw new Error("All recommended tracks were already known to you. Great taste!");
        
        if (!isHeadless) mainButton.innerText = "Sorting...";
        const tracksToSort = newRecommendedTracks.slice(0, discoveryPlaylistSize * 2);
        
        const trackIds = tracksToSort.map(t => t.id);
        const stats = await getBatchTrackStats(trackIds);
        const tracksWithFeaturesFinal = tracksToSort.map(t => ({ ...t, features: stats[t.id] }));
        
        const validForWave = tracksWithFeaturesFinal.filter(t => t.features && t.features.energy != null);
        const others = tracksWithFeaturesFinal.filter(t => !t.features || t.features.energy == null);
        
        const sortedTracks = await energyWaveSort(validForWave);
        const finalTracks = [...sortedTracks, ...others].slice(0, discoveryPlaylistSize);

        const trackUris = finalTracks.map(track => track.uri);
        
        if (!isHeadless) mainButton.innerText = "Creating...";
        const { playlist: newPlaylist, wasUpdated } = await getOrCreateDedicatedPlaylist(vibeType, playlistName, playlistDescription);
        
        if (wasUpdated) {
            await replacePlaylistTracks(newPlaylist.id, trackUris);
        } else {
            await addTracksToPlaylist(newPlaylist.id, trackUris);
        }

        showNotification(`Playlist "${playlistName}" ${wasUpdated ? 'updated' : 'created'} successfully!`);
        await navigateToPlaylist(newPlaylist);

    } catch (error) {
        console.error(`Error in generateSpotifyRecommendations (${vibeType}):`, error);
        showNotification(error.message, true);
    } finally {
        if (!isHeadless) {
            resetButtons();
        }
    }
  }

  async function generateFollowedReleasesChronological(options = {}) {
    const { isHeadless = false } = options;
    const { GraphQL, CosmosAsync } = Spicetify;
    if (!isHeadless) {
        setButtonProcessing(true);
        mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
        mainButton.style.color = buttonStyles.main.disabledColor;
        mainButton.style.cursor = "default";
        svgElement.style.fill = buttonStyles.main.disabledColor;
        menuButtons.forEach((button) => (button.disabled = true));
        toggleMenu();
        closeAllMenus();
    }

    try {
        const updateProgress = isHeadless ? () => {} : (message) => { mainButton.innerText = message; };

        updateProgress("Get artists...");
        
        async function getFollowedArtists() {
            if (isFallbackActive()) {
                try {
                    if (Spicetify.Platform?.LibraryAPI?.getContents) {
                        const res = await Spicetify.Platform.LibraryAPI.getContents({ limit: 50000, sort: { field: "NAME", order: "ASC" } });
                        return (res.items || [])
                            .filter(item => item.type === 'artist' || (item.uri && item.uri.includes(':artist:')))
                            .map(a => ({ uri: a.uri, name: a.name, id: a.uri.split(':')[2] }));
                    }
                } catch (e) {
                    console.warn("[Sort-Play] LibraryAPI fallback failed", e);
                }
                return [];
            }

            let artists = [];
            let nextUrl = 'https://api.spotify.com/v1/me/following?type=artist&limit=50';
            try {
                while (nextUrl) {
                    const response = await Spicetify.CosmosAsync.get(nextUrl);
                    if (response.artists?.items) {
                        artists.push(...response.artists.items);
                        nextUrl = response.artists.next;
                    } else {
                        nextUrl = null;
                    }
                }
            } catch (e) {
                if (registerWebApiFailure()) {
                    return getFollowedArtists();
                }
                throw e;
            }
            return artists;
        }

        const followedArtists = await getFollowedArtists();
        if (followedArtists.length === 0) {
            throw new Error("You are not following any artists.");
        }

        const dateLimit = new Date();
        dateLimit.setUTCHours(0, 0, 0, 0);
        
        let daysDesc = "";
    
        if (String(newReleasesDaysLimit).startsWith('release-')) {
             const weeks = parseInt(newReleasesDaysLimit.split('-')[1], 10) || 1;
             const daysSinceLastFriday = (dateLimit.getUTCDay() + 2) % 7;
             const totalDaysToSubtract = daysSinceLastFriday + (weeks - 1) * 7;
             dateLimit.setUTCDate(dateLimit.getUTCDate() - totalDaysToSubtract);
             daysDesc = weeks === 1 ? "this release week" : `the last ${weeks} release weeks`;
        } else {
             const days = parseInt(newReleasesDaysLimit, 10) || 14;
             dateLimit.setUTCDate(dateLimit.getUTCDate() - days);
             daysDesc = `the last ${days} days`;
        }
    
        const newReleasesMap = new Map();
        
        const BATCH_SIZE = 300;
        for (let i = 0; i < followedArtists.length; i += BATCH_SIZE) {
            const artistBatch = followedArtists.slice(i, i + BATCH_SIZE);
            updateProgress(`Scanning...`);

            const batchPromises = artistBatch.map(artist => {
                const variables = { uri: artist.uri, order: "DATE_DESC", offset: 0, limit: 20 };
                return GraphQL.Request(GraphQL.Definitions.queryArtistDiscographyAll, variables)
                    .catch(err => {
                        console.warn(`Failed to fetch discography for ${artist.name}`, err);
                        return null;
                    });
            });

            const batchResponses = await Promise.all(batchPromises);

            for (const response of batchResponses) {
                if (!response || response.errors || !response.data?.artistUnion) continue;
                
                const releases = response.data.artistUnion.discography?.all?.items;
                if (releases) {
                    for (const release of releases) {
                        const album = release.releases.items[0];
                        if (album?.date?.isoString) {
                            const releaseDate = new Date(album.date.isoString);
                            if (releaseDate >= dateLimit) {
                                newReleasesMap.set(album.uri, album);
                            }
                        }
                    }
                }
            }
            await new Promise(resolve => setTimeout(resolve, 200));
        }

        const allNewReleases = Array.from(newReleasesMap.values());
        if (allNewReleases.length === 0) {
            throw new Error(`No new releases found in ${daysDesc}.`);
        }

        updateProgress(`Get tracks...`);
        let initialTrackPool = [];
        const verifiedNewTracks = [];

        if (isFallbackActive()) {
            const CONCURRENCY = 5;
            let processedCount = 0;
            
            for (let i = 0; i < allNewReleases.length; i += CONCURRENCY) {
                const batch = allNewReleases.slice(i, i + CONCURRENCY);
                const results = await Promise.all(batch.map(async (albumMeta) => {
                    try {
                        const albumId = albumMeta.uri.split(':')[2];
                        let tracks = await getAlbumTracks(albumId);
                        
                        if (!tracks || !Array.isArray(tracks)) tracks = [];

                        if (followedReleasesAlbumLimit !== 'all') {
                            const limit = parseInt(followedReleasesAlbumLimit, 10);
                            if (!isNaN(limit)) tracks = tracks.slice(0, limit);
                        }
                        
                        return tracks.map(t => ({
                            track: t,
                            albumMeta: albumMeta 
                        }));
                    } catch (e) { return []; }
                }));
                
                results.flat().forEach(item => {
                    const t = item.track;
                    const meta = item.albumMeta;
                    
                    const adapted = {
                        uri: t.uri,
                        id: t.uri.split(':')[2],
                        name: t.name,
                        duration_ms: t.durationMilis,
                        track_number: t.trackNumber || (t.track?.track_number) || 0,
                        artists: t.track?.artists || (t.artistUris || []).map((u, idx) => ({ id: u.split(':')[2], name: (t.allArtists || "").split(', ')[idx] || 'Unknown' })),
                        album: {
                            name: t.albumName,
                            release_date: meta.date?.isoString || t.releaseDate,
                            album_type: meta.type || 'album',
                            total_tracks: 0 
                        }
                    };
                    verifiedNewTracks.push(adapted);
                });
                
                processedCount += batch.length;
                updateProgress(`Tracks ${Math.round((processedCount / allNewReleases.length) * 100)}%`);
            }
        } else {
            const albumUris = allNewReleases.map(a => a.uri);
            try {
                for (let i = 0; i < albumUris.length; i += 20) {
                    const albumIdBatch = albumUris.slice(i, i + 20).map(uri => uri.split(':')[2]);
                    const albumsData = await CosmosAsync.get(`https://api.spotify.com/v1/albums?ids=${albumIdBatch.join(',')}`);
                    if (albumsData.albums) {
                        for (const album of albumsData.albums) {
                            if (album && album.tracks && album.tracks.items) {
                                let tracksFromAlbum = album.tracks.items;
                                if (followedReleasesAlbumLimit !== 'all') {
                                    tracksFromAlbum = tracksFromAlbum.slice(0, parseInt(followedReleasesAlbumLimit, 10));
                                }
                                initialTrackPool.push(...tracksFromAlbum);
                            }
                        }
                    }
                }
            } catch (e) {
                if (registerWebApiFailure()) {
                    return generateFollowedReleasesChronological(options);
                }
                throw e;
            }

            if (initialTrackPool.length === 0) {
                throw new Error("Could not fetch any tracks from the new releases.");
            }

            updateProgress("Verifying...");
            const trackIdsToVerify = initialTrackPool.map(t => t.id);

            try {
                for (let i = 0; i < trackIdsToVerify.length; i += 50) {
                    const batchIds = trackIdsToVerify.slice(i, i + 50);
                    const trackDetailsResponse = await CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${batchIds.join(',')}`);

                    if (trackDetailsResponse && trackDetailsResponse.tracks) {
                        for (const detailedTrack of trackDetailsResponse.tracks) {
                            if (detailedTrack && detailedTrack.album && detailedTrack.album.release_date) {
                                const trackReleaseDate = new Date(detailedTrack.album.release_date);
                                if (trackReleaseDate >= dateLimit) {
                                    verifiedNewTracks.push(detailedTrack);
                                }
                            }
                        }
                    }
                }
            } catch (e) {
                if (registerWebApiFailure()) {
                    return generateFollowedReleasesChronological(options);
                }
                throw e;
            }
        }
        
        updateProgress("Deduplicating...");
        const trackGroups = new Map();

        const getFirstWord = (title) => {
            if (!title) return "";
            const clean = title.replace(/^[^a-zA-Z0-9]+/, '').split(/\s+/)[0].replace(/[^a-zA-Z0-9]+$/, '').toLowerCase();
            return clean;
        };

        for (const track of verifiedNewTracks) {
            const duration = track.duration_ms;
            const artistIds = track.artists ? track.artists.map(a => a.id).sort().join(',') : "";
            const firstWord = getFirstWord(track.name);

            const key = `${duration}|${artistIds}|${firstWord}`;

            if (!trackGroups.has(key)) {
                trackGroups.set(key, []);
            }
            trackGroups.get(key).push(track);
        }

        const finalDeduplicatedTracks = [];

        const getTypeScore = (type) => {
            const t = (type || '').toLowerCase();
            if (t === 'album') return 3;
            if (t === 'compilation') return 2;
            if (t === 'single') return 1;
            return 0;
        };

        for (const group of trackGroups.values()) {
            if (group.length === 1) {
                finalDeduplicatedTracks.push(group[0]);
                continue;
            }

            group.sort((a, b) => {
                const scoreA = getTypeScore(a.album.album_type);
                const scoreB = getTypeScore(b.album.album_type);
                if (scoreA !== scoreB) {
                    return scoreB - scoreA;
                }

                const dateA = new Date(a.album.release_date).getTime();
                const dateB = new Date(b.album.release_date).getTime();
                if (dateA !== dateB) {
                    return dateB - dateA;
                }

                const tracksA = a.album.total_tracks || 0;
                const tracksB = b.album.total_tracks || 0;
                return tracksB - tracksA;
            });

            finalDeduplicatedTracks.push(group[0]);
        }

        let genuinelyNewTracks = finalDeduplicatedTracks;
        console.log(`Followed Releases: Verified ${verifiedNewTracks.length} tracks, deduplicated to ${genuinelyNewTracks.length} tracks.`);

        if (genuinelyNewTracks.length === 0) {
            throw new Error("No genuinely new tracks found after verification and deduplication.");
        }
        
        updateProgress("Sorting...");
        genuinelyNewTracks.sort((a, b) => {
            const dateA = new Date(a.album.release_date).getTime();
            const dateB = new Date(b.album.release_date).getTime();
            if (dateB !== dateA) {
                return dateB - dateA;
            }
        
            const albumNameA = a.album.name || '';
            const albumNameB = b.album.name || '';
            const albumCompare = albumNameA.localeCompare(albumNameB);
            if (albumCompare !== 0) {
                return albumCompare; 
            }
        
            return a.track_number - b.track_number;
        });

        const trackUris = genuinelyNewTracks.map(track => track.uri);
        const playlistName = "New Releases: Followed";
        const playlistDescription = `All new releases from artists you follow from ${daysDesc} (since ${dateLimit.toLocaleDateString()}), sorted by release date. Created by Sort-Play.`;
        
        updateProgress("Creating...");
        const { playlist: newPlaylist, wasUpdated } = await getOrCreateDedicatedPlaylist('followedReleasesChronological', playlistName, playlistDescription);
        
        updateProgress("Saving...");
        if (wasUpdated) {
            await replacePlaylistTracks(newPlaylist.id, trackUris);
        } else {
            await addTracksToPlaylist(newPlaylist.id, trackUris);
        }
        
        showNotification(`Playlist "${playlistName}" ${wasUpdated ? 'updated' : 'created'} with ${trackUris.length} tracks!`);

        if (openPlaylistAfterSortEnabled && newPlaylist.uri) { 
            const tempPath = "/library"; 
            Spicetify.Platform.History.push(tempPath);
            await new Promise(resolve => setTimeout(resolve, 600)); 
            const newPlaylistPath = Spicetify.URI.fromString(newPlaylist.uri).toURLPath(true);
            if (newPlaylistPath) Spicetify.Platform.History.push(newPlaylistPath);
        }

    } catch (error) {
        console.error("Error generating Chronological Followed Releases:", error);
        const isNotFound = error.message.includes("No new releases found") || error.message.includes("not following any artists");
        showNotification(error.message, isNotFound ? 'warning' : true);
    } finally {
        if (!isHeadless) {
            resetButtons();
        }
    }
  }

  async function isTrackAvailable(track) {
    if (!track) return false;

    if (track.is_playable === false) {
        return false;
    }

    if (Array.isArray(track.available_markets)) {
        if (track.available_markets.length === 0) {
            return false;
        }

        const userMarket = await userMarketPromise;
        if (userMarket) {
            return track.available_markets.includes(userMarket);
        }
    }

    return true;
  }

  async function getDirectTracksFromGenrePlaylists(playlistsToFetch, numTracksNeeded) {
    const directTracks = [];
    const allSimplifiedTracks = [];

    for (const playlist of playlistsToFetch.values()) {
        try {
            const playlistTracks = await getPlaylistTracks(playlist.uri);
            if (playlistTracks.length > 0) {
                allSimplifiedTracks.push(...playlistTracks);
            }
        } catch (error) {
            console.warn(`Could not fetch tracks for genre playlist ${playlist.genre}:`, error);
        }
    }

    if (allSimplifiedTracks.length === 0) {
        return [];
    }

    const uniqueTracksMap = new Map(allSimplifiedTracks.map(t => [t.uri, t]));
    const shuffledPool = shuffleArray(Array.from(uniqueTracksMap.values()));
    
    let poolIndex = 0;

    while (directTracks.length < numTracksNeeded && poolIndex < shuffledPool.length) {
        const needed = numTracksNeeded - directTracks.length;
        const batchSize = Math.min(needed + 10, 50);
        const batchToTest = shuffledPool.slice(poolIndex, poolIndex + batchSize);
        poolIndex += batchSize;

        if (batchToTest.length === 0) break;

        const trackIds = batchToTest.map(t => t.uri.split(':')[2]);
        
        try {
            let responseTracks = [];

            const fetchBatchInternal = async () => {
                return await Promise.all(trackIds.map(id => fetchInternalTrackMetadata(id)));
            };

            if (isFallbackActive()) {
                responseTracks = await fetchBatchInternal();
            } else {
                try {
                    const fullTrackDetails = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${trackIds.join(',')}`);
                    responseTracks = fullTrackDetails?.tracks || [];
                } catch (error) {
                    if (registerWebApiFailure()) {
                        responseTracks = await fetchBatchInternal();
                    } else {
                        throw error;
                    }
                }
            }

            if (responseTracks) {
                for (const fullTrack of responseTracks) {
                    if (fullTrack && await isTrackAvailable(fullTrack)) {
                        directTracks.push(fullTrack);
                        if (directTracks.length >= numTracksNeeded) {
                            break;
                        }
                    }
                }
            }
        } catch (error) {
            console.warn(`Failed to fetch a batch of full track details for availability check:`, error);
        }
    }

    const flaggedTracks = directTracks.map(track => ({
        ...track,
        sourceInfo: {
            method: 'Direct Pick',
            sourcePlaylist: 'Various Genre Playlists'
        }
    }));
    
    return flaggedTracks;
  }

  async function discoverTracksViaGenreSearch(selectedGenres, numTracksNeeded, existingTracks = []) {
    const allSearchedTracks = new Map();
    const existingTrackUris = new Set(existingTracks.map(t => t.uri));

    for (const genre of selectedGenres) {
        const searchPromises = [];
        for (let offset = 0; offset < 200; offset += 50) {
            const params = new URLSearchParams({
                q: `genre:"${genre}"`,
                type: 'track',
                limit: 50,
                offset: offset
            });
            searchPromises.push(Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?${params.toString()}`));
        }

        const searchResults = await Promise.all(searchPromises);
        for (const result of searchResults) { 
            if (result.tracks?.items) {
                const availabilityChecks = await Promise.all(result.tracks.items.map(track => isTrackAvailable(track)));
                result.tracks.items.forEach((track, index) => {
                    if (availabilityChecks[index] && !allSearchedTracks.has(track.uri)) {
                        allSearchedTracks.set(track.uri, track);
                    }
                });
            }
        }
    }

    if (allSearchedTracks.size === 0) {
        console.warn("Genre search returned no available tracks.");
        return [];
    }
    
    const trackPool = Array.from(allSearchedTracks.values()).filter(track => !existingTrackUris.has(track.uri));

    return shuffleArray(trackPool).slice(0, numTracksNeeded).map(track => ({
        ...track,
        sourceInfo: {
            method: 'Genre Search',
            searchTerm: selectedGenres.join(', ')
        }
    }));
  }

  async function discoverTracksViaMultiSeedRecommendation(playlistsToFetch, numTracksNeeded, existingTracks = []) {
    const existingTrackUris = new Set(existingTracks.map(t => t.uri));
    const recommendationPool = new Map();
    let seedTrackPool = [];

    for (const playlist of playlistsToFetch.values()) {
        try {
            const playlistTracks = await getPlaylistTracks(playlist.uri);
            const availabilityChecks = await Promise.all(playlistTracks.map(track => isTrackAvailable(track)));
            seedTrackPool.push(...playlistTracks.filter((_, index) => availabilityChecks[index]));
        } catch (error) {
            console.warn(`Could not fetch seed tracks from ${playlist.genre}:`, error);
        }
    }
    
    if (seedTrackPool.length < 5) {
        console.warn("Not enough available seed tracks for multi-seed recommendation.");
        return [];
    }

    seedTrackPool = shuffleArray(Array.from(new Map(seedTrackPool.map(t => [t.uri, t])).values()));

    const NUM_RECOMMENDATION_CALLS = 4;
    const recommendationPromises = [];

    for (let i = 0; i < NUM_RECOMMENDATION_CALLS; i++) {
        const seedTracks = seedTrackPool.slice(i * 5, (i * 5) + 5).map(t => t.uri.split(':')[2]);
        if (seedTracks.length === 0) continue;

        const params = new URLSearchParams({
            limit: 50,
            seed_tracks: seedTracks.join(',')
        });
        recommendationPromises.push(Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/recommendations?${params.toString()}`));
    }

    const recommendationResults = await Promise.all(recommendationPromises);
    for (const result of recommendationResults) { 
        if (result.tracks) {
            const availabilityChecks = await Promise.all(result.tracks.map(track => isTrackAvailable(track)));
            result.tracks.forEach((track, index) => {
                if (availabilityChecks[index] && !recommendationPool.has(track.uri)) {
                    recommendationPool.set(track.uri, track);
                }
            });
        }
    }

    const sourceDescription = `Seeded from ${playlistsToFetch.size} playlists like: ${Array.from(playlistsToFetch.values()).slice(0,3).map(p => p.genre).join(', ')}...`;
    const recommendedTracks = Array.from(recommendationPool.values())
        .filter(track => !existingTrackUris.has(track.uri))
        .map(track => ({
            ...track,
            sourceInfo: {
                method: 'Recommendation',
                details: sourceDescription
            }
        }));

    return shuffleArray(recommendedTracks).slice(0, numTracksNeeded);
  }

  async function generateInfiniteVibe(options = {}) {
    const { isHeadless = false } = options;
    
    if (!isHeadless) {
        setButtonProcessing(true);
        mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
        mainButton.style.color = buttonStyles.main.disabledColor;
        mainButton.style.cursor = "default";
        svgElement.style.fill = buttonStyles.main.disabledColor;
        menuButtons.forEach((button) => (button.disabled = true));
        toggleMenu();
        closeAllMenus();
    }

    const updateProgress = (msg) => {
        if (!isHeadless) mainButton.innerText = msg;
    };

    try {
        updateProgress("Seeds...");
        const seeds = [];

        const currentTrack = Spicetify.Player.data?.item;
        if (currentTrack && currentTrack.uri.startsWith('spotify:track:') && !Spicetify.URI.isLocal(currentTrack.uri)) {
            seeds.push({
                name: currentTrack.name,
                artist: currentTrack.artists[0].name,
                source: 'anchor'
            });
        }

        try {
            const topTracks = await getTopItems('tracks', 'short_term', 30);
            if (topTracks && topTracks.length > 0) {
                const shuffledTop = shuffleArray(topTracks).slice(0, 10);
                shuffledTop.forEach(t => seeds.push({
                    name: t.name,
                    artist: t.artists[0].name,
                    source: 'obsession'
                }));
            }
        } catch (e) {
            console.warn("Failed to fetch recent obsessions for Infinite Vibe:", e);
        }

        const allLiked = await getLikedSongs();
        if (allLiked.length > 0) {
            const shuffledLiked = shuffleArray(allLiked).slice(0, 7);
            shuffledLiked.forEach(t => seeds.push({
                name: t.name,
                artist: t.artistName || t.artists[0]?.name,
                source: 'liked'
            }));
        }

        if (seeds.length === 0) {
            throw new Error("Could not generate seeds. Play a song or add liked songs.");
        }

        updateProgress("Echoes...");
        const candidates = new Map(); 

        const seedProcessingPromises = seeds.map(async (seed, index) => {
            const params = new URLSearchParams({
                method: 'track.getsimilar',
                artist: seed.artist,
                track: seed.name,
                limit: '30',
                format: 'json'
            });
            
            try {
                const res = await fetchLfmWithGateway(params);
                if (res.ok) {
                    const data = await res.json();
                    const similarTracks = data.similartracks?.track || [];
                    const seedArtistLower = seed.artist.toLowerCase().trim();
                    
                    similarTracks.forEach(simTrack => {
                        const matchScore = parseFloat(simTrack.match);
                        if (matchScore < 0.15) return;

                        const sArtistName = simTrack.artist.name;
                        const sArtistLower = sArtistName.toLowerCase().trim();

                        if (sArtistLower.includes(seedArtistLower) || seedArtistLower.includes(sArtistLower)) {
                            return;
                        }

                        const sName = simTrack.name;
                        const key = `${sArtistLower}|${sName.toLowerCase().trim()}`;
                        
                        if (!candidates.has(key)) {
                            candidates.set(key, {
                                score: 0,
                                sources: new Set(),
                                trackName: sName,
                                artistName: sArtistName
                            });
                        }
                        
                        const candidate = candidates.get(key);
                        candidate.score += 1;
                        candidate.sources.add(`seed-${index}`); 
                    });
                }
            } catch (e) {
                console.warn(`Failed to get similar tracks for seed: ${seed.name}`, e);
            }
        });

        await Promise.all(seedProcessingPromises);

        const scoredCandidates = [];
        const seedKeys = new Set(seeds.map(s => `${s.artist.toLowerCase().trim()}|${s.name.toLowerCase().trim()}`));

        candidates.forEach((cand, key) => {
            if (seedKeys.has(key)) return;

            if (cand.sources.size > 1) {
                cand.score += 50;
            }
            scoredCandidates.push(cand);
        });

        scoredCandidates.sort((a, b) => b.score - a.score);
        const topCandidates = scoredCandidates.slice(0, 100);

        if (topCandidates.length === 0) {
            throw new Error("No similar tracks found above threshold.");
        }

        updateProgress("Resolving...");
        
        const mockLocalTracks = topCandidates.map(c => ({
            uri: "spotify:local:::::", 
            name: c.trackName,
            artistName: c.artistName
        }));

        const { convertedTracks: resolvedSpotifyTracks } = await convertLocalTracksToSpotify(
            mockLocalTracks,
        );

        updateProgress("Verifying...");
        const availableTracks = [];
        for (const t of resolvedSpotifyTracks) {
            if (await isTrackAvailable(t)) availableTracks.push(t);
        }

        updateProgress("Filtering...");
        const likedUris = new Set(allLiked.map(s => s.uri));
        const likedTrackIds = allLiked.map(s => s.uri.split(':')[2]).filter(Boolean);
        const cachedLikedMetadata = await idb.getMany('trackMetadata', likedTrackIds, CACHE_EXPIRE_METADATA);
        const likedIsrcs = new Set();
        cachedLikedMetadata.forEach(meta => {
            if (meta?.external_ids?.isrc) likedIsrcs.add(meta.external_ids.isrc);
        });

        const candidatesForMeta = availableTracks.map(t => ({
            uri: t.uri,
            id: t.id || t.uri.split(':')[2],
            track: t.track || t, 
            name: t.name,
            artistName: t.artistName || (t.artists && t.artists[0]?.name) || "",
            allArtists: t.allArtists || (t.artists && t.artists.map(a => a.name).join(", ")),
            artists: t.artists
        }));

        const candidatesWithMeta = await refreshTrackAlbumInfo(candidatesForMeta, () => {});
        
        const likedFilteredPool = candidatesWithMeta.filter(c => {
            if (likedUris.has(c.uri)) return false;
            const isrc = c.track?.external_ids?.isrc;
            if (isrc && likedIsrcs.has(isrc)) return false;
            return true;
        });

        const albumSeen = new Set();
        const albumFilteredPool = [];
        
        for (const track of likedFilteredPool) {
            const albumId = track.albumId || track.track?.album?.id;
            if (albumId && !albumSeen.has(albumId)) {
                albumSeen.add(albumId);
                albumFilteredPool.push(track);
            } else if (!albumId) {
                const albumName = track.albumName || track.track?.album?.name;
                if (albumName && !albumSeen.has(albumName)) {
                    albumSeen.add(albumName);
                    albumFilteredPool.push(track);
                } else if (!albumName) {
                    albumFilteredPool.push(track);
                }
            }
        }

        updateProgress("History...");
        let finalPoolTracks = albumFilteredPool;
        
        if (loadLastFmUsername()) {
             const poolWithScrobbles = await processBatchesWithDelay(
                albumFilteredPool, 
                50, 
                200, 
                (p) => { if(!isHeadless) mainButton.innerText = `History ${p}%`; },
                getTrackDetailsWithPersonalScrobbles
            );

            const unlistenedTracks = poolWithScrobbles.filter(t => !t.personalScrobbles || t.personalScrobbles === 0);
            
            if (unlistenedTracks.length < 50) {
                const listenedTracks = poolWithScrobbles.filter(t => t.personalScrobbles > 0);
                const needed = 50 - unlistenedTracks.length;
                const backfill = listenedTracks.slice(0, needed);
                finalPoolTracks = [...unlistenedTracks, ...backfill];
            } else {
                finalPoolTracks = unlistenedTracks;
            }
        }

        updateProgress("Sequencing...");
        const top50 = finalPoolTracks.slice(0, 50);
        
        if (top50.length === 0) {
            throw new Error("No available tracks found after filtering.");
        }

        const trackIds = top50.map(t => t.uri.split(':')[2]);
        const stats = await getBatchTrackStats(trackIds);
        
        const tracksWithFeatures = top50.map(t => {
            const id = t.uri.split(':')[2];
            return { ...t, features: stats[id] };
        });

        const validForWave = tracksWithFeatures.filter(t => t.features && t.features.energy != null);
        const others = tracksWithFeatures.filter(t => !t.features || t.features.energy == null);

        const sorted = await energyWaveSort(validForWave, 'discovery');
        const finalTracks = [...sorted, ...others];
        
        const trackUris = finalTracks.map(t => t.uri);

        const playlistName = "Infinite Vibe";
        const playlistDescription = "A continuous mood generated from recent obsessions and library deep cuts. Created by Sort-Play.";

        updateProgress("Creating...");
        const { playlist: newPlaylist, wasUpdated } = await getOrCreateDedicatedPlaylist('infiniteVibe', playlistName, playlistDescription);

        updateProgress("Saving...");
        if (wasUpdated) {
            await replacePlaylistTracks(newPlaylist.id, trackUris);
        } else {
            await addTracksToPlaylist(newPlaylist.id, trackUris);
        }

        showNotification(`Playlist "${playlistName}" ${wasUpdated ? 'updated' : 'created'} with ${trackUris.length} tracks!`);
        await navigateToPlaylist(newPlaylist);

    } catch (error) {
        console.error("Error generating Infinite Vibe:", error);
        showNotification(`Infinite Vibe failed: ${error.message}`, true);
    } finally {
        if (!isHeadless) {
            resetButtons();
        }
    }
  }

  async function generateNeighborsMix(options = {}) {
    const { isHeadless = false } = options;
    
    const username = loadLastFmUsername();
    if (!username) {
        if (!isHeadless) showNotification("Last.fm username not set. Please set it in Settings.", true);
        return;
    }

    if (!isHeadless) {
        setButtonProcessing(true);
        mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
        mainButton.style.color = buttonStyles.main.disabledColor;
        mainButton.style.cursor = "default";
        svgElement.style.fill = buttonStyles.main.disabledColor;
        menuButtons.forEach((button) => (button.disabled = true));
        toggleMenu();
        closeAllMenus();
    }

    const updateProgress = (msg) => {
        if (!isHeadless) mainButton.innerText = msg;
    };

    const parseObsessionsFromDoc = (doc) => {
        const items = doc.querySelectorAll('.obsession-history-item');
        return Array.from(items).map(item => {
            const trackName = item.querySelector('.obsession-history-item-heading')?.textContent?.trim();
            const artistName = item.querySelector('.obsession-history-item-artist span a')?.textContent?.trim() || 
                               item.querySelector('.obsession-history-item-artist')?.textContent?.trim();
            
            if (trackName && artistName) {
                return { name: trackName, artist: { name: artistName } }; 
            }
            return null;
        }).filter(Boolean);
    };

    const scrapeNeighborObsessions = async (neighborName) => {
        try {
            const gatewayUrlBase = LFM_GATEWAY_URL;
            const baseUrl = `https://www.last.fm/user/${neighborName}/obsessions`;
            
            const response = await fetch(`${gatewayUrlBase}${encodeURIComponent(baseUrl)}`);
            if (!response.ok) return [];
            
            const html = await response.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, "text/html");

            let allTracks = parseObsessionsFromDoc(doc);

            const paginationLinks = doc.querySelectorAll('.pagination-page a');
            let totalPages = 1;
            if (paginationLinks.length > 0) {
                const lastPageText = paginationLinks[paginationLinks.length - 1].textContent.trim();
                totalPages = parseInt(lastPageText) || 1;
            }

            if (totalPages > 1) {
                const pagesToFetch = new Set();
                const maxPagePool = Math.min(totalPages, 15);
                
                while (pagesToFetch.size < 3 && pagesToFetch.size < maxPagePool - 1) {
                    const p = Math.floor(Math.random() * (maxPagePool - 1)) + 2; 
                    pagesToFetch.add(p);
                }

                const pagePromises = Array.from(pagesToFetch).map(async (pageNum) => {
                    const pageUrl = `${baseUrl}?page=${pageNum}`;
                    try {
                        const pRes = await fetch(`${gatewayUrlBase}${encodeURIComponent(pageUrl)}`);
                        if (pRes.ok) {
                            const pHtml = await pRes.text();
                            const pDoc = new DOMParser().parseFromString(pHtml, "text/html");
                            return parseObsessionsFromDoc(pDoc);
                        }
                    } catch (e) { return []; }
                    return [];
                });

                const extraTracks = await Promise.all(pagePromises);
                extraTracks.forEach(tracks => allTracks.push(...tracks));
            }

            return shuffleArray(allTracks).slice(0, 20);

        } catch (e) {
            console.warn(`[Sort-Play] Failed to scrape obsessions for ${neighborName}`, e);
            return [];
        }
    };

    try {
        updateProgress("Neighbors...");

        const targetUrl = `https://www.last.fm/user/${username}/neighbours`;
        const gatewayUrl = `${LFM_GATEWAY_URL}${encodeURIComponent(targetUrl)}`;
        
        let candidates = [];
        try {
            const response = await fetch(gatewayUrl);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const htmlText = await response.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlText, "text/html");
            const neighborNodes = doc.querySelectorAll('.user-list-item .user-list-name a');
            
            candidates = Array.from(neighborNodes).map(node => ({
                name: node.textContent.trim()
            }));
        } catch (scrapeError) {
            throw new Error(`Failed to scrape neighbors: ${scrapeError.message}`);
        }

        if (candidates.length === 0) {
             throw new Error("No neighbors found. Last.fm might not have calculated them yet.");
        }
            
        candidates = shuffleArray(candidates);
        const activeNeighbors = candidates.slice(0, 20);

        if (activeNeighbors.length === 0) {
            throw new Error("Could not find any neighbors.");
        }

        updateProgress("Scanning...");
        const trackScoreMap = new Map();

        const processTrack = (track, points, neighborName) => {
            if (!track || !track.name || !track.artist) return;
            const artistName = track.artist.name || track.artist['#text']; 
            const trackName = track.name;
            if (!artistName || !trackName) return;

            const key = `${artistName.toLowerCase().trim()}|${trackName.toLowerCase().trim()}`;
            
            if (!trackScoreMap.has(key)) {
                trackScoreMap.set(key, {
                    artist: artistName,
                    track: trackName,
                    score: 0,
                    neighbors: new Set()
                });
            }
            
            const entry = trackScoreMap.get(key);
            entry.score += points;
            entry.neighbors.add(neighborName);
        };

        let neighborIndex = 0;
        const neighborPromises = activeNeighbors.map(async (neighbor) => {
            const name = neighbor.name;
            
            const p1 = fetchLfmWithGateway(new URLSearchParams({ method: 'user.gettoptracks', user: name, period: '7day', limit: '20', format: 'json' }));
            const p2 = fetchLfmWithGateway(new URLSearchParams({ method: 'user.gettoptracks', user: name, period: 'overall', limit: '20', format: 'json' }));
            const p3 = fetchLfmWithGateway(new URLSearchParams({ method: 'user.getlovedtracks', user: name, limit: '20', format: 'json' }));
            
            const p4 = scrapeNeighborObsessions(name);

            const [r1, r2, r3, obsessions] = await Promise.all([p1, p2, p3, p4]);
            
            const d1 = r1.ok ? await r1.json() : {};
            const d2 = r2.ok ? await r2.json() : {};
            const d3 = r3.ok ? await r3.json() : {};

            const tracks7day = d1.toptracks?.track || [];
            const tracksOverall = d2.toptracks?.track || [];
            const tracksLoved = d3.lovedtracks?.track || [];

            (Array.isArray(tracks7day) ? tracks7day : []).forEach(t => processTrack(t, 15, name));
            (Array.isArray(tracksOverall) ? tracksOverall : []).forEach(t => processTrack(t, 15, name));
            (Array.isArray(tracksLoved) ? tracksLoved : []).forEach(t => processTrack(t, 20, name));
            obsessions.forEach(t => processTrack(t, 25, name));

            neighborIndex++;
            updateProgress(`Scan ${Math.round((neighborIndex / activeNeighbors.length) * 100)}%`);
        });

        await Promise.all(neighborPromises);

        trackScoreMap.forEach(entry => {
            if (entry.neighbors.size > 1) {
                entry.score = entry.score * 1.5;
            }
        });

        const sortedRawCandidates = Array.from(trackScoreMap.values())
            .sort((a, b) => b.score - a.score);

        const finalCandidates = [];
        const artistCounts = new Map();
        const MAX_TRACKS_PER_ARTIST = 2;
        const TARGET_CANDIDATE_COUNT = 150;

        for (const candidate of sortedRawCandidates) {
            if (finalCandidates.length >= TARGET_CANDIDATE_COUNT) break;

            const artistKey = candidate.artist.toLowerCase().trim();
            const currentCount = artistCounts.get(artistKey) || 0;

            if (currentCount < MAX_TRACKS_PER_ARTIST) {
                finalCandidates.push(candidate);
                artistCounts.set(artistKey, currentCount + 1);
            }
        }

        updateProgress("Resolving...");
        
        const mockLocalTracks = finalCandidates.map(c => ({
            uri: "spotify:local:::::",
            name: c.track,
            artistName: c.artist
        }));

        const { convertedTracks: resolvedSpotifyTracks } = await convertLocalTracksToSpotify(
            mockLocalTracks,
        );

        updateProgress("Verifying...");
        const availableTracks = [];
        for (const t of resolvedSpotifyTracks) {
            if (await isTrackAvailable(t)) availableTracks.push(t);
        }

        updateProgress("Filtering...");
        const likedSongs = await getLikedSongs();
        const likedUris = new Set(likedSongs.map(s => s.uri));
        
        const likedTrackIds = likedSongs.map(s => s.uri.split(':')[2]).filter(Boolean);
        const cachedLikedMetadata = await idb.getMany('trackMetadata', likedTrackIds, CACHE_EXPIRE_METADATA);
        const likedIsrcs = new Set();
        cachedLikedMetadata.forEach(meta => {
            if (meta?.external_ids?.isrc) likedIsrcs.add(meta.external_ids.isrc);
        });

        const candidatesForMeta = availableTracks.map(t => ({
            uri: t.uri,
            id: t.id || t.uri.split(':')[2],
            track: t.track || t, 
            name: t.name,
            artistName: t.artistName || (t.artists && t.artists[0]?.name) || "",
            allArtists: t.allArtists || (t.artists && t.artists.map(a => a.name).join(", ")),
            artists: t.artists
        }));

        const candidatesWithMeta = await refreshTrackAlbumInfo(candidatesForMeta, () => {});
        
        const likedFilteredPool = candidatesWithMeta.filter(c => {
            if (likedUris.has(c.uri)) return false;
            const isrc = c.track?.external_ids?.isrc;
            if (isrc && likedIsrcs.has(isrc)) return false;
            return true;
        });

        updateProgress("History...");
        const poolWithScrobbles = await processBatchesWithDelay(
            likedFilteredPool, 
            50, 
            200, 
            (p) => { if(!isHeadless) mainButton.innerText = `History ${p}%`; },
            getTrackDetailsWithPersonalScrobbles
        );

        const unlistenedTracks = poolWithScrobbles.filter(t => !t.personalScrobbles || t.personalScrobbles === 0);
        let finalPoolTracks = unlistenedTracks;

        if (unlistenedTracks.length < 50) {
            const listenedTracks = poolWithScrobbles.filter(t => t.personalScrobbles > 0);
            const needed = 50 - unlistenedTracks.length;
            
            const backfill = listenedTracks.slice(0, needed);
            finalPoolTracks = [...unlistenedTracks, ...backfill];
            
            if (backfill.length > 0 && !isHeadless) {
                console.log(`[Sort-Play] Backfilled Neighbors Mix with ${backfill.length} listened tracks to prevent empty playlist.`);
            }
        }

        updateProgress("Sequencing...");
        const top50 = finalPoolTracks.slice(0, 50);
        
        if (top50.length === 0) {
            throw new Error("No available tracks found after filtering.");
        }

        const trackIds = top50.map(t => t.uri.split(':')[2]);
        const stats = await getBatchTrackStats(trackIds);
        
        const tracksWithFeatures = top50.map(t => {
            const id = t.uri.split(':')[2];
            return {
                ...t,
                features: stats[id]
            };
        });

        const validForWave = tracksWithFeatures.filter(t => t.features && t.features.energy != null);
        const others = tracksWithFeatures.filter(t => !t.features || t.features.energy == null);

        const sorted = await energyWaveSort(validForWave);
        const finalTracks = [...sorted, ...others];
        
        const trackUris = finalTracks.map(t => t.uri);

        const playlistName = "Neighbors Mix";
        const playlistDescription = "A balanced mix of current obsessions, trends, and favorites from your Last.fm neighbors. Filtered for discovery. Created by Sort-Play.";

        updateProgress("Creating...");
        const { playlist: newPlaylist, wasUpdated } = await getOrCreateDedicatedPlaylist('neighborsMix', playlistName, playlistDescription);

        updateProgress("Saving...");
        if (wasUpdated) {
            await replacePlaylistTracks(newPlaylist.id, trackUris);
        } else {
            await addTracksToPlaylist(newPlaylist.id, trackUris);
        }

        showNotification(`Playlist "${playlistName}" ${wasUpdated ? 'updated' : 'created'} with ${trackUris.length} tracks!`);
        await navigateToPlaylist(newPlaylist);

    } catch (error) {
        console.error("Error generating Neighbors Mix:", error);
        showNotification(`Neighbors Mix failed: ${error.message}`, true);
    } finally {
        if (!isHeadless) {
            resetButtons();
        }
    }
  }

  async function generateGenreTreePlaylist(selectedGenres) {
    setButtonProcessing(true);
    mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
    mainButton.style.color = buttonStyles.main.disabledColor;
    mainButton.style.cursor = "default";
    svgElement.style.fill = buttonStyles.main.disabledColor;
    menuButtons.forEach((button) => (button.disabled = true));
    toggleMenu();
    closeAllMenus();

    try {
        mainButton.innerText = "Finding...";
        if (!genrePlaylistsCache) {
            genrePlaylistsCache = await getGenreMapping();
        }

        const playlistsToFetch = new Map();
        const numPlaylistsPerGenre = Math.max(5, Math.floor(20 / selectedGenres.length));

        for (const selectedGenre of selectedGenres) {
            const isMainGenre = !!GENRE_MAPPINGS[selectedGenre];
            const allGenreTerms = isMainGenre 
                ? new Set([selectedGenre, ...(GENRE_MAPPINGS[selectedGenre] || [])])
                : new Set([selectedGenre]);
            
            const matchingPlaylists = genrePlaylistsCache.filter(p => 
                [...allGenreTerms].some(term => {
                    const escapedTerm = escapeRegExp(term);
                    const regex = new RegExp(`\\b${escapedTerm}\\b`, 'i');
                    return regex.test(p.genre);
                })
            );

            const shuffled = shuffleArray(matchingPlaylists);
            shuffled.slice(0, numPlaylistsPerGenre).forEach(p => playlistsToFetch.set(p.uri, p));
        }

        if (playlistsToFetch.size === 0) {
            throw new Error("Could not find any genre playlists for your selection.");
        }

        const tracksPerPart = Math.ceil(discoveryPlaylistSize / 3);

        mainButton.innerText = "Fetching...";
        const directTracks = await getDirectTracksFromGenrePlaylists(playlistsToFetch, tracksPerPart);

        mainButton.innerText = "Discover...";
        const [searchedTracks, recommendedTracks] = await Promise.all([
            discoverTracksViaGenreSearch(selectedGenres, tracksPerPart, directTracks),
            discoverTracksViaMultiSeedRecommendation(playlistsToFetch, tracksPerPart, directTracks)
        ]);

        mainButton.innerText = "Combining...";
        const allTracks = [...directTracks, ...searchedTracks, ...recommendedTracks];

        const uniqueFinalTracks = Array.from(new Map(allTracks.map(t => [t.uri, t])).values());
        const finalSizedTracks = shuffleArray(uniqueFinalTracks).slice(0, discoveryPlaylistSize);

        mainButton.innerText = "Sorting...";
        const { trackGenreMap } = await fetchAllTrackGenres(finalSizedTracks);
        const sortedTracks = interleaveSortByGenre(finalSizedTracks, trackGenreMap);

        const trackUris = sortedTracks.map(t => t.uri);
        const playlistName = `Genre Explorer: ${selectedGenres.slice(0, 3).join(', ')}${selectedGenres.length > 3 ? '...' : ''}`;
        
        let genreListString = selectedGenres.join(', ');
        const maxGenreListLength = 240;
        if (genreListString.length > maxGenreListLength) {
            genreListString = genreListString.substring(0, maxGenreListLength) + "...";
        }
        const playlistDescription = `A playlist exploring the genres: ${genreListString}. Created by Sort-Play.`;

        mainButton.innerText = "Creating...";
        const { playlist: newPlaylist, wasUpdated } = await getOrCreateDedicatedPlaylist('genreTreeExplorer', playlistName, playlistDescription);

        mainButton.innerText = "Saving...";
        if (wasUpdated) {
            await replacePlaylistTracks(newPlaylist.id, trackUris);
        } else {
            await addTracksToPlaylist(newPlaylist.id, trackUris);
        }

        showNotification(`Playlist "${playlistName}" ${wasUpdated ? 'updated' : 'created'}!`);
        await navigateToPlaylist(newPlaylist);

    } catch (error) {
        console.error("Error in Genre Tree Explorer:", error);
        showNotification(error.message, true);
    } finally {
        resetButtons();
    }
  }

  async function generateRandomGenrePlaylist(options = {}) {
    const { isHeadless = false } = options;
    if (!isHeadless) {
        setButtonProcessing(true);
        mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
        mainButton.style.color = buttonStyles.main.disabledColor;
        mainButton.style.cursor = "default";
        svgElement.style.fill = buttonStyles.main.disabledColor;
        menuButtons.forEach((button) => (button.disabled = true));
        toggleMenu();
        closeAllMenus();
    }

    try {
        if (!isHeadless) mainButton.innerText = "Finding...";
        if (!genrePlaylistsCache) {
            genrePlaylistsCache = await getGenreMapping();
        }

        const allAvailableGenres = [...new Set(genrePlaylistsCache.map(p => p.genre))];
        if (allAvailableGenres.length < RANDOM_GENRE_SELECTION_SIZE) {
            throw new Error("Not enough genres in the database to create a random playlist.");
        }

        let genreHistory = JSON.parse(localStorage.getItem(STORAGE_KEY_RANDOM_GENRE_HISTORY) || '[]');
        let availablePool = allAvailableGenres.filter(genre => !genreHistory.includes(genre));

        if (availablePool.length < RANDOM_GENRE_SELECTION_SIZE) {
            genreHistory = [];
            availablePool = allAvailableGenres;
        }

        const selectedGenres = shuffleArray(availablePool).slice(0, RANDOM_GENRE_SELECTION_SIZE);

        genreHistory.push(...selectedGenres);
        if (genreHistory.length > RANDOM_GENRE_HISTORY_SIZE) {
            genreHistory = genreHistory.slice(genreHistory.length - RANDOM_GENRE_HISTORY_SIZE);
        }
        localStorage.setItem(STORAGE_KEY_RANDOM_GENRE_HISTORY, JSON.stringify(genreHistory));

        const playlistsToFetch = new Map();
        for (const selectedGenre of selectedGenres) {
            const matchingPlaylists = genrePlaylistsCache.filter(p => p.genre === selectedGenre);
            if (matchingPlaylists.length > 0) {
                const chosenPlaylist = matchingPlaylists[Math.floor(Math.random() * matchingPlaylists.length)];
                playlistsToFetch.set(chosenPlaylist.uri, chosenPlaylist);
            }
        }

        if (playlistsToFetch.size === 0) {
            throw new Error("Could not find any genre playlists for the random selection.");
        }

        const tracksPerPart = Math.ceil(discoveryPlaylistSize / 3);

        if (!isHeadless) mainButton.innerText = "Fetching...";
        const directTracks = await getDirectTracksFromGenrePlaylists(playlistsToFetch, tracksPerPart);

        if (!isHeadless) mainButton.innerText = "Discover...";
        const [searchedTracks, recommendedTracks] = await Promise.all([
            discoverTracksViaGenreSearch(selectedGenres, tracksPerPart, directTracks),
            discoverTracksViaMultiSeedRecommendation(playlistsToFetch, tracksPerPart, directTracks)
        ]);

        if (!isHeadless) mainButton.innerText = "Combining...";
        const allTracks = [...directTracks, ...searchedTracks, ...recommendedTracks];
        
        const uniqueFinalTracks = Array.from(new Map(allTracks.map(t => [t.uri, t])).values());
        const finalSizedTracks = shuffleArray(uniqueFinalTracks).slice(0, discoveryPlaylistSize);

        if (!isHeadless) mainButton.innerText = "Sorting...";
        const { trackGenreMap } = await fetchAllTrackGenres(finalSizedTracks);
        const sortedTracks = interleaveSortByGenre(finalSizedTracks, trackGenreMap);

        const trackUris = sortedTracks.map(t => t.uri);
        const playlistName = `Random Genre Explorer`;
        
        let genreListString = selectedGenres.slice(0, 10).join(', ');
        const maxGenreListLength = 240;
        if (genreListString.length > maxGenreListLength) {
            genreListString = genreListString.substring(0, maxGenreListLength) + "...";
        }
        const playlistDescription = `A playlist exploring a random mix of genres including: ${genreListString}. Created by Sort-Play.`;

        if (!isHeadless) mainButton.innerText = "Creating...";
        const { playlist: newPlaylist, wasUpdated } = await getOrCreateDedicatedPlaylist('randomGenreExplorer', playlistName, playlistDescription);

        if (!isHeadless) mainButton.innerText = "Saving...";
        if (wasUpdated) {
            await replacePlaylistTracks(newPlaylist.id, trackUris);
        } else {
            await addTracksToPlaylist(newPlaylist.id, trackUris);
        }

        showNotification(`Playlist "${playlistName}" ${wasUpdated ? 'updated' : 'created'}!`);
        await navigateToPlaylist(newPlaylist);

    } catch (error) {
        console.error("Error in Random Genre Explorer:", error);
        showNotification(error.message, true);
    } finally {
        if (!isHeadless) {
            resetButtons();
        }
    }
  }

  function interleaveSortByGenre(tracks, trackGenreMap) {
    if (!tracks || tracks.length === 0) return [];

    const genreToTracksMap = new Map();
    const trackToGenresMap = new Map();

    tracks.forEach(track => {
        const genres = trackGenreMap.get(track.uri);
        if (genres && genres.length > 0) {
            const genreNames = genres.map(g => g.name);
            trackToGenresMap.set(track.uri, genreNames);

            genreNames.forEach(genreName => {
                if (!genreToTracksMap.has(genreName)) {
                    genreToTracksMap.set(genreName, []);
                }
                genreToTracksMap.get(genreName).push(track);
            });
        } else {
            const NO_GENRE_KEY = '__no_genre__';
            if (!genreToTracksMap.has(NO_GENRE_KEY)) {
                genreToTracksMap.set(NO_GENRE_KEY, []);
            }
            genreToTracksMap.get(NO_GENRE_KEY).push(track);
            trackToGenresMap.set(track.uri, [NO_GENRE_KEY]);
        }
    });

    const sortedTracks = [];
    const remainingTracksUris = new Set(tracks.map(t => t.uri));
    let lastGenre = null;

    while (remainingTracksUris.size > 0) {
        let availableGenres = [...genreToTracksMap.keys()].filter(g => genreToTracksMap.get(g).length > 0);
        
        if (availableGenres.length > 1 && lastGenre && availableGenres.includes(lastGenre)) {
            availableGenres = availableGenres.filter(g => g !== lastGenre);
        }

        if (availableGenres.length === 0) {
            availableGenres = [...genreToTracksMap.keys()].filter(g => genreToTracksMap.get(g).length > 0);
            if (availableGenres.length === 0) break;
        }

        const chosenGenre = availableGenres[Math.floor(Math.random() * availableGenres.length)];
        const tracksInGenre = genreToTracksMap.get(chosenGenre);
        const chosenTrack = tracksInGenre.splice(Math.floor(Math.random() * tracksInGenre.length), 1)[0];

        sortedTracks.push(chosenTrack);
        remainingTracksUris.delete(chosenTrack.uri);
        lastGenre = chosenGenre;

        const allGenresOfChosenTrack = trackToGenresMap.get(chosenTrack.uri);
        allGenresOfChosenTrack.forEach(genreName => {
            if (genreToTracksMap.has(genreName)) {
                const list = genreToTracksMap.get(genreName);
                const index = list.findIndex(t => t.uri === chosenTrack.uri);
                if (index > -1) {
                    list.splice(index, 1);
                }
            }
        });
    }

    return sortedTracks;
  }

  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  async function showGenreTreeExplorerModal() {
    const overlay = document.createElement("div");
    overlay.id = "sort-play-genre-tree-overlay";
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        z-index: 2002;
        display: flex; justify-content: center; align-items: center;
    `;

    const modalContainer = document.createElement("div");
    modalContainer.className = "main-embedWidgetGenerator-container sort-play-font-scope";
    modalContainer.style.cssText = `
        z-index: 2003;
        width: 620px !important;
        display: flex;
        flex-direction: column;
        border-radius: 30px;
    `;
    const shadowRoot = modalContainer.attachShadow({ mode: 'open' });
    modalContainer.querySelector = (sel) => shadowRoot.querySelector(sel);
    modalContainer.querySelectorAll = (sel) => shadowRoot.querySelectorAll(sel);

    if (!genrePlaylistsCache) {
        try {
            const response = await fetch(GENRE_PLAYLISTS_URL);
            genrePlaylistsCache = await response.json();
        } catch (e) {
            console.error("Sort-Play: Failed to fetch genre database for sorting.", e);
            showNotification("Could not fetch genre database.", true);
            genrePlaylistsCache = []; 
        }
    }
    
    const genreRankMap = new Map();
    genrePlaylistsCache.forEach((p, index) => {
        const lowerGenre = p.genre.toLowerCase();
        if (!genreRankMap.has(lowerGenre)) {
            genreRankMap.set(lowerGenre, index);
        }
    });

    const mainGenreList = Object.keys(GENRE_MAPPINGS);
    const mainGenreRankCache = new Map();

    const getMainGenreRank = (mainGenre) => {
        if (mainGenreRankCache.has(mainGenre)) {
            return mainGenreRankCache.get(mainGenre);
        }

        let rank = genreRankMap.get(mainGenre.toLowerCase());
        if (rank !== undefined) {
            mainGenreRankCache.set(mainGenre, rank);
            return rank;
        }

        const subGenres = GENRE_MAPPINGS[mainGenre] || [];
        let minRank = Infinity;
        for (const subGenre of subGenres) {
            const subGenreRank = genreRankMap.get(subGenre.toLowerCase());
            if (subGenreRank !== undefined) {
                minRank = Math.min(minRank, subGenreRank);
            }
        }

        mainGenreRankCache.set(mainGenre, minRank);
        return minRank;
    };

    const priorityGenres = ["pop", "rock", "hip hop", "rap", "jazz", "electronic", "r&b", "country", "classical", "metal", "folk", "blues", "reggae", "punk"];

    mainGenreList.sort((a, b) => {
        const aLower = a.toLowerCase();
        const bLower = b.toLowerCase();
        const isAPriority = priorityGenres.includes(aLower);
        const isBPriority = priorityGenres.includes(bLower);

        if (isAPriority && !isBPriority) return -1;
        if (!isAPriority && isBPriority) return 1;
        if (isAPriority && isBPriority) {
            return priorityGenres.indexOf(aLower) - priorityGenres.indexOf(bLower);
        }

        const rankA = getMainGenreRank(a);
        const rankB = getMainGenreRank(b);

        if (rankA !== Infinity && rankB === Infinity) return -1;
        if (rankA === Infinity && rankB !== Infinity) return 1;
        
        if (rankA !== rankB) {
            return rankA - rankB;
        }

        return a.localeCompare(b);
    });


    let selectedMainGenres = [];
    let userAddedGenres = new Set();
    let selectedUserGenres = new Set();

    const savedUserGenres = localStorage.getItem(STORAGE_KEY_USER_ADDED_GENRES);
    if (savedUserGenres) {
        try {
            userAddedGenres = new Set(JSON.parse(savedUserGenres));
        } catch (e) {
            console.error("Sort-Play: Failed to parse user-added genres.", e);
            userAddedGenres = new Set();
        }
    }

    const saveUserGenres = () => {
        localStorage.setItem(STORAGE_KEY_USER_ADDED_GENRES, JSON.stringify(Array.from(userAddedGenres)));
    };

    shadowRoot.innerHTML = `
      <style>
        :host { font-family: 'SpotifyMixUI', sans-serif !important; color: #fff; }
        *, button, input, select, textarea { box-sizing: border-box; font-family: 'SpotifyMixUI', sans-serif !important; }
        h1 { margin: 0; line-height: normal; }
        .genre-tree-modal .genre-container { max-height: 23vh; overflow-y: auto; background-color: #1e1e1e; border-radius: 20px; padding: 15px 10px; margin-top: 15px; scrollbar-width: thin; scrollbar-color: #3b3b3b transparent; }
        .genre-tree-modal .genre-container::-webkit-scrollbar { width: 6px; }
        .genre-tree-modal .genre-container::-webkit-scrollbar-track { background: transparent; }
        .genre-tree-modal .genre-container::-webkit-scrollbar-thumb { background-color: #535353; border-radius: 3px; }
        .genre-tree-modal .user-added-container { margin-top: 0; max-height: 12vh; margin-bottom: 15px; margin-top: 15px; }
        .genre-tree-modal .genre-button { display: inline-flex; align-items: center; padding: 6px 16px; margin: 4px; border-radius: 20px; border: none; cursor: pointer; background-color: #343434; color: white; font-weight: 500; font-size: 14px; transition: background-color 0.2s ease; }
        .genre-tree-modal .genre-button.selected { background-color: #1ED760; color: black; }
        .genre-tree-modal .user-genre-remove { margin-left: 8px; font-size: 16px; font-weight: bold; line-height: 1; opacity: 0.7; }
        .genre-tree-modal .user-genre-remove:hover { opacity: 1; }
        .genre-tree-modal .search-bar-wrapper { position: relative; display: flex; align-items: center; }
        .genre-tree-modal .search-bar { width: 100%; padding: 10px 45px 10px 15px; border-radius: 20px; border: 1px solid #282828; background: #282828; color: white; }
        .genre-tree-modal .add-genre-button { position: absolute; right: 5px; top: 5px; bottom: 5px; width: 50px; height: 30px; background-color: #1ED760; color: black; border: none; border-radius: 20px; font-size: 24px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; line-height: 1; }
        .genre-tree-modal .add-genre-button:hover { background-color: #3BE377; }
        .genre-tree-modal #genre-add-error { color: #f15e6c; font-size: 13px; margin-top: 8px; text-align: center; display: none; }
        .genre-tree-modal .main-button-primary { background-color: #1ED760; color: black; transition: background-color 0.1s ease;}
        .genre-tree-modal .main-button-primary:hover { background-color: #3BE377; }
        .genre-tree-modal .genre-section-header { color: #b3b3b3; font-size: 14px; font-weight: bold; margin-top: 15px; margin-bottom: -5px; padding-left: 10px; }
        .main-trackCreditsModal-closeBtn { background: transparent; border: 0; padding: 0; color: #b3b3b3; cursor: pointer; transition: color 0.2s ease; }
        .main-trackCreditsModal-closeBtn:hover { color: #ffffff; }
        .main-buttons-button.main-button-primary { background-color: #1ED760; color: black; transition: background-color 0.1s ease;}
        .main-buttons-button.main-button-primary:hover { background-color: #3BE377; }
      </style>
      <div class="main-trackCreditsModal-header" style="display: flex; justify-content: space-between; align-items: center;">
          <h1 class="main-trackCreditsModal-title"><span style='font-size: 25px;'>Genre Tree Explorer</span></h1>
          <button id="closeGenreTreeModal" aria-label="Close" class="main-trackCreditsModal-closeBtn">
            <svg width="18" height="18" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                <title>Close</title>
                <path d="M31.098 29.794L16.955 15.65 31.097 1.51 29.683.093 15.54 14.237 1.4.094-.016 1.508 14.126 15.65-.016 29.795l1.414 1.414L15.54 17.065l14.144 14.143" fill="currentColor" fill-rule="evenodd"></path>
            </svg>
          </button>
      </div>
      <div class="main-trackCreditsModal-mainSection genre-tree-modal" style="padding: 22px 47px 20px !important; max-height: 70vh; flex-grow: 1;">
        <p style="color: #c1c1c1; font-size: 16px; margin-bottom: 15px;">Select genres or add your own to start exploring.</p>
        <div class="search-bar-wrapper">
            <input type="text" id="genre-search-bar" class="search-bar" placeholder="Search or add a new genre...">
            <button id="add-genre-btn" class="add-genre-button" title="Add Genre">+</button>
        </div>
        <div id="genre-add-error"></div>
        <div id="user-added-section" style="display: none;">
            <div class="genre-section-header">Your Added Genres</div>
            <div id="user-added-genres-container" class="genre-container user-added-container"></div>
        </div>
        <div class="genre-section-header">Main Genres</div>
        <div id="genre-buttons-container" class="genre-container"></div>
      </div>
      <div class="main-trackCreditsModal-originalCredits" style="padding: 15px 24px !important; border-top: 1px solid #282828; flex-shrink: 0;">
        <div style="display: flex; justify-content: flex-end; align-items: center; gap: 15px;">
            <div id="genre-selection-error" style="color: #f15e6c; font-size: 13px; display: none; flex-grow: 1; text-align: right;"></div>
            <button id="createGenreTreePlaylist" class="main-buttons-button main-button-primary" 
                    style="padding: 8px 18px; border-radius: 20px; font-weight: 550; font-size: 13px; text-transform: uppercase; border: none; cursor: pointer;">
                Create Playlist
            </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(overlay);
    overlay.appendChild(modalContainer);

    const userGenreSection = modalContainer.querySelector('#user-added-section');
    const userGenreContainer = modalContainer.querySelector('#user-added-genres-container');
    const mainGenreContainer = modalContainer.querySelector('#genre-buttons-container');
    const searchBar = modalContainer.querySelector('#genre-search-bar');
    const addBtn = modalContainer.querySelector('#add-genre-btn');
    const errorDiv = modalContainer.querySelector('#genre-add-error');

    const renderGenres = (filter = '') => {
        mainGenreContainer.innerHTML = '';
        const filteredGenres = mainGenreList.filter(g => g.toLowerCase().includes(filter.toLowerCase()));
        filteredGenres.forEach(genre => {
            const btn = document.createElement('button');
            btn.className = 'genre-button';
            btn.textContent = genre;
            if (selectedMainGenres.includes(genre)) {
                btn.classList.add('selected');
            }
            btn.onclick = () => {
                if (selectedMainGenres.includes(genre)) {
                    selectedMainGenres = selectedMainGenres.filter(g => g !== genre);
                    btn.classList.remove('selected');
                } else {
                    selectedMainGenres.push(genre);
                    btn.classList.add('selected');
                }
            };
            mainGenreContainer.appendChild(btn);
        });
    };

    const renderUserGenres = (filter = '') => {
        userGenreContainer.innerHTML = '';
        const filteredUserGenres = [...userAddedGenres].filter(g => g.toLowerCase().includes(filter.toLowerCase()));
        
        if (userAddedGenres.size === 0) {
            userGenreSection.style.display = 'none';
            return;
        }
        userGenreSection.style.display = 'block';

        filteredUserGenres.forEach(genre => {
            const btn = document.createElement('button');
            btn.className = 'genre-button';
            
            const textSpan = document.createElement('span');
            textSpan.textContent = genre;
            btn.appendChild(textSpan);

            const removeSpan = document.createElement('span');
            removeSpan.className = 'user-genre-remove';
            removeSpan.innerHTML = '&times;';
            removeSpan.onclick = (e) => {
                e.stopPropagation();
                userAddedGenres.delete(genre);
                selectedUserGenres.delete(genre);
                saveUserGenres();
                fullRender(searchBar.value);
            };
            btn.appendChild(removeSpan);

            if (selectedUserGenres.has(genre)) {
                btn.classList.add('selected');
            }
            btn.onclick = () => {
                if (selectedUserGenres.has(genre)) {
                    selectedUserGenres.delete(genre);
                    btn.classList.remove('selected');
                } else {
                    selectedUserGenres.add(genre);
                    btn.classList.add('selected');
                }
            };
            userGenreContainer.appendChild(btn);
        });
    };

    const fullRender = (filter = '') => {
        renderUserGenres(filter);
        renderGenres(filter);
    };

    searchBar.addEventListener('input', () => fullRender(searchBar.value));
    
    addBtn.addEventListener('click', async () => {
        const newGenre = searchBar.value.trim().toLowerCase();

        if (!newGenre) return;
        if (mainGenreList.includes(newGenre) || userAddedGenres.has(newGenre)) {
            showNotification(`"${newGenre}" already exists in the list.`, true);
            return;
        }

        if (!genrePlaylistsCache) {
            showNotification("Could not verify genre; genre database is unavailable.", true);
            return;
        }

        const escapedGenre = escapeRegExp(newGenre);
        const regex = new RegExp(`\\b${escapedGenre}\\b`, 'i');
        const hasMatch = genrePlaylistsCache.some(p => regex.test(p.genre));

        if (hasMatch) {
            userAddedGenres.add(newGenre);
            selectedUserGenres.add(newGenre);
            saveUserGenres();
            searchBar.value = '';
            fullRender();
        } else {
            showNotification(`No genre found for "${newGenre}". Try a broader term.`, true);
        }
    });

    fullRender();

    const closeModal = () => overlay.remove();
    
    const createPlaylistBtn = modalContainer.querySelector('#createGenreTreePlaylist');

    createPlaylistBtn.addEventListener('click', () => {
        const allSelected = [...selectedMainGenres, ...selectedUserGenres];
        if (allSelected.length === 0) {
            showNotification("Please select at least one genre.", true);
            return;
        }
        closeModal();
        generateGenreTreePlaylist(allSelected);
    });

    const closeButton = modalContainer.querySelector("#closeGenreTreeModal");
    if (closeButton) {
        closeButton.addEventListener("click", closeModal);
    }

    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            e.preventDefault();
            e.stopPropagation();
        }
    });
  }

  async function handleSortAndCreatePlaylist(sortType, options = {}) {
    const { isHeadless = false } = options;

    if (sortType === "sortByParent" || sortType === "createNewPlaylist") {
      return;
    }

    const topTrackSortTypes = {
        topThisMonth:    { time_range: 'short_term',  name: 'This Month',      description: 'from this month' },
        topLast6Months:  { time_range: 'medium_term', name: 'Last 6 Months',   description: 'from the last 6 months' },
        topAllTime:      { time_range: 'long_term',   name: 'All-Time',        description: 'of all time' }
    };

    const recommendationSortTypes = ['recommendRecentVibe', 'recommendAllTime', 'pureDiscovery', 'followedReleasesChronological', 'genreTreeExplorer', 'infiniteVibe', 'neighborsMix'];
    if (recommendationSortTypes.includes(sortType)) {
        if (sortType === 'genreTreeExplorer') {
            showGenreTreeExplorerModal();
        } else if (sortType === 'followedReleasesChronological') {
            await generateFollowedReleasesChronological(options);
        } else if (sortType === 'neighborsMix') {
            await generateNeighborsMix(options);
        } else if (sortType === 'infiniteVibe') {
            await generateInfiniteVibe(options);
        } else { 
            await generateSpotifyRecommendations(sortType, options);
        }
        return; 
    }

    if (sortType === "aiPick") {
        setButtonProcessing(true);
        mainButton.innerHTML = '<div class="loader"></div>';
        mainButton.innerText = "Preparing...";
        toggleMenu();
        closeAllMenus();
    
        try {
            const currentUri = getCurrentUri();
            if (!currentUri) {
                throw new Error("Please select a playlist or artist first");
            }
    
            let tracks;
            let isArtistPage = false;

            if (URI.isPlaylistV1OrV2(currentUri)) {
                tracks = await getPlaylistTracks(currentUri.split(":")[2]);
            } else if (URI.isArtist(currentUri)) {
                tracks = await getArtistTracks(currentUri);
                isArtistPage = true;
            } else if (isLikedSongsPage(currentUri)) {
                tracks = await getLikedSongs();
            } else if (URI.isAlbum(currentUri)) {
                tracks = await getAlbumTracks(currentUri.split(":")[2]);
            } else {
                throw new Error('Invalid page for AI Pick');
            }
    
            if (!tracks || tracks.length === 0) {
                throw new Error('No tracks found to analyze');
            }

            if (isArtistPage) {
                tracks = await processArtistPageTracks(tracks);
            }
            
            const openModal = async () => {
                await showAiPickModal(tracks, currentUri);
                resetButtons(); 
            };

            await openModal();

            return;
    
        } catch (error) {
            console.error("Error preparing AI Pick:", error);
            showNotification(error.message, true);
            resetButtons();
        }
        return;
    }
    
    if (topTrackSortTypes[sortType]) {
        if (!isHeadless) {
            setButtonProcessing(true);
            mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
            mainButton.style.color = buttonStyles.main.disabledColor;
            mainButton.style.cursor = "default";
            svgElement.style.fill = buttonStyles.main.disabledColor;
            menuButtons.forEach((button) => (button.disabled = true));
            toggleMenu();
            closeAllMenus();
        }
        
        try {
            if (!isHeadless) mainButton.innerText = "Fetching...";
            const topTracksData = await getTopItems('tracks', topTrackSortTypes[sortType].time_range, topTracksLimit);
            
            if (!topTracksData || topTracksData.length === 0) {
                showNotification(`No top tracks found for "${topTrackSortTypes[sortType].name}".`, true);
                if (!isHeadless) resetButtons();
                return;
            }

            const trackUris = topTracksData.map(track => track.uri);
            const playlistName = `My Top Tracks: ${topTrackSortTypes[sortType].name}`;
            const playlistDescription = `Your top tracks ${topTrackSortTypes[sortType].description}, created by Sort-Play.`;
            
            if (!isHeadless) mainButton.innerText = "Creating...";
            const { playlist: newPlaylist, wasUpdated } = await getOrCreateDedicatedPlaylist(sortType, playlistName, playlistDescription);
            
            if (!isHeadless) mainButton.innerText = "Saving...";
            if (wasUpdated) {
                await replacePlaylistTracks(newPlaylist.id, trackUris);
            } else {
                await addTracksToPlaylist(newPlaylist.id, trackUris);
            }
            
            showNotification(`Playlist "${playlistName}" ${wasUpdated ? 'updated' : 'created'} successfully!`);

            if (openPlaylistAfterSortEnabled && newPlaylist && newPlaylist.uri) { 
                const tempPath = "/library"; 
                Spicetify.Platform.History.push(tempPath);
                await new Promise(resolve => setTimeout(resolve, 450)); 
                const newPlaylistPath = Spicetify.URI.fromString(newPlaylist.uri).toURLPath(true);
                if (newPlaylistPath) {
                  Spicetify.Platform.History.push(newPlaylistPath);
                } else {
                  console.warn("Could not determine path for new playlist URI:", newPlaylist.uri);
                }
            }
        } catch (error) {
            console.error("Error creating top tracks playlist:", error);
            showNotification("Failed to create top tracks playlist.", true);
        } finally {
            if (!isHeadless) {
                resetButtons();
            }
        }
        return; 
    }

    if (!isHeadless) {
        setButtonProcessing(true);
        mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
        mainButton.style.color = buttonStyles.main.disabledColor;
        mainButton.style.cursor = "default";
        svgElement.style.fill = buttonStyles.main.disabledColor;
        menuButtons.forEach((button) => (button.disabled = true));
        toggleMenu();
        closeAllMenus();
    }

    const initialPagePath = Spicetify.Platform.History.location.pathname; 

    try {
      const currentUriAtStart = getCurrentUri(); 
      if (!currentUriAtStart) {
        if (!isHeadless) resetButtons();
        showNotification("Please select a playlist or artist first");
        return;
      }

      let tracks;
      let isArtistPage = false;
      let isAlbumPage = false;
      let currentPlaylistDetails = null;
      let sourcePlaylistCoverUrl = null;
      let sourceNameForDialog = "Current Context"; 

      if (URI.isPlaylistV1OrV2(currentUriAtStart)) {
        const playlistId = currentUriAtStart.split(":")[2];
        tracks = await getPlaylistTracks(playlistId);
        try {
            if (isFallbackActive()) {
                const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(currentUriAtStart);
                currentPlaylistDetails = { name: meta.name, owner: { id: meta.owner.uri.split(':')[2], display_name: meta.owner.name }, images: meta.images };
            } else {
                try {
                    currentPlaylistDetails = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${playlistId}`);
                } catch (e) {
                    if (registerWebApiFailure()) {
                        const meta = await Spicetify.Platform.PlaylistAPI.getMetadata(currentUriAtStart);
                        currentPlaylistDetails = { name: meta.name, owner: { id: meta.owner.uri.split(':')[2], display_name: meta.owner.name }, images: meta.images };
                    }
                }
            }
            sourceNameForDialog = currentPlaylistDetails?.name || "Current Playlist";
            if (currentPlaylistDetails?.images?.length > 0) {
                sourcePlaylistCoverUrl = currentPlaylistDetails.images[0].url;
            }
        } catch (e) {
            console.warn("Could not fetch current playlist details for ownership check/dialog", e);
        }
      } else if (URI.isArtist(currentUriAtStart)) {
        tracks = await getArtistTracks(currentUriAtStart);
        isArtistPage = true;
      } else if (isLikedSongsPage(currentUriAtStart)) {
        tracks = await getLikedSongs();
      } else if (isLocalFilesPage(currentUriAtStart)) {
        tracks = await getLocalFilesTracks();
      } else if (URI.isAlbum(currentUriAtStart)) {
        const albumId = currentUriAtStart.split(":")[2];
        tracks = await getAlbumTracks(albumId);
        isAlbumPage = true;
        try {
            let albumDetails;
            if (isFallbackActive()) {
                const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: currentUriAtStart, locale: "en", offset: 0, limit: 1 });
                const u = res.data.albumUnion;
                albumDetails = { name: u.name, images: [{ url: u.coverArt.sources[0].url }] };
            } else {
                try {
                    albumDetails = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${albumId}`);
                } catch(e) {
                    if (registerWebApiFailure()) {
                        const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: currentUriAtStart, locale: "en", offset: 0, limit: 1 });
                        const u = res.data.albumUnion;
                        albumDetails = { name: u.name, images: [{ url: u.coverArt.sources[0].url }] };
                    }
                }
            }
            sourceNameForDialog = albumDetails?.name || "Current Album";
            if (albumDetails?.images?.length > 0) {
                sourcePlaylistCoverUrl = albumDetails.images[0].url;
            }
        } catch (e) {
            console.warn("Could not fetch current album details", e);
        }
      } else {
        throw new Error('Invalid page for sorting');
      }

      if (!tracks || tracks.length === 0) {
          showNotification('No tracks found to sort');
          if (!isHeadless) resetButtons();
          return;
      }

      let unconvertedLocalCount = 0;
      const directSortsToConvertLocalTracks = [
        'playCount', 'popularity', 'releaseDate', 'averageColor', 
        'energyWave', 'tempo', 'energy', 'danceability', 'valence', 
        'acousticness', 'instrumentalness', 'deduplicateOnly'
      ];

      const user = await Spicetify.Platform.UserAPI.getUser();
      let canModifyCurrentPlaylist = sortCurrentPlaylistEnabled &&
                                       createPlaylistAfterSort && 
                                       isDirectSortType(sortType) &&
                                       URI.isPlaylistV1OrV2(currentUriAtStart) &&
                                       !isArtistPage &&
                                       !isAlbumPage &&
                                       !isLikedSongsPage(currentUriAtStart) &&
                                       currentPlaylistDetails &&
                                       currentPlaylistDetails.owner &&
                                       currentPlaylistDetails.owner.id === user.username;

      if (canModifyCurrentPlaylist && !isHeadless) {
        const userChoice = await showConfirmationModal({
            title: "Sort Current Playlist?",
            description: `This will replace all tracks in this playlist with the sorted version. Do you want to modify the current playlist, or create a new one instead?`,
            confirmText: "Modify Current",
            cancelText: "Cancel",
            neutralText: "Create New",
        });

        if (userChoice === 'cancel') {
            showNotification("Sorting cancelled.");
            if (!isHeadless) resetButtons();
            return;
        } else if (userChoice === 'neutral') {
            canModifyCurrentPlaylist = false;
        }
      }

      if (directSortsToConvertLocalTracks.includes(sortType)) {
        const { convertedTracks, unconvertedCount } = await convertLocalTracksToSpotify(
            tracks,
            (progress) => { if (!isHeadless) mainButton.innerText = progress; }
        );
        tracks = convertedTracks;
        unconvertedLocalCount = unconvertedCount;
      }

      if (unconvertedLocalCount > 0 && !isHeadless) {
          const plural = unconvertedLocalCount === 1 ? "track" : "tracks";
          showNotification(`${unconvertedLocalCount} local ${plural} not found on Spotify and were skipped.`, 'warning');
      }

      let sortedTracks;
      let uniqueTracks;
      let removedTracks = [];
      let playlistUriForQueue = currentUriAtStart; 
      let playlistWasModifiedOrCreated = false;
      let newPlaylistObjectForNavigation = null; 
      let modifiedPlaylistOriginalPath = null;
      let missingDataCount = 0;


      if (sortType === "lastScrobbled") {
          try {
              const result = await handleLastScrobbledSorting(
                tracks, (progress) => { if (!isHeadless) mainButton.innerText = `${progress}%`; }
              );
              sortedTracks = result.sortedTracks;
              removedTracks = result.removedTracks;
              if (!isHeadless) mainButton.innerText = "100%";
          } catch (error) {
              if (!isHeadless) resetButtons();
              showNotification(error.message, true);
              return;
          }
      } else {
        if (!isHeadless) mainButton.innerText = "0%";

        let tracksWithPopularity;

        if (isArtistPage) {
            tracksWithPopularity = await processArtistPageTracks(tracks, isHeadless);
        } 
        else if (playlistDeduplicate || sortType === 'deduplicateOnly') {
            if (!isHeadless) mainButton.innerText = "Enriching...";
            
            const tracksWithPlayCounts = await enrichTracksWithPlayCounts(
              tracks, (progress) => { if (!isHeadless) mainButton.innerText = `${Math.floor(progress * 0.40)}%`; }
            );

            tracksWithPopularity = await fetchPopularityForMultipleTracks(
              tracksWithPlayCounts, 
              (progress) => { if (!isHeadless) mainButton.innerText = `${40 + Math.floor(progress * 0.60)}%`; }
            );
        
        } else if (sortType === 'playCount') {
            if (!isHeadless) mainButton.innerText = "0%";
            tracksWithPopularity = await enrichTracksWithPlayCounts(
                tracks, (progress) => { if (!isHeadless) mainButton.innerText = `${Math.floor(progress * 0.80)}%`; }
            );

        } else if (sortType === 'popularity') {
            if (!isHeadless) mainButton.innerText = "0%";
            tracksWithPopularity = await fetchPopularityForMultipleTracks(
              tracks, 
              (progress) => { if (!isHeadless) mainButton.innerText = `${10 + Math.floor(progress * 0.90)}%`; }
            );

        } else {
            tracksWithPopularity = tracks.map(track => ({
                ...track,
                trackId: track.uri.split(":")[2],
                songTitle: track.name,
                artistName: track.artistName || (track.artists && track.artists[0]?.name),
                allArtists: track.allArtists || (track.artists?.map(a => a.name).join(", ")),
                albumName: track.albumName || track.album?.name,
                playCount: "N/A",
                popularity: null,
            }));
        }


        if (
          sortType === "playCount" ||
          sortType === "popularity" ||
          sortType === "shuffle" ||
          sortType === "releaseDate" ||
          sortType === "averageColor" ||
          sortType === "deduplicateOnly" ||
          sortType === "filterLiked" ||
          sortType === "keepLiked" ||
          sortType === "sortByLiked" ||
          sortType === "filterSingles" ||
          sortType === "filterAlbums"
        ) {
          let tracksForDeduplication;
          if (sortType === "releaseDate") {
            const tracksWithReleaseDates = await processBatchesWithDelay(
              tracksWithPopularity, 50, 500, (progress) => { if (!isHeadless) mainButton.innerText = `${Math.floor(progress * 0.80)}%`; }, getTrackDetailsWithReleaseDate
            );
            tracksForDeduplication = tracksWithReleaseDates;
          } else if (sortType === "averageColor") {
              const albumIds = [...new Set(tracksWithPopularity.map(t => t.albumId || t.track?.album?.id).filter(Boolean))];
              const bulkPalettes = await idb.getMany('palettes', albumIds);

              const cachedTracks = [];
              const uncachedTracks = [];
              
              for (const track of tracksWithPopularity) {
                  const albumId = track.albumId || track.track?.album?.id;
                  if (albumId && bulkPalettes.has(albumId)) {
                      cachedTracks.push({ ...track, averageColor: bulkPalettes.get(albumId) });
                  } else {
                      uncachedTracks.push(track);
                  }
              }

              let tracksWithColor = [];
              const totalColorTracks = tracksWithPopularity.length;

              if (cachedTracks.length > 0) {
                  const cachedResults = await processBatchesWithDelay(
                      cachedTracks, 50, 500,
                      (progress) => {
                          const overallProgress = (cachedTracks.length / totalColorTracks) * progress;
                          if (!isHeadless) mainButton.innerText = `${60 + Math.floor(overallProgress * 0.40)}%`;
                      },
                      getTrackDetailsWithPaletteAnalysis
                  );
                  tracksWithColor.push(...cachedResults);
              }

              if (uncachedTracks.length > 0) {
                  const uncachedResults = await processBatchesWithDelay(
                      uncachedTracks, 15, 1500,
                      (progress) => {
                          const cachedPortion = (cachedTracks.length / totalColorTracks) * 40;
                          const uncachedPortion = (uncachedTracks.length / totalColorTracks) * progress * 0.40;
                          if (!isHeadless) mainButton.innerText = `${60 + Math.floor(cachedPortion + uncachedPortion)}%`;
                      },
                      getTrackDetailsWithPaletteAnalysis
                  );
                  tracksWithColor.push(...uncachedResults);
              }

              tracksForDeduplication = tracksWithColor;
          } else {
            tracksForDeduplication = tracksWithPopularity;
          }
          if (sortType === "filterSingles" || sortType === "filterAlbums") {
            if (!isHeadless) mainButton.innerText = "Checking...";
            if (!isArtistPage) {
                tracksForDeduplication = await refreshTrackAlbumInfo(tracksForDeduplication, (progress) => {
                    if (!isHeadless) mainButton.innerText = `${Math.floor(progress * 0.50)}%`;
                });
            }
         }

          const deduplicationResult = await deduplicateTracks(
              tracksForDeduplication, 
              sortType === "deduplicateOnly", 
              isArtistPage,
              (progress) => { if (!isHeadless) mainButton.innerText = `Dedup ${progress}%`; }
          );
          uniqueTracks = deduplicationResult.unique;
          removedTracks = deduplicationResult.removed;

          if (sortType === "playCount") {
            const getVal = (t) => (t.playCount === "N/A" || t.playCount == null) ? -1 : Number(t.playCount);
            sortedTracks = uniqueTracks.sort((a, b) => 
                sortOrderState.playCount ? getVal(a) - getVal(b) : getVal(b) - getVal(a)
            );
          } else if (sortType === "popularity") {
            const getVal = (t) => (t.popularity == null) ? -1 : Number(t.popularity);
            sortedTracks = uniqueTracks.sort((a, b) => 
                sortOrderState.popularity ? getVal(a) - getVal(b) : getVal(b) - getVal(a)
            );
        } else if (sortType === "releaseDate") {
          sortedTracks = uniqueTracks
            .sort((a, b) => {
              const valA = a.releaseDate ? new Date(a.releaseDate).getTime() : 0;
              const valB = b.releaseDate ? new Date(b.releaseDate).getTime() : 0;

              const dateComparison = sortOrderState.releaseDate
                ? valA - valB
                : valB - valA;
    
              if (dateComparison !== 0) {
                return dateComparison;
              }

              const albumA = (a.albumName || "").toLowerCase();
              const albumB = (b.albumName || "").toLowerCase();
              const albumCompare = albumA.localeCompare(albumB);
              if (albumCompare !== 0) return albumCompare;
              
              return (a.trackNumber || 0) - (b.trackNumber || 0);
            });
        } else if (sortType === "averageColor") {
              sortedTracks = uniqueTracks
                  .filter(track => track.averageColor && track.averageColor.dominantHsl)
                  .sort((a, b) => {
                      const analysisA = a.averageColor;
                      const analysisB = b.averageColor;
                      const sortOrder = sortOrderState.averageColor ? -1 : 1;

                      if (colorSortMode === 'perceptual') {
                          if (analysisA.isMonochrome && !analysisB.isMonochrome) return -1;
                          if (!analysisA.isMonochrome && analysisB.isMonochrome) return 1;

                          if (analysisA.isMonochrome) {
                              return (analysisB.dominantHsl.l - analysisA.dominantHsl.l);
                          } else {
                              const colorA = analysisA.dominantHsl;
                              const colorB = analysisB.dominantHsl;
                              if (colorA.h !== colorB.h) {
                                  return (colorA.h - colorB.h) * sortOrder;
                              }
                              return colorB.l - colorA.l;
                          }
                      } else {
                          const colorA = analysisA.dominantHsl;
                          const colorB = analysisB.dominantHsl;
                          if (colorA.h !== colorB.h) {
                              return (colorA.h - colorB.h) * sortOrder;
                          }
                          if (colorA.l !== colorB.l) {
                              return (colorA.l - colorB.l) * sortOrder;
                          }
                          return (colorA.s - colorB.s) * sortOrder;
                      }
                  });
          } else if (sortType === "shuffle") {
            const containsLocalFiles = uniqueTracks.some(track => Spicetify.URI.isLocal(track.uri));

            if (useEnergyWaveShuffle && !containsLocalFiles) {
                if (!isHeadless) mainButton.innerText = "Analyzing...";
                const trackIds = uniqueTracks.map(t => t.trackId);
                const allStats = await getBatchTrackStats(trackIds);

                const tracksWithAudioFeatures = uniqueTracks.map(track => {
                    const stats = allStats[track.trackId] || {};
                    return { ...track, ...stats, features: stats };
                });
                
                const tracksWithData = tracksWithAudioFeatures.filter(track => track.features && track.features.energy !== null && track.features.valence !== null);
                const tracksWithoutData = tracksWithAudioFeatures.filter(track => !track.features || track.features.energy === null || track.features.valence === null);
                missingDataCount = tracksWithoutData.length;

                const waveSortedTracks = await randomizedEnergyWaveSort(tracksWithData);

                sortedTracks = [...waveSortedTracks, ...shuffleArray(tracksWithoutData)];
            } else {
                if (useEnergyWaveShuffle && containsLocalFiles && !isHeadless) {
                    showNotification("Playlist contains local files. Using normal shuffle instead of Vibe & Flow.");
                }
                sortedTracks = shuffleArray(uniqueTracks);
            }
        } else if (sortType === "deduplicateOnly") {
            if (removedTracks.length === 0) {
                showNotification("No duplicate tracks found.");
                if (!isHeadless) resetButtons();
                return;
            }
            const originalOrderMap = new Map();
            tracksForDeduplication.forEach((track, index) => {
                if (track.uri) {
                    originalOrderMap.set(track.uri, index);
                }
            });
            sortedTracks = uniqueTracks.sort((a, b) => {
                const orderA = originalOrderMap.get(a.uri);
                const orderB = originalOrderMap.get(b.uri);
                return orderA - orderB;
            });
        } else if (sortType === "filterLiked" || sortType === "keepLiked" || sortType === "sortByLiked") {
            if (!isHeadless) mainButton.innerText = "Checking...";
            const likedSongs = await getLikedSongs();
            const likedSongUris = new Set(likedSongs.map(s => s.uri));
            
            if (!isHeadless) mainButton.innerText = "ISRCs...";
            
            const tracksWithMetadata = await refreshTrackAlbumInfo(uniqueTracks, (progress) => {
                if (!isHeadless) mainButton.innerText = `ISRCs ${Math.floor(progress)}%`;
            });

            const likedTrackIds = likedSongs.map(s => s.uri.split(':')[2]).filter(Boolean);
            const cachedLikedMetadata = await idb.getMany('trackMetadata', likedTrackIds, CACHE_EXPIRE_METADATA);
            
            const likedIsrcSet = new Set();
            cachedLikedMetadata.forEach(meta => {
                if (meta && meta.external_ids && meta.external_ids.isrc) {
                    likedIsrcSet.add(meta.external_ids.isrc);
                }
            });
            
            likedTrackIds.forEach(id => {
                const storedIsrc = localStorage.getItem("sort-play-like-" + id);
                if (storedIsrc) likedIsrcSet.add(storedIsrc);
            });

            const originalOrderMap = new Map();
            tracksForDeduplication.forEach((track, index) => originalOrderMap.set(track.uri, index));
            
            if (sortType === "sortByLiked") {
                sortedTracks = uniqueTracks.sort((a, b) => {
                    let isLikedA = likedSongUris.has(a.uri);
                    let isLikedB = likedSongUris.has(b.uri);

                    if (!isLikedA) {
                        const metaA = tracksWithMetadata.find(t => t.uri === a.uri);
                        const isrcA = metaA?.track?.external_ids?.isrc;
                        if (isrcA && likedIsrcSet.has(isrcA)) isLikedA = true;
                    }
                    
                    if (!isLikedB) {
                        const metaB = tracksWithMetadata.find(t => t.uri === b.uri);
                        const isrcB = metaB?.track?.external_ids?.isrc;
                        if (isrcB && likedIsrcSet.has(isrcB)) isLikedB = true;
                    }

                    const valA = isLikedA ? 1 : 0;
                    const valB = isLikedB ? 1 : 0;

                    if (valA !== valB) {
                        return sortOrderState.sortByLiked ? valA - valB : valB - valA;
                    }
                    return originalOrderMap.get(a.uri) - originalOrderMap.get(b.uri);
                });
            } else {
                sortedTracks = uniqueTracks
                    .filter(track => {
                        let isLiked = likedSongUris.has(track.uri);
                        
                        if (!isLiked) {
                            const meta = tracksWithMetadata.find(t => t.uri === track.uri);
                            const isrc = meta?.track?.external_ids?.isrc;
                            if (isrc && likedIsrcSet.has(isrc)) isLiked = true;
                        }
                        
                        return sortType === "keepLiked" ? isLiked : !isLiked;
                    })
                    .sort((a, b) => originalOrderMap.get(a.uri) - originalOrderMap.get(b.uri));
            }
          } else if (sortType === "filterSingles") {
            const originalOrderMap = new Map();
            tracksForDeduplication.forEach((track, index) => originalOrderMap.set(track.uri, index));
            
            sortedTracks = uniqueTracks
                .filter(track => {
                    const type = track.albumType || track.track?.album?.album_type;
                    return type === 'single';
                })
                .sort((a, b) => originalOrderMap.get(a.uri) - originalOrderMap.get(b.uri));

          } else if (sortType === "filterAlbums") {
            const filteredTracks = uniqueTracks.filter(track => {
                const type = track.albumType || track.track?.album?.album_type;
                return type === 'album' || type === 'compilation';
            });

            if (sortOrderState.filterAlbums) {
                sortedTracks = filteredTracks.sort((a, b) => {
                    const albumA = (a.albumName || "").toLowerCase();
                    const albumB = (b.albumName || "").toLowerCase();
                    const albumCompare = albumA.localeCompare(albumB);
                    if (albumCompare !== 0) return albumCompare;
                    
                    const trackA = a.trackNumber || 0;
                    const trackB = b.trackNumber || 0;
                    return trackA - trackB;
                });
            } else {
                const originalOrderMap = new Map();
                tracksForDeduplication.forEach((track, index) => originalOrderMap.set(track.uri, index));
                
                sortedTracks = filteredTracks.sort((a, b) => originalOrderMap.get(a.uri) - originalOrderMap.get(b.uri));
            }
          }

          if (!isHeadless) mainButton.innerText = "100%";

        } else if (sortType === "energyWave") {
            if (isFallbackActive()) {
                if (!isHeadless) resetButtons();
                showNotification("Energy Wave is unavailable.", true);
                return;
            }
            if (!isHeadless) mainButton.innerText = "Analyzing...";
            const trackIds = tracksWithPopularity.map(t => t.trackId);
            const allStats = await getBatchTrackStats(trackIds);

            const tracksWithAudioFeatures = tracksWithPopularity.map(track => {
                const stats = allStats[track.trackId] || {};
                return { ...track, ...stats, features: stats };
            });
    
            const deduplicationResult = await deduplicateTracks(
                tracksWithAudioFeatures, 
                false, 
                isArtistPage,
                (progress) => { if (!isHeadless) mainButton.innerText = `Dedup ${progress}%`; }
            );
            uniqueTracks = deduplicationResult.unique;
            removedTracks = deduplicationResult.removed;
    
            const tracksWithData = uniqueTracks.filter(track => track.features && track.features.energy !== null && track.features.valence !== null);
            const tracksWithoutData = uniqueTracks.filter(track => !track.features || track.features.energy === null || track.features.valence === null);
            missingDataCount = tracksWithoutData.length;

            const journeySortedTracks = await energyWaveSort(tracksWithData);

            if (sortOrderState.energyWave) {
                journeySortedTracks.reverse();
            }

            if (canModifyCurrentPlaylist) {
                sortedTracks = [...journeySortedTracks, ...tracksWithoutData];
            } else {
                sortedTracks = journeySortedTracks;
            }
            if (!isHeadless) mainButton.innerText = "100%";

        } else if (['tempo', 'energy', 'danceability', 'valence', 'acousticness', 'instrumentalness'].includes(sortType)) {
            const trackIds = tracksWithPopularity.map(t => t.trackId);
            const allStats = await getBatchTrackStats(trackIds, (progress) => {
                const overallProgress = 60 + Math.floor(progress * 0.40);
                if (!isHeadless) mainButton.innerText = `${overallProgress}%`;
            });

            const tracksWithAudioFeatures = tracksWithPopularity.map(track => {
                const stats = allStats[track.trackId] || {};
                return { ...track, ...stats };
            });
    
            const deduplicationResult = await deduplicateTracks(
                tracksWithAudioFeatures, 
                false, 
                isArtistPage,
                (progress) => { if (!isHeadless) mainButton.innerText = `Dedup ${progress}%`; }
            );
            uniqueTracks = deduplicationResult.unique;
            removedTracks = deduplicationResult.removed;
    
            const tracksWithData = uniqueTracks.filter(track => track[sortType] !== null && track[sortType] !== undefined);
            const tracksWithoutData = uniqueTracks.filter(track => track[sortType] === null || track[sortType] === undefined);
            missingDataCount = tracksWithoutData.length;

            const sortedTracksWithData = tracksWithData.sort((a, b) => {
                const valA = a[sortType] || 0;
                const valB = b[sortType] || 0;
                return sortOrderState[sortType] ? valA - valB : valB - valA;
            });

            if (canModifyCurrentPlaylist) {
                sortedTracks = [...sortedTracksWithData, ...tracksWithoutData];
            } else {
                sortedTracks = sortedTracksWithData;
            }

        } else if (sortType === "scrobbles" || sortType === "personalScrobbles") {
            try {
                const tracksWithScrobbles = await handleScrobblesSorting(
                  tracksWithPopularity,
                  sortType,
                  (progress) => { if (!isHeadless) mainButton.innerText = `${80 + Math.floor(progress * 0.20)}%`; }
                );

                const deduplicationResult = await deduplicateTracks(
                    tracksWithScrobbles, 
                    sortType === "deduplicateOnly", 
                    isArtistPage,
                    (progress) => { if (!isHeadless) mainButton.innerText = `Dedup ${progress}%`; }
                );
                uniqueTracks = deduplicationResult.unique;
                removedTracks = deduplicationResult.removed;

                if (sortType === 'personalScrobbles') {
                    const includeZeroScrobbles = localStorage.getItem("sort-play-include-no-scrobbles") !== "false";

                    let tracksToSort = uniqueTracks.map((track, index) => ({ ...track, originalIndex: index }));

                    if (!includeZeroScrobbles) {
                        tracksToSort = tracksToSort.filter(t => t.personalScrobbles > 0);
                    }

                    sortedTracks = tracksToSort.sort((a, b) => {
                        const getVal = (t) => (typeof t.personalScrobbles === 'number') ? t.personalScrobbles : -1;
                        const valA = getVal(a);
                        const valB = getVal(b);

                        if (valA === valB) {
                             return a.originalIndex - b.originalIndex;
                        }

                        return sortOrderState.personalScrobbles 
                            ? valA - valB 
                            : valB - valA;
                    });
                } else { 
                    const tracksToSort = uniqueTracks.map((track, index) => ({ ...track, originalIndex: index }));

                    sortedTracks = tracksToSort.sort((a, b) => {
                        const getVal = (t) => (typeof t.scrobbles === 'number') ? t.scrobbles : -1;
                        const valA = getVal(a);
                        const valB = getVal(b);

                        if (valA === valB) {
                             return a.originalIndex - b.originalIndex;
                        }

                        return sortOrderState.scrobbles 
                            ? valA - valB 
                            : valB - valA;
                    });
                }
                if (!isHeadless) mainButton.innerText = "100%";

              } catch (error) {
                if (!isHeadless) resetButtons();
                showNotification(error.message);
                return;
              }
        } else if (sortType === "lastScrobbled") { 
            try {
                const result = await handleLastScrobbledSorting(
                    tracks, (progress) => { if (!isHeadless) mainButton.innerText = `${progress}%`; }
                );
                sortedTracks = result.sortedTracks;
                removedTracks = result.removedTracks;
                if (!isHeadless) mainButton.innerText = "100%";
            } catch (error) {
                if (!isHeadless) resetButtons();
                showNotification(error.message, true);
                return;
            }
        }
      }

      if (isArtistPage && sortedTracks && sortedTracks.length > 0) {
          const targetArtistId = currentUriAtStart.split(":")[2];
          sortedTracks = sortedTracks.filter(t => {
              const checkId = (id) => id && (id === targetArtistId || id.includes(targetArtistId));
              
              const inArtistUris = t.artistUris && Array.isArray(t.artistUris) && t.artistUris.some(checkId);
              
              const inTrackArtists = t.track && t.track.artists && Array.isArray(t.track.artists) && 
                                    t.track.artists.some(a => checkId(a.uri) || checkId(a.id));
              
              const inArtists = t.artists && Array.isArray(t.artists) && 
                               t.artists.some(a => checkId(a.uri) || checkId(a.id));
              
              return inArtistUris || inTrackArtists || inArtists;
          });
      }
      
      if (createPlaylistAfterSort && isDirectSortType(sortType)) {
        if (!sortedTracks || sortedTracks.length === 0) {
            console.log("No tracks left after sorting/filtering to create/modify playlist.");
            if (!addToQueueEnabled) {
                showNotification("No tracks to process for playlist.", 'warning');
            }
            if (!isHeadless) resetButtons();
            return;
        }
        
        const sourceUriForNaming = currentUriAtStart; 
        let finalSourceName;
        if (URI.isArtist(sourceUriForNaming)) {
            const id = sourceUriForNaming.split(":")[2];
            try {
                if (isFallbackActive()) {
                    const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, { uri: sourceUriForNaming, locale: "en", includePrerelease: false });
                    finalSourceName = res.data.artistUnion.profile.name;
                } else {
                    finalSourceName = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists/${id}`).then((r) => r.name);
                }
            } catch (e) {
                if (registerWebApiFailure()) {
                    const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, { uri: sourceUriForNaming, locale: "en", includePrerelease: false });
                    finalSourceName = res.data.artistUnion.profile.name;
                }
            }
        } else if (isLikedSongsPage(sourceUriForNaming)) {
            finalSourceName = "Liked Songs";
        } else if (isLocalFilesPage(sourceUriForNaming)) {
            finalSourceName = "Local Files";
        } else if (URI.isAlbum(sourceUriForNaming)) {
            const albumId = sourceUriForNaming.split(":")[2];
            try {
                if (isFallbackActive()) {
                    const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: sourceUriForNaming, locale: "en", offset: 0, limit: 1 });
                    finalSourceName = res.data.albumUnion.name;
                } else {
                    finalSourceName = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${albumId}`).then((r) => r.name);
                }
            } catch (e) {
                if (registerWebApiFailure()) {
                    const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: sourceUriForNaming, locale: "en", offset: 0, limit: 1 });
                    finalSourceName = res.data.albumUnion.name;
                }
            }
        } else {
            finalSourceName = currentPlaylistDetails?.name || "Current Playlist";
        }
        
        let suffixPattern = new RegExp(`\\s*(${possibleSuffixes.join("|")})\\s*`);
        while (suffixPattern.test(finalSourceName)) {
          finalSourceName = finalSourceName.replace(suffixPattern, "");
        }
        const sortTypeInfo = {
          playCount: { fullName: "play count", shortName: "PlayCount" },
          popularity: { fullName: "popularity", shortName: "Popularity" },
          releaseDate: { fullName: "release date", shortName: "ReleaseDate" },
          scrobbles: { fullName: "Last.fm scrobbles", shortName: "Scrobbles" },
          personalScrobbles: { fullName: "Last.fm personal scrobbles", shortName: "My Scrobbles" },
          lastScrobbled: { fullName: "your last scrobbled date", shortName: "Last Scrobbled" },
          shuffle: { fullName: "shuffle", shortName: "Shuffle" },
          averageColor: { fullName: "album color", shortName: "Color" },
          deduplicateOnly: { fullName: "deduplication", shortName: "Deduplicated" },
          filterLiked: { fullName: "hiding liked songs", shortName: "Unliked" },
          keepLiked: { fullName: "keeping only liked songs", shortName: "Liked Only" },
          sortByLiked: { fullName: "liked status", shortName: "Liked" },
          filterSingles: { fullName: "singles only", shortName: "Singles" },
          filterAlbums: { fullName: "albums only", shortName: "Albums" },
          energyWave: { fullName: "energy wave", shortName: "Energy Wave" },
          tempo: { fullName: "tempo (BPM)", shortName: "Tempo" },
          energy: { fullName: "energy", shortName: "Energy" },
          danceability: { fullName: "danceability", shortName: "Danceability" },
          valence: { fullName: "valence", shortName: "Valence" },
          acousticness: { fullName: "acousticness", shortName: "Acousticness" },
          instrumentalness: { fullName: "instrumentalness", shortName: "Instrumentalness" }
        }[sortType];

        if (canModifyCurrentPlaylist) {
            const playlistIdToModify = currentUriAtStart.split(":")[2];
            modifiedPlaylistOriginalPath = initialPagePath; 

            try {
                const requestBody = {
                    description: `Sorted by ${sortTypeInfo.fullName} using Sort-Play`
                };

                if (changeTitleOnModify) {
                    requestBody.name = `${finalSourceName} (${sortTypeInfo.shortName})`;
                }

                try {
                    if (isFallbackActive()) {
                        await Spicetify.Platform.PlaylistAPI.setAttributes(`spotify:playlist:${playlistIdToModify}`, requestBody);
                    } else {
                        try {
                            await Spicetify.CosmosAsync.put(
                                `https://api.spotify.com/v1/playlists/${playlistIdToModify}`,
                                requestBody
                            );
                        } catch (error) {
                            if (registerWebApiFailure()) {
                                await Spicetify.Platform.PlaylistAPI.setAttributes(`spotify:playlist:${playlistIdToModify}`, requestBody);
                            } else {
                                throw error;
                            }
                        }
                    }
                } catch (error) {
                    const isExpectedJsonError = error instanceof SyntaxError && error.message.includes("Unexpected end of JSON input");
                    if (!isExpectedJsonError) {
                        console.warn("An unexpected error occurred while updating playlist details. Proceeding with track replacement.", error);
                    }
                }

                if (!isHeadless) mainButton.innerText = "Saving...";
                const trackUris = sortedTracks.map((track) => track.uri);
                await replacePlaylistTracks(playlistIdToModify, trackUris);
                
                showNotification(`Playlist sorted by ${sortTypeInfo.fullName}!`);
                playlistUriForQueue = currentUriAtStart; 
                playlistWasModifiedOrCreated = true; 

            } catch (error) {
                console.error("Error modifying current playlist:", error);
                showNotification(`An error occurred while modifying the current playlist.`);
                playlistWasModifiedOrCreated = false;
                playlistUriForQueue = currentUriAtStart; 
                modifiedPlaylistOriginalPath = null; 
            }
        } else {
            if (sortCurrentPlaylistEnabled && URI.isPlaylistV1OrV2(currentUriAtStart) && (!currentPlaylistDetails || !currentPlaylistDetails.owner || currentPlaylistDetails.owner.id !== user.username)) {
            }
            try {
              if (showRemovedDuplicates && removedTracks.length > 0 && !isArtistPage) {
                showRemovedTracksModal(removedTracks);
              }
              let playlistDescription = `Sorted by ${sortTypeInfo.fullName} using Sort-Play`;
              if (isArtistPage) {
                playlistDescription = `Discography of ${finalSourceName} - created and sorted by ${sortTypeInfo.fullName} using Sort-Play`
              } else if (isAlbumPage) {
                const albumId = currentUriAtStart.split(":")[2];
                let artistName = "Unknown Artist";
                
                try {
                    const fetchAlbumArtistFallback = async () => {
                        const res = await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, { uri: currentUriAtStart, locale: "en", offset: 0, limit: 1 });
                        if (res.data.albumUnion.artists.items.length > 0) {
                            return res.data.albumUnion.artists.items[0].profile.name;
                        }
                        return "Unknown Artist";
                    };

                    if (isFallbackActive()) {
                        artistName = await fetchAlbumArtistFallback();
                    } else {
                        try {
                            const albumDetails = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums/${albumId}`);
                            artistName = albumDetails.artists[0].name;
                        } catch (e) {
                            if (registerWebApiFailure()) {
                                artistName = await fetchAlbumArtistFallback();
                            } else {
                                throw e;
                            }
                        }
                    }
                } catch (e) { console.warn("Failed to fetch album artist for description", e); }

                playlistDescription = `Tracks from ${finalSourceName} by ${artistName} - created and sorted by ${sortTypeInfo.fullName} using Sort-Play`;
              }

              if (playlistDescription.length > 300) {
                playlistDescription = playlistDescription.substring(0, 296) + "...";
              }

              if (!isHeadless) mainButton.innerText = "Creating...";

              let basePlaylistName = finalSourceName;
              if (changeTitleOnCreate) {
                  basePlaylistName = `${finalSourceName} (${sortTypeInfo.shortName})`;
              }

              const allTrackUris = sortedTracks.map((track) => track.uri);
              const PLAYLIST_LIMIT = 11000;
              const totalParts = Math.ceil(allTrackUris.length / PLAYLIST_LIMIT);

              for (let i = 0; i < totalParts; i++) {
                  let currentPlaylistName = basePlaylistName;
                  if (totalParts > 1) {
                      currentPlaylistName += ` (${i + 1}/${totalParts})`;
                  }

                  if (!isHeadless) mainButton.innerText = "Creating...";

                  const newPlaylist = await createPlaylist(currentPlaylistName, playlistDescription);
                  
                  await new Promise(resolve => setTimeout(resolve, 1250));
                  
                  if (i === 0) {
                      playlistUriForQueue = newPlaylist.uri;
                      newPlaylistObjectForNavigation = newPlaylist; 
                      playlistWasModifiedOrCreated = true;
                  }

                  if (!isHeadless) mainButton.innerText = "Saving...";
                  
                  if (isArtistPage) {
                    try {
                      const artistImageUrl = await getArtistImageUrl(currentUriAtStart.split(":")[2]);
                      if (artistImageUrl) {
                        const base64Image = await toBase64(artistImageUrl);
                        await setPlaylistImage(newPlaylist.id, base64Image);
                      }
                    } catch (error) { 
                        console.error("Error setting playlist image:", error);
                        if (i === 0) showNotification("Failed to copy artist image to playlist cover.", 'warning');
                    }
                  } else if (sourcePlaylistCoverUrl && !isDefaultMosaicCover(sourcePlaylistCoverUrl)) {
                    try {
                      const base64Image = await imageUrlToBase64(sourcePlaylistCoverUrl);
                      await setPlaylistImage(newPlaylist.id, base64Image);
                    } catch (error) {
                      console.warn("Could not apply original playlist/album cover:", error);
                      if (i === 0) showNotification("Failed to copy original cover image.", 'warning');
                    }
                  }

                  const start = i * PLAYLIST_LIMIT;
                  const end = start + PLAYLIST_LIMIT;
                  const batchUris = allTrackUris.slice(start, end);
                  await addTracksToPlaylist(newPlaylist.id, batchUris);

                  await addPlaylistToLibrary(newPlaylist.uri);
              }

              showNotification(`Playlist sorted by ${sortTypeInfo.fullName}!`);

            } catch (error) {
              console.error("Error creating or updating playlist:", error);
              showNotification(`An error occurred while creating the playlist.`);
              playlistWasModifiedOrCreated = false;
              playlistUriForQueue = currentUriAtStart;
              newPlaylistObjectForNavigation = null;
            }
        }
      }

      if (missingDataCount > 0 && ['tempo', 'energy', 'danceability', 'valence', 'acousticness', 'instrumentalness', 'energyWave'].includes(sortType)) {
        const sortTypeInfo = {
            tempo: { fullName: "tempo (BPM)" },
            energy: { fullName: "energy" },
            danceability: { fullName: "danceability" },
            valence: { fullName: "valence" },
            acousticness: { fullName: "acousticness" },
            instrumentalness: { fullName: "instrumentalness" },
            energyWave: { fullName: "audio features" }
        }[sortType];

        const plural = missingDataCount === 1 ? "track was" : "tracks were";
        setTimeout(() => {
            showNotification(`${missingDataCount} ${plural} missing ${sortTypeInfo.fullName} data.`, 'warning');
        }, 1500);
      }
      
      if (addToQueueEnabled && isDirectSortType(sortType) && sortedTracks && sortedTracks.length > 0) {
        try {
          await setQueueFromTracks(sortedTracks, playlistUriForQueue);
        } catch (queueError) {
          console.error("Failed to add sorted tracks to queue:", queueError);
          showNotification("Failed to add to queue.", true);
        }
      } else if (addToQueueEnabled && isDirectSortType(sortType) && (!sortedTracks || sortedTracks.length === 0)) {
          showNotification("No tracks to add to queue after sorting/filtering.", true);
      }

      if (isDirectSortType(sortType) && !playlistWasModifiedOrCreated && !addToQueueEnabled) {
        if (sortedTracks && sortedTracks.length > 0) {
             showNotification(`Sorting complete for ${sortType}. No playlist created or queue modified as per settings.`);
        }
      } else if (isDirectSortType(sortType) && !createPlaylistAfterSort && addToQueueEnabled) {
        console.log(`Playlist creation skipped for ${sortType} due to setting, tracks added to queue.`);
      } else if (isDirectSortType(sortType) && !createPlaylistAfterSort && !addToQueueEnabled) {
        console.log(`Playlist creation and queueing skipped for ${sortType} due to settings.`);
      }

      if (playlistWasModifiedOrCreated) {
          if (modifiedPlaylistOriginalPath) { 
              const currentPathAfterSort = Spicetify.Platform.History.location.pathname;
              if (openPlaylistAfterSortEnabled || currentPathAfterSort === modifiedPlaylistOriginalPath) {
                  const tempPath = "/library"; 
                  Spicetify.Platform.History.push(tempPath);
                  await new Promise(resolve => setTimeout(resolve, 1000));
                  Spicetify.Platform.History.push(modifiedPlaylistOriginalPath); 
              }
          } else if (newPlaylistObjectForNavigation) { 
              await navigateToPlaylist(newPlaylistObjectForNavigation);
          }
      }


    } catch (error) {
      console.error("Error during sorting process:", error);
      showNotification(`An error occurred during the sorting process: ${error.message}`);
    } finally {
      if (!isHeadless) {
        resetButtons();
      }
    }
  }

  const KEY_TO_CAMELOT_MAP = {
    "B": "1B", "Fâ™¯/Gâ™­": "2B", "Câ™¯/Dâ™­": "3B", "Gâ™¯/Aâ™­": "4B", "Dâ™¯/Eâ™­": "5B", 
    "Aâ™¯/Bâ™­": "6B", "F": "7B", "C": "8B", "G": "9B", "D": "10B", "A": "11B", "E": "12B",
    "Gâ™¯/Aâ™­m": "1A", "Dâ™¯/Eâ™­m": "2A", "Aâ™¯/Bâ™­m": "3A", "Fm": "4A", "Cm": "5A", 
    "Gm": "6A", "Dm": "7A", "Am": "8A", "Em": "9A", "Bm": "10A", "Fâ™¯/Gâ™­m": "11A", "Câ™¯/Dâ™­m": "12A"
  };


  function getHarmonicCompatibilityScore(camelotKey1, camelotKey2) {
    if (!camelotKey1 || !camelotKey2) return 25;

    const num1 = parseInt(camelotKey1.slice(0, -1));
    const mode1 = camelotKey1.slice(-1);
    const num2 = parseInt(camelotKey2.slice(0, -1));
    const mode2 = camelotKey2.slice(-1);

    if (isNaN(num1) || isNaN(num2)) return 25;

    const sameMode = mode1 === mode2;
    
    const clockwiseDiff = ((num2 - num1) % 12 + 12) % 12;
    const counterClockwiseDiff = ((num1 - num2) % 12 + 12) % 12;
    const diff = Math.min(clockwiseDiff, counterClockwiseDiff);

    if (diff === 0 && sameMode) return 100;
    
    if (diff === 0 && !sameMode) return 85;

    if (diff === 1) {
        if (sameMode) return 90;
        return 75;
    }
    
    if (diff === 2) {
        if (sameMode) return 60;
        return 45;
    }
    
    if (diff === 7 || diff === 5) {
        if (sameMode) return 55;
        return 40;
    }
    
    if (diff === 3) {
        if (sameMode) return 40;
        return 30;
    }
    
    if (diff === 4) {
        if (sameMode) return 25;
        return 15;
    }
    
    if (diff === 6) return 5;
    
    return 10;
  }


  function generateJourneyMap(playlistLength, persona = 'wave') {
    const patterns = {
        workout: {
            core: [
                'Medium-Energy/Positive-Valence',
                'High-Energy/Positive-Valence',
                'High-Energy/Neutral-Valence',
                'High-Energy/Positive-Valence',
                'Medium-Energy/Positive-Valence',
                'High-Energy/Neutral-Valence',
                'High-Energy/Positive-Valence',
                'Medium-Energy/Neutral-Valence',
            ],
            openingOverride: 'Medium-Energy/Positive-Valence',
            closingOverride: 'Medium-Energy/Positive-Valence'
        },
        wave: {
            core: [
                'Medium-Energy/Neutral-Valence',
                'Medium-Energy/Positive-Valence',
                'High-Energy/Positive-Valence',
                'High-Energy/Neutral-Valence',
                'Medium-Energy/Positive-Valence',
                'Medium-Energy/Neutral-Valence',
                'Low-Energy/Positive-Valence',
                'Low-Energy/Neutral-Valence',
                'Medium-Energy/Neutral-Valence',
                'Medium-Energy/Positive-Valence',
                'High-Energy/Neutral-Valence',
                'High-Energy/Positive-Valence',
                'Medium-Energy/Positive-Valence',
                'Low-Energy/Positive-Valence',
            ],
            openingOverride: 'Medium-Energy/Positive-Valence',
            closingOverride: 'Medium-Energy/Positive-Valence'
        },
        chill: {
            core: [
                'Medium-Energy/Positive-Valence',
                'Low-Energy/Positive-Valence',
                'Low-Energy/Neutral-Valence',
                'Low-Energy/Positive-Valence',
                'Medium-Energy/Neutral-Valence',
                'Low-Energy/Neutral-Valence',
                'Low-Energy/Positive-Valence',
                'Low-Energy/Neutral-Valence',
            ],
            openingOverride: 'Medium-Energy/Positive-Valence',
            closingOverride: 'Low-Energy/Positive-Valence'
        },
        focus: {
            core: [
                'Medium-Energy/Neutral-Valence',
                'Medium-Energy/Neutral-Valence',
                'Low-Energy/Neutral-Valence',
                'Medium-Energy/Neutral-Valence',
                'Low-Energy/Positive-Valence',
                'Medium-Energy/Neutral-Valence',
                'Low-Energy/Neutral-Valence',
                'Medium-Energy/Neutral-Valence',
            ],
            openingOverride: 'Medium-Energy/Neutral-Valence',
            closingOverride: 'Medium-Energy/Neutral-Valence'
        },
        party: {
            core: [
                'Medium-Energy/Positive-Valence',
                'High-Energy/Positive-Valence',
                'High-Energy/Positive-Valence',
                'High-Energy/Neutral-Valence',
                'High-Energy/Positive-Valence',
                'Medium-Energy/Positive-Valence',
                'High-Energy/Positive-Valence',
                'High-Energy/Positive-Valence',
            ],
            openingOverride: 'Medium-Energy/Positive-Valence',
            closingOverride: 'High-Energy/Positive-Valence'
        },
        discovery: {
            core: [
                'Medium-Energy/Positive-Valence',
                'Medium-Energy/Neutral-Valence',
                'High-Energy/Positive-Valence',
                'Medium-Energy/Neutral-Valence',
                'Low-Energy/Positive-Valence',
                'Low-Energy/Neutral-Valence',
                'Medium-Energy/Positive-Valence',
                'High-Energy/Neutral-Valence',
                'Medium-Energy/Positive-Valence',
                'Low-Energy/Neutral-Valence',
                'Medium-Energy/Neutral-Valence',
                'High-Energy/Positive-Valence',
                'Medium-Energy/Positive-Valence',
            ],
            openingOverride: 'Medium-Energy/Positive-Valence',
            closingOverride: 'Medium-Energy/Positive-Valence'
        }
    };

    const selectedPattern = patterns[persona] || patterns.wave;
    const { core, openingOverride, closingOverride } = selectedPattern;
    
    const journeyMap = [];

    for (let i = 0; i < playlistLength; i++) {
        let step;
        
        if (i < core.length) {
            step = core[i];
        } else {
            const phasePosition = i % core.length;
            step = core[phasePosition];
            
            if (i > core.length && Math.random() < 0.15) {
                const tiers = ['Low', 'Medium', 'High'];
                const valences = ['Negative-Valence', 'Neutral-Valence', 'Positive-Valence'];
                
                const [energyPart] = step.split('/');
                const currentEnergyIndex = tiers.findIndex(t => energyPart.includes(t));
                
                const shift = Math.random() > 0.5 ? 1 : -1;
                const newEnergyIndex = Math.max(0, Math.min(2, currentEnergyIndex + shift));
                step = `${tiers[newEnergyIndex]}-Energy/${valences[1 + Math.floor(Math.random() * 2)]}`;
            }
        }
        
        journeyMap.push(step);
    }
    
    if (playlistLength >= 3) {
        journeyMap[0] = openingOverride;
        journeyMap[playlistLength - 1] = closingOverride;
        
        if (journeyMap[1]?.includes('High-Energy') && openingOverride.includes('Medium-Energy')) {
            journeyMap[1] = 'Medium-Energy/Positive-Valence';
        }
    }
    
    return journeyMap;
  }
  
  async function energyWaveSort(tracks, persona = 'wave') {
    if (tracks.length < 3) {
        return tracks;
    }

    const getTier = (val) => {
        if (val === undefined || val === null) return 'Medium';
        const normalized = val <= 1 ? val : val / 100;
        return normalized <= 0.33 ? 'Low' : normalized <= 0.66 ? 'Medium' : 'High';
    };

    const normalize = (val) => {
        if (val === undefined || val === null) return null;
        return val <= 1 ? val : val / 100;
    };

    const versionKeywords = [
        'remastered', 'remaster', '\\d{4} remaster', 'anniversary edition',
        'deluxe edition', 'super deluxe', 'legacy edition', 'mono', 'stereo',
        'radio edit', 'radio mix', 'radio', 'single version', 'single edit', 'album version',
        'extended mix', 'extended version', 'club mix', 'clean', 'explicit',
        'special edition', 'original mix', 'original version', 'live', 'live at',
        'live in', 'live from', 'feat\\.?', 'ft\\.?', 'featuring', 'demo',
        'instrumental', 'acoustic'
    ];
    const versionRegex = new RegExp(`[\\(\\[\\-]?\\s*(${versionKeywords.join('|')})[^\\)\\]]*[\\)\\]\\-]?`, 'gi');

    const getCleanTitle = (rawTitle) => {
        if (!rawTitle) return "";
        return rawTitle
            .toLowerCase()
            .replace(versionRegex, '')
            .replace(/['â€™Ê¼]/g, "'")
            .replace(/[^a-z0-9\s]/g, '')
            .replace(/\s+/g, ' ')
            .trim();
    };

    const trackProfiles = tracks.map(track => {
        const f = track.features || {};
        
        const energy = normalize(f.energy);
        const valence = normalize(f.valence);
        const danceability = normalize(f.danceability);
        const acousticness = normalize(f.acousticness);
        const instrumentalness = normalize(f.instrumentalness);
        const speechiness = normalize(f.speechiness);
        const liveness = normalize(f.liveness);
        
        const moodBucket = `${getTier(energy)}-Energy/${getTier(valence)}-Valence`;

        const keyName = f.key || "C";
        const mode = f.mode === 0 ? 'm' : '';
        const camelotKey = KEY_TO_CAMELOT_MAP[keyName + mode] || KEY_TO_CAMELOT_MAP[keyName] || null;

        return {
            ...track,
            profile: { 
                moodBucket, 
                camelotKey, 
                tempo: f.tempo || null,
                energy: energy ?? 0.5,
                valence: valence ?? 0.5,
                danceability: danceability ?? 0.5,
                acousticness: acousticness ?? 0.5,
                instrumentalness: instrumentalness ?? 0,
                speechiness: speechiness ?? 0.1,
                liveness: liveness ?? 0.2,
                popularity: track.popularity ?? 50,
                durationMs: track.duration_ms || f.duration_ms || 200000
            }
        };
    });

    const validTempos = trackProfiles.filter(t => t.profile.tempo !== null).map(t => t.profile.tempo);
    const avgTempo = validTempos.length > 0 
        ? validTempos.reduce((a, b) => a + b, 0) / validTempos.length 
        : 120;
    
    trackProfiles.forEach(t => {
        if (t.profile.tempo === null) t.profile.tempo = avgTempo;
    });

    const fullJourneyMap = generateJourneyMap(tracks.length, persona);

    const getTempoScore = (lastTempo, candidateTempo) => {
        const directDiff = Math.abs(candidateTempo - lastTempo);
        const halfTimeDiff = Math.abs(candidateTempo - (lastTempo / 2));
        const doubleTimeDiff = Math.abs(candidateTempo - (lastTempo * 2));
        const thirdTimeDiff = Math.abs(candidateTempo - (lastTempo * 2 / 3));
        
        const effectiveDiff = Math.min(directDiff, halfTimeDiff, doubleTimeDiff, thirdTimeDiff);
        const percentDiff = (effectiveDiff / lastTempo) * 100;
        
        if (percentDiff < 3) return 70;
        if (percentDiff < 6) return 55;
        if (percentDiff < 10) return 40;
        if (percentDiff < 15) return 25;
        if (percentDiff < 22) return 5;
        if (percentDiff < 32) return -25;
        if (percentDiff < 45) return -50;
        return -75;
    };

    const getMoodMatchScore = (candidateBucket, targetBucket) => {
        if (candidateBucket === targetBucket) return 100;
        
        const [candEnergy, candValence] = candidateBucket.split('/');
        const [targetEnergy, targetValence] = targetBucket.split('/');
        
        let score = 0;
        
        if (candEnergy === targetEnergy) {
            score += 45;
        } else {
            const energyTiers = ['Low-Energy', 'Medium-Energy', 'High-Energy'];
            const candIndex = energyTiers.indexOf(candEnergy);
            const targetIndex = energyTiers.indexOf(targetEnergy);
            if (Math.abs(candIndex - targetIndex) === 1) score += 20;
        }
        
        if (candValence === targetValence) {
            score += 35;
        } else {
            const valenceTiers = ['Negative-Valence', 'Neutral-Valence', 'Positive-Valence'];
            const candIndex = valenceTiers.indexOf(candValence);
            const targetIndex = valenceTiers.indexOf(targetValence);
            if (candIndex !== -1 && targetIndex !== -1 && Math.abs(candIndex - targetIndex) === 1) {
                score += 15;
            }
        }
        
        return score;
    };

    const getFlowScore = (lastProfile, candProfile) => {
        let score = 0;
        
        const energyDiff = Math.abs(candProfile.energy - lastProfile.energy);
        if (energyDiff < 0.12) score += 30;
        else if (energyDiff < 0.22) score += 15;
        else if (energyDiff < 0.35) score += 0;
        else if (energyDiff < 0.50) score -= 15;
        else score -= 35;
        
        const danceDiff = Math.abs(candProfile.danceability - lastProfile.danceability);
        if (danceDiff < 0.15) score += 20;
        else if (danceDiff < 0.30) score += 8;
        else if (danceDiff > 0.50) score -= 15;
        
        const acousticDiff = Math.abs(candProfile.acousticness - lastProfile.acousticness);
        if (acousticDiff < 0.20) score += 18;
        else if (acousticDiff < 0.40) score += 5;
        else if (acousticDiff > 0.65) score -= 25;
        
        const instrDiff = Math.abs(candProfile.instrumentalness - lastProfile.instrumentalness);
        if (instrDiff < 0.25) score += 12;
        else if (instrDiff > 0.70) score -= 18;
        
        const valenceDiff = Math.abs(candProfile.valence - lastProfile.valence);
        if (valenceDiff < 0.15) score += 15;
        else if (valenceDiff < 0.30) score += 5;
        else if (valenceDiff > 0.55) score -= 12;
        
        return score;
    };

    const selectOpeningTrack = () => {
        const targetStart = fullJourneyMap[0];
        const [targetEnergyTier, targetValenceTier] = targetStart.split('/');
        
        let idealEnergyMin, idealEnergyMax, idealValenceMin, idealValenceMax;
        
        if (targetEnergyTier === 'High-Energy') { idealEnergyMin = 0.66; idealEnergyMax = 1.0; }
        else if (targetEnergyTier === 'Medium-Energy') { idealEnergyMin = 0.33; idealEnergyMax = 0.66; }
        else { idealEnergyMin = 0.0; idealEnergyMax = 0.33; }

        if (targetValenceTier === 'Positive-Valence') { idealValenceMin = 0.66; idealValenceMax = 1.0; }
        else if (targetValenceTier === 'Neutral-Valence') { idealValenceMin = 0.33; idealValenceMax = 0.66; }
        else { idealValenceMin = 0.0; idealValenceMax = 0.33; }

        const candidates = trackProfiles.map(t => {
            let score = 0;
            
            score += getMoodMatchScore(t.profile.moodBucket, targetStart);
            
            if (t.profile.energy >= idealEnergyMin && t.profile.energy <= idealEnergyMax) score += 30;
            if (t.profile.valence >= idealValenceMin && t.profile.valence <= idealValenceMax) score += 20;

            if (t.profile.popularity >= 40) score += 20;
            else if (t.profile.popularity >= 20) score += 10;
            
            if (t.profile.instrumentalness > 0.8 && persona !== 'focus') score -= 20;
            if (t.profile.speechiness > 0.66) score -= 20;
            
            score += Math.random() * 15;
            
            return { track: t, score };
        });
        
        candidates.sort((a, b) => b.score - a.score);
        return candidates[0].track;
    };

    let remainingTracks = [...trackProfiles];
    const sortedPlaylist = [];
    
    const firstTrack = selectOpeningTrack();
    sortedPlaylist.push(firstTrack);
    remainingTracks = remainingTracks.filter(t => t.uri !== firstTrack.uri);
    let lastTrack = firstTrack;

    while (remainingTracks.length > 0) {
        const currentPosition = sortedPlaylist.length;
        const currentJourneyStep = fullJourneyMap[currentPosition] || fullJourneyMap[fullJourneyMap.length - 1];
        const isNearEnd = currentPosition >= tracks.length - 4;
        const isFinalTrack = remainingTracks.length === 1;
        const isSecondToLast = remainingTracks.length === 2;
        
        const lastTitle = getCleanTitle(lastTrack.songTitle || lastTrack.name);

        const scoredCandidates = remainingTracks.map(candidateTrack => {
            let score = 0;
            const candProfile = candidateTrack.profile;
            const lastProfile = lastTrack.profile;

            score += getMoodMatchScore(candProfile.moodBucket, currentJourneyStep);

            const harmonicScore = getHarmonicCompatibilityScore(lastProfile.camelotKey, candProfile.camelotKey);
            score += harmonicScore * 0.85;

            score += getTempoScore(lastProfile.tempo, candProfile.tempo);

            score += getFlowScore(lastProfile, candProfile);

            if (isNearEnd && !isFinalTrack && persona !== 'party' && persona !== 'workout') {
                if (candProfile.energy < 0.65) score += 18;
                if (candProfile.valence > 0.40) score += 12;
            }
            
            if (isSecondToLast) {
                if (candProfile.energy >= 0.45 && candProfile.energy <= 0.75) score += 15;
            }
            
            if (isFinalTrack) {
                if (candProfile.energy >= 0.35 && candProfile.energy <= 0.70) score += 30;
                if (candProfile.valence >= 0.45) score += 25;
                if (candProfile.popularity >= 40) score += 20;
                if (candProfile.tempo >= 80 && candProfile.tempo <= 130) score += 15;
            }

            const candTitle = getCleanTitle(candidateTrack.songTitle || candidateTrack.name);
            if (candTitle === lastTitle && candTitle.length > 0) {
                score -= 1000; 
            }

            score += Math.random() * 4;

            return { track: candidateTrack, score };
        });

        scoredCandidates.sort((a, b) => b.score - a.score);
        const selected = scoredCandidates[0].track;

        sortedPlaylist.push(selected);
        remainingTracks = remainingTracks.filter(t => t.uri !== selected.uri);
        lastTrack = selected;
    }

    return sortedPlaylist.map(profiledTrack => tracks.find(t => t.uri === profiledTrack.uri));
  }

  async function randomizedEnergyWaveSort(tracks, options = {}) {
    const { persona = 'wave', chaos = 0.5 } = options;
    
    if (tracks.length < 3) {
        return [...tracks].sort(() => Math.random() - 0.5);
    }

    const normalize = (val) => {
        if (val === undefined || val === null) return null;
        return val <= 1 ? val : val / 100;
    };

    const getTier = (val) => {
        if (val === undefined || val === null) return 'Medium';
        const normalized = val <= 1 ? val : val / 100;
        return normalized <= 0.33 ? 'Low' : normalized <= 0.66 ? 'Medium' : 'High';
    };

    const versionKeywords = [
        'remastered', 'remaster', '\\d{4} remaster', 'anniversary edition',
        'deluxe edition', 'super deluxe', 'legacy edition', 'mono', 'stereo',
        'radio edit', 'radio mix', 'radio', 'single version', 'single edit', 'album version',
        'extended mix', 'extended version', 'club mix', 'clean', 'explicit',
        'special edition', 'original mix', 'original version', 'live', 'live at',
        'live in', 'live from', 'feat\\.?', 'ft\\.?', 'featuring', 'demo',
        'instrumental', 'acoustic'
    ];
    const versionRegex = new RegExp(`[\\(\\[\\-]?\\s*(${versionKeywords.join('|')})[^\\)\\]]*[\\)\\]\\-]?`, 'gi');

    const getCleanTitle = (rawTitle) => {
        if (!rawTitle) return "";
        return rawTitle
            .toLowerCase()
            .replace(versionRegex, '')
            .replace(/['â€™Ê¼]/g, "'")
            .replace(/[^a-z0-9\s]/g, '')
            .replace(/\s+/g, ' ')
            .trim();
    };

    const trackProfiles = tracks.map(track => {
        const f = track.features || {};
        
        const energy = normalize(f.energy);
        const valence = normalize(f.valence);
        const danceability = normalize(f.danceability);
        const acousticness = normalize(f.acousticness);
        const instrumentalness = normalize(f.instrumentalness);
        
        const moodBucket = `${getTier(energy)}-Energy/${getTier(valence)}-Valence`;

        const keyName = f.key || "C";
        const mode = f.mode === 0 ? 'm' : '';
        const camelotKey = KEY_TO_CAMELOT_MAP[keyName + mode] || KEY_TO_CAMELOT_MAP[keyName] || null;

        return {
            ...track,
            profile: { 
                moodBucket, 
                camelotKey, 
                tempo: f.tempo || null,
                energy: energy ?? 0.5,
                valence: valence ?? 0.5,
                danceability: danceability ?? 0.5,
                acousticness: acousticness ?? 0.5,
                instrumentalness: instrumentalness ?? 0,
                popularity: track.popularity ?? 50
            }
        };
    });

    const validTempos = trackProfiles.filter(t => t.profile.tempo !== null).map(t => t.profile.tempo);
    const avgTempo = validTempos.length > 0 
        ? validTempos.reduce((a, b) => a + b, 0) / validTempos.length 
        : 120;
    
    trackProfiles.forEach(t => {
        if (t.profile.tempo === null) t.profile.tempo = avgTempo;
    });

    const getPoolSize = (remainingCount, chaosLevel) => {
        let baseSize;
        if (remainingCount <= 10) baseSize = 2;
        else if (remainingCount <= 25) baseSize = 3;
        else if (remainingCount <= 50) baseSize = 4;
        else if (remainingCount <= 100) baseSize = 5;
        else baseSize = 6;
        
        const chaosAdjustment = Math.floor((chaosLevel - 0.5) * 4);
        const finalSize = Math.max(2, Math.min(remainingCount, baseSize + chaosAdjustment));
        
        return finalSize;
    };

    const getTempoScore = (lastTempo, candidateTempo) => {
        const directDiff = Math.abs(candidateTempo - lastTempo);
        const halfTimeDiff = Math.abs(candidateTempo - (lastTempo / 2));
        const doubleTimeDiff = Math.abs(candidateTempo - (lastTempo * 2));
        const thirdTimeDiff = Math.abs(candidateTempo - (lastTempo * 2 / 3));
        
        const effectiveDiff = Math.min(directDiff, halfTimeDiff, doubleTimeDiff, thirdTimeDiff);
        const percentDiff = (effectiveDiff / lastTempo) * 100;
        
        if (percentDiff < 3) return 70;
        if (percentDiff < 6) return 55;
        if (percentDiff < 10) return 40;
        if (percentDiff < 15) return 25;
        if (percentDiff < 22) return 5;
        if (percentDiff < 32) return -25;
        if (percentDiff < 45) return -50;
        return -75;
    };

    const getMoodMatchScore = (candidateBucket, targetBucket) => {
        if (candidateBucket === targetBucket) return 100;
        
        const [candEnergy, candValence] = candidateBucket.split('/');
        const [targetEnergy, targetValence] = targetBucket.split('/');
        
        let score = 0;
        
        if (candEnergy === targetEnergy) {
            score += 45;
        } else {
            const energyTiers = ['Low-Energy', 'Medium-Energy', 'High-Energy'];
            const candIndex = energyTiers.indexOf(candEnergy);
            const targetIndex = energyTiers.indexOf(targetEnergy);
            if (Math.abs(candIndex - targetIndex) === 1) score += 20;
        }
        
        if (candValence === targetValence) {
            score += 35;
        } else {
            const valenceTiers = ['Negative-Valence', 'Neutral-Valence', 'Positive-Valence'];
            const candIndex = valenceTiers.indexOf(candValence);
            const targetIndex = valenceTiers.indexOf(targetValence);
            if (candIndex !== -1 && targetIndex !== -1 && Math.abs(candIndex - targetIndex) === 1) {
                score += 15;
            }
        }
        
        return score;
    };

    const getFlowScore = (lastProfile, candProfile) => {
        let score = 0;
        
        const energyDiff = Math.abs(candProfile.energy - lastProfile.energy);
        if (energyDiff < 0.12) score += 25;
        else if (energyDiff < 0.22) score += 12;
        else if (energyDiff < 0.35) score += 0;
        else if (energyDiff < 0.50) score -= 10;
        else score -= 25;
        
        const danceDiff = Math.abs(candProfile.danceability - lastProfile.danceability);
        if (danceDiff < 0.15) score += 15;
        else if (danceDiff < 0.30) score += 6;
        else if (danceDiff > 0.50) score -= 12;
        
        const acousticDiff = Math.abs(candProfile.acousticness - lastProfile.acousticness);
        if (acousticDiff < 0.20) score += 15;
        else if (acousticDiff < 0.40) score += 4;
        else if (acousticDiff > 0.65) score -= 20;
        
        const instrDiff = Math.abs(candProfile.instrumentalness - lastProfile.instrumentalness);
        if (instrDiff < 0.25) score += 10;
        else if (instrDiff > 0.70) score -= 15;
        
        return score;
    };

    const weightedRandomSelect = (candidates, chaosLevel) => {
        if (candidates.length === 0) return null;
        if (candidates.length === 1) return candidates[0];
        
        const minScore = Math.min(...candidates.map(c => c.score));
        const normalizedCandidates = candidates.map(c => ({
            ...c,
            normalizedScore: c.score - minScore + 10
        }));
        
        const flatteningPower = 1 - (chaosLevel * 0.8);
        const weightedCandidates = normalizedCandidates.map(c => ({
            ...c,
            weight: Math.pow(c.normalizedScore, flatteningPower)
        }));
        
        const totalWeight = weightedCandidates.reduce((sum, c) => sum + c.weight, 0);
        
        let random = Math.random() * totalWeight;
        for (const candidate of weightedCandidates) {
            random -= candidate.weight;
            if (random <= 0) {
                return candidate;
            }
        }
        
        return weightedCandidates[weightedCandidates.length - 1];
    };

    const fullJourneyMap = generateJourneyMap(tracks.length, persona);

    const selectOpeningTrack = () => {
        const candidates = trackProfiles.map(t => {
            let score = 0;
            
            score += getMoodMatchScore(t.profile.moodBucket, fullJourneyMap[0]) * 0.7;
            
            if (t.profile.energy >= 0.40 && t.profile.energy <= 0.72) score += 35;
            if (t.profile.valence >= 0.45) score += 25;
            if (t.profile.tempo >= 85 && t.profile.tempo <= 135) score += 15;
            
            score += Math.random() * 30 * chaos;
            
            return { track: t, score };
        });
        
        candidates.sort((a, b) => b.score - a.score);
        
        const openerPoolSize = Math.max(2, Math.floor(3 + chaos * 4));
        const topOpeners = candidates.slice(0, Math.min(openerPoolSize, candidates.length));
        
        return weightedRandomSelect(topOpeners, chaos).track;
    };

    let remainingTracks = [...trackProfiles];
    const sortedPlaylist = [];

    const firstTrack = selectOpeningTrack();
    sortedPlaylist.push(firstTrack);
    remainingTracks = remainingTracks.filter(t => t.uri !== firstTrack.uri);
    let lastTrack = firstTrack;

    while (remainingTracks.length > 0) {
        const currentPosition = sortedPlaylist.length;
        const currentJourneyStep = fullJourneyMap[currentPosition] || fullJourneyMap[fullJourneyMap.length - 1];
        const isNearEnd = currentPosition >= tracks.length - 3;
        const isFinalTrack = remainingTracks.length === 1;

        const lastTitle = getCleanTitle(lastTrack.songTitle || lastTrack.name);

        const scoredCandidates = remainingTracks.map(candidateTrack => {
            let score = 0;
            const candProfile = candidateTrack.profile;
            const lastProfile = lastTrack.profile;

            score += getMoodMatchScore(candProfile.moodBucket, currentJourneyStep) * 0.85;

            const harmonicScore = getHarmonicCompatibilityScore(lastProfile.camelotKey, candProfile.camelotKey);
            score += harmonicScore * 0.75;

            score += getTempoScore(lastProfile.tempo, candProfile.tempo);

            score += getFlowScore(lastProfile, candProfile) * 0.8;

            if (isFinalTrack) {
                if (candProfile.energy >= 0.35 && candProfile.energy <= 0.70) score += 20;
                if (candProfile.valence >= 0.45) score += 15;
            }

            if (isNearEnd && !isFinalTrack && persona !== 'party') {
                if (candProfile.energy < 0.65) score += 12;
            }

            const candTitle = getCleanTitle(candidateTrack.songTitle || candidateTrack.name);
            if (candTitle === lastTitle && candTitle.length > 0) {
                score -= 500;
            }

            return { track: candidateTrack, score };
        });

        scoredCandidates.sort((a, b) => b.score - a.score);

        const poolSize = getPoolSize(remainingTracks.length, chaos);
        const topCandidates = scoredCandidates.slice(0, Math.min(poolSize, scoredCandidates.length));

        const selected = weightedRandomSelect(topCandidates, chaos);

        sortedPlaylist.push(selected.track);
        remainingTracks = remainingTracks.filter(t => t.uri !== selected.track.uri);
        lastTrack = selected.track;
    }

    return sortedPlaylist.map(profiledTrack => tracks.find(t => t.uri === profiledTrack.uri));
  }

  function shuffleArray(array) {
    if (array.length < 10) {
      return simpleShuffle(array);
    } else {
      return complexShuffle(array);
    }
  }

  function simpleShuffle(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  function complexShuffle(array) {
    let shuffled = [...array];

    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }

    const mid = Math.floor(shuffled.length / 2);
    const firstHalf = shuffled.slice(0, mid);
    const secondHalf = shuffled.slice(mid);
    
    shuffled = [];
    while (firstHalf.length || secondHalf.length) {
        if (Math.random() < 0.5 && firstHalf.length) {
            shuffled.push(firstHalf.pop());
        } else if (secondHalf.length) {
            shuffled.push(secondHalf.pop());
        } else if (firstHalf.length) {
            shuffled.push(firstHalf.pop());
        }
    }
    const chunkSize = Math.floor(Math.random() * 5) + 3;  
    for (let i = 0; i < shuffled.length; i += chunkSize) {
        const chunk = shuffled.slice(i, i + chunkSize);
        const rotateBy = Math.floor(Math.random() * chunk.length);
        const rotatedChunk = [
            ...chunk.slice(rotateBy),
            ...chunk.slice(0, rotateBy)
        ];
        shuffled.splice(i, chunk.length, ...rotatedChunk);
    }
    const breakUpClusters = (arr) => {
        for (let i = 0; i < arr.length - 2; i++) {
            if (arr[i].artists?.[0]?.uri === arr[i + 1].artists?.[0]?.uri &&
                arr[i].artists?.[0]?.uri === arr[i + 2].artists?.[0]?.uri) {
                const moveIdx = i + 1;
                const trackToMove = arr[moveIdx];
                const minDistance = 5;
                let newPosition;
                do {
                    newPosition = Math.floor(Math.random() * arr.length);
                } while (Math.abs(newPosition - moveIdx) < minDistance);
                
                arr.splice(moveIdx, 1);
                arr.splice(newPosition, 0, trackToMove);
                i++;
            }
        }
        return arr;
    };
    
    return breakUpClusters(shuffled);
  }

  function showRemovedTracksModal(removedTracks) {

    const styleId = 'sort-play-global-modal-height-fix';
    if (!document.getElementById(styleId)) {
      const styleElement = document.createElement('style');
      styleElement.id = styleId;
      styleElement.innerHTML = `
        .GenericModal > .main-embedWidgetGenerator-container {
          height: auto !important;
        }
      `;
      document.head.appendChild(styleElement);
    }

    const modalContainer = document.createElement("div");
    modalContainer.style.width = "800px"; 
    modalContainer.style.maxHeight = "auto";
    modalContainer.style.overflowY = "auto";
    modalContainer.style.display = "flex";  
    modalContainer.style.flexDirection = "column";  

    const textAreaContainer = document.createElement("div");
    textAreaContainer.style.overflowY = "auto";
    textAreaContainer.style.flexGrow = "1"; 
  
    const trackListTextArea = document.createElement("textarea");
    trackListTextArea.style.width = "100%";
    trackListTextArea.style.border = "1px solid #ccc";
    trackListTextArea.style.padding = "10px";
    trackListTextArea.style.boxSizing = "border-box";
    trackListTextArea.style.resize = "none"; 
    trackListTextArea.readOnly = true;
    trackListTextArea.style.minHeight = "300px";
  
    let trackListText = "";
    removedTracks.forEach((track, index) => {
      trackListText += `${index + 1}. ${track.songTitle} - ${track.artistName} - ${track.albumName} - (${track.uri})\n`;
    });
  
    trackListTextArea.value = trackListText;

    textAreaContainer.appendChild(trackListTextArea);

    const copyButton = document.createElement("button");
    copyButton.textContent = "Copy to Clipboard";
    copyButton.style.marginTop = "10px";
    copyButton.style.padding = "6px 12px";
    copyButton.style.width = "250px"; 
    copyButton.style.backgroundColor = "#1ED760";
    copyButton.style.color = "black";
    copyButton.style.border = "none";
    copyButton.style.borderRadius = "20px";
    copyButton.style.cursor = "pointer";
  
    copyButton.addEventListener("click", () => {
      navigator.clipboard.writeText(trackListTextArea.value).then(
        () => {
          showNotification("Tracks copied to clipboard!");
        },
        (err) => {
          console.error("Failed to copy:", err);
          showNotification("Failed to copy tracks to clipboard.");
        }
      );
    });

    modalContainer.appendChild(textAreaContainer);
    modalContainer.appendChild(copyButton);
  
    Spicetify.PopupModal.display({
      title: "Removed Duplicate Tracks",
      content: modalContainer,
      isLarge: true,
    });
  }
  

  async function deduplicateTracks(tracks, force = false, isArtistPageContext = false, updateProgress = () => {}) {
    if (!force && !playlistDeduplicate && !isArtistPageContext) {
        return { unique: tracks, removed: [] };
    }

    const fastYield = () => new Promise(resolve => {
        const channel = new MessageChannel();
        channel.port1.onmessage = resolve;
        channel.port2.postMessage(null);
    });

    const tracksWithIds = tracks.filter(t => t.uri.startsWith("spotify:track:"));
    const trackIds = tracksWithIds.map(t => t.uri.split(":")[2]);
    const uniqueTrackIds = [...new Set(trackIds)];

    const cachedMetadata = await idb.getMany('trackMetadata', uniqueTrackIds, CACHE_EXPIRE_METADATA);
    const missingIds = uniqueTrackIds.filter(id => {
        const meta = cachedMetadata.get(id);
        return !meta || !meta.external_ids || !meta.external_ids.isrc;
    });

    if (missingIds.length > 0) {
        const BATCH_SIZE = 50;
        
        const processDedupeInternal = async (id) => {
            const data = await fetchInternalTrackMetadata(id);
            if (data) {
                const cacheData = {
                    name: data.name,
                    album: {
                        name: data.album.name,
                        id: data.album.id,
                        uri: data.album.uri,
                        release_date: data.album.release_date,
                        album_type: 'album'
                    },
                    artists: data.artists.map(a => ({
                        id: a.id,
                        name: a.name,
                        uri: a.uri
                    })),
                    duration_ms: data.duration_ms,
                    popularity: data.popularity,
                    external_ids: data.external_ids,
                    id: data.id,
                    uri: data.uri
                };
                cachedMetadata.set(data.id, cacheData);
                idb.set('trackMetadata', data.id, cacheData);
            }
        };

        for (let i = 0; i < missingIds.length; i += BATCH_SIZE) {
            const batch = missingIds.slice(i, i + BATCH_SIZE);
            
            if (isFallbackActive()) {
                await Promise.all(batch.map(id => processDedupeInternal(id)));
            } else {
                try {
                    const response = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${batch.join(',')}`);
                    if (response && response.tracks) {
                        response.tracks.forEach(track => {
                            if (track) {
                                const cacheData = {
                                    name: track.name,
                                    album: {
                                        name: track.album.name,
                                        id: track.album.id,
                                        uri: track.album.uri,
                                        release_date: track.album.release_date,
                                        album_type: track.album.album_type
                                    },
                                    artists: track.artists.map(a => ({
                                        id: a.id,
                                        name: a.name,
                                        uri: a.uri
                                    })),
                                    duration_ms: track.duration_ms,
                                    popularity: track.popularity,
                                    external_ids: track.external_ids,
                                    id: track.id,
                                    uri: track.uri
                                };
                                cachedMetadata.set(track.id, cacheData);
                                idb.set('trackMetadata', track.id, cacheData);
                            }
                        });
                    }
                } catch (e) {
                    if (registerWebApiFailure()) {
                        await Promise.all(batch.map(id => processDedupeInternal(id)));
                    } else {
                        console.warn("[Sort-Play] Failed to fetch ISRC batch during deduplication", e);
                    }
                }
            }
        }
    }

    const DURATION_THRESHOLD = 2000; 
    const finalUniqueTracks = [];
    const finalRemovedTracks = [];

    const fetchIsrc = async (id) => {
        if (!id) return null;
        
        if (cachedMetadata.has(id)) {
            return cachedMetadata.get(id)?.external_ids?.isrc;
        }

        const cached = await idb.get('trackMetadata', id, CACHE_EXPIRE_METADATA);
        if (cached?.external_ids?.isrc) {
            cachedMetadata.set(id, cached);
            return cached.external_ids.isrc;
        }

        try {
            const res = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks/${id}`);
            if (res?.external_ids?.isrc) {
                const cacheData = {
                    name: res.name,
                    album: {
                        name: res.album.name,
                        id: res.album.id,
                        uri: res.album.uri,
                        release_date: res.album.release_date,
                        album_type: res.album.album_type
                    },
                    artists: res.artists.map(a => ({
                        id: a.id,
                        name: a.name,
                        uri: a.uri
                    })),
                    duration_ms: res.duration_ms,
                    popularity: res.popularity,
                    external_ids: res.external_ids,
                    id: res.id,
                    uri: res.uri
                };
                cachedMetadata.set(id, cacheData);
                await idb.set('trackMetadata', id, cacheData);
                return res.external_ids.isrc;
            }
        } catch(e) {}
        return null;
    };

    const versionKeywords = [
        'remastered', 'remaster', '\\d{4} remaster', 'anniversary edition',
        'deluxe edition', 'super deluxe', 'legacy edition', 'mono', 'stereo',
        'radio edit', 'radio mix', 'single version', 'single edit', 'album version',
        'extended mix', 'extended version', 'club mix', 'clean', 'explicit',
        'special edition', 'original mix', 'original version'
    ];
    const versionRegex = new RegExp(`[\\(\\[\\-]?\\s*(${versionKeywords.join('|')})\\s*[\\)\\]\\-]?`, 'i');

    const getCleanTitle = (rawTitle) => {
        return rawTitle
            .toLowerCase()
            .replace(versionRegex, '')
            .replace(/['â€™Ê¼]/g, "'")
            .replace(/[^a-z0-9\s]/g, '')
            .replace(/\s+/g, ' ')
            .trim();
    };
    
    const getNormalizedTitle = (rawTitle) => {
        return rawTitle
            .trim()
            .toLowerCase()
            .replace(/['â€™Ê¼]/g, "'")
            .replace(/[()\[\],.:-]/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
    };

    const normalizeAndSplitArtists = (artistStr) => {
        const clean = (name) => name.toLowerCase().replace(/[.&]/g, '').replace(/\s+/g, ' ').trim();
        return artistStr.split(',').map(a => clean(a.trim()));
    };

    const wordBuckets = new Map();
    const fallbackBucket = [];
    const cleanTitleBuckets = new Map();
    const playCountBuckets = new Map();

    const getTokens = (str) => {
        if (!str) return [];
        return str.toLowerCase()
            .replace(/[^\p{L}\p{N}\s]/gu, ' ')
            .split(/\s+/)
            .filter(w => w.length > 0);
    };

    const sortedInputTracks = [...tracks].sort((a, b) => {
        const popA = a.popularity || 0;
        const popB = b.popularity || 0;
        if (popB !== popA) {
            return popB - popA;
        }
        return (a.uri || "").localeCompare(b.uri || "");
    });

    const BATCH_PROCESS_SIZE = 200;

    const trackCleanData = new Map();
    for (const track of sortedInputTracks) {
        const rawTitle = track.songTitle || track.name || "Unknown Title";
        const artist = track.allArtists || track.artistName || "";
        trackCleanData.set(track, {
            rawTitle,
            rawTitleLower: rawTitle.trim().toLowerCase(),
            cleanTitle: getCleanTitle(rawTitle),
            normalizedTitle: getNormalizedTitle(rawTitle),
            tokens: getTokens(rawTitle),
            artistSet: new Set(normalizeAndSplitArtists(artist)),
            artist,
            duration: track.durationMs,
            hasVersionKeyword: versionRegex.test(rawTitle)
        });
    }
    
    for (let i = 0; i < sortedInputTracks.length; i++) {
        if (i % BATCH_PROCESS_SIZE === 0 && i > 0) {
            await fastYield();
            updateProgress(Math.floor((i / sortedInputTracks.length) * 100));
        }

        const candidateTrack = sortedInputTracks[i];
        let isConsideredDuplicateOfAnExistingUnique = false;

        const candData = trackCleanData.get(candidateTrack);
        const candidateDuration = candData.duration;
        const candidateArtist = candData.artist;
        const candTokens = candData.tokens;
        const candidateCleanTitle = candData.cleanTitle;
        const candidateArtistSet = candData.artistSet;
        
        const candidateHasValidPlayCount = candidateTrack.playCount !== "N/A" &&
                                          candidateTrack.playCount !== 0 &&
                                          candidateTrack.playCount !== null &&
                                          candidateTrack.playCount !== undefined;

        const potentialMatches = new Set();
        
        if (candTokens.length === 0) {
            for (let k = 0; k < fallbackBucket.length; k++) {
                potentialMatches.add(fallbackBucket[k]);
            }
        } else {
            for (let t = 0; t < candTokens.length; t++) {
                const token = candTokens[t];
                const bucket = wordBuckets.get(token);
                if (bucket) {
                    for (let k = 0; k < bucket.length; k++) {
                        potentialMatches.add(bucket[k]);
                    }
                }
            }
        }
        
        const potentialMatchesArray = [...potentialMatches];
        const MATCH_BATCH_SIZE = 2500;
        
        for (let m = 0; m < potentialMatchesArray.length; m++) {
            if (m > 0 && m % MATCH_BATCH_SIZE === 0) {
                await fastYield();
            }
            
            const existingUniqueTrack = potentialMatchesArray[m];
            const existingHasValidPlayCount = existingUniqueTrack.playCount !== "N/A" &&
                                              existingUniqueTrack.playCount !== 0 &&
                                              existingUniqueTrack.playCount !== null &&
                                              existingUniqueTrack.playCount !== undefined;

            const existData = trackCleanData.get(existingUniqueTrack);
            const existingDuration = existData.duration; 
            const existingArtist = existData.artist;
            const existingArtistSet = existData.artistSet;
            
            let areDuplicatesByNewRules = false;
            
            let artistsOverlap = false;
            if (candidateArtist && existingArtist) {
                for (const artist of candidateArtistSet) {
                    if (existingArtistSet.has(artist)) {
                        artistsOverlap = true;
                        break;
                    }
                }
            }

            if (candidateHasValidPlayCount && existingHasValidPlayCount) {
                if (Number(candidateTrack.playCount) === Number(existingUniqueTrack.playCount)) {
                    
                    if (!areDuplicatesByNewRules && 
                        candData.rawTitleLower === existData.rawTitleLower &&
                        artistsOverlap) {
                        areDuplicatesByNewRules = true;
                    }

                    if (!areDuplicatesByNewRules && artistsOverlap) {
                        const hasVersionKeyword = candData.hasVersionKeyword || existData.hasVersionKeyword;
                        if (hasVersionKeyword) {
                            const cleanExistingTitle = existData.cleanTitle;
                            if (candidateCleanTitle === cleanExistingTitle) {
                                areDuplicatesByNewRules = true;
                            }
                        }
                    }

                    if (!areDuplicatesByNewRules && artistsOverlap) {
                        const durationDiff = Math.abs(candidateDuration - existingDuration);
                        if (durationDiff <= DURATION_THRESHOLD) {
                            areDuplicatesByNewRules = true;
                        }
                    }
                }
            } else {
                const normalizedCandidateTitle = candData.normalizedTitle;
                const normalizedExistingTitle = existData.normalizedTitle;

                if (normalizedCandidateTitle === normalizedExistingTitle && artistsOverlap) {
                    if (candidateDuration === existingDuration) {
                        areDuplicatesByNewRules = true;
                    }
                }
            }

            if (areDuplicatesByNewRules) {
                isConsideredDuplicateOfAnExistingUnique = true;
                break;
            }
        }

        if (!isConsideredDuplicateOfAnExistingUnique) {
            const titleMatches = cleanTitleBuckets.get(candidateCleanTitle);
            
            if (titleMatches && titleMatches.length > 0) {
                const titleMatch = titleMatches[0];
                const cId = candidateTrack.uri.split(':')[2];
                const eId = titleMatch.uri.split(':')[2];
                if (cId && eId) {
                    const [cIsrc, eIsrc] = await Promise.all([fetchIsrc(cId), fetchIsrc(eId)]);
                    if (cIsrc && eIsrc && cIsrc === eIsrc) {
                        isConsideredDuplicateOfAnExistingUnique = true;
                    }
                }
            }
        }

        if (!isConsideredDuplicateOfAnExistingUnique && candidateHasValidPlayCount) {
            const pc = Number(candidateTrack.playCount);
            const matches = playCountBuckets.get(pc);
            if (matches && matches.length > 0) {
                for (const existingMatch of matches) {
                    const existDataForPC = trackCleanData.get(existingMatch);
                    let artistsOverlapPC = false;
                    if (candData.artist && existDataForPC.artist) {
                        for (const artist of candData.artistSet) {
                            if (existDataForPC.artistSet.has(artist)) {
                                artistsOverlapPC = true;
                                break;
                            }
                        }
                    }

                    if (artistsOverlapPC) {
                        const cId = candidateTrack.uri.split(':')[2];
                        const eId = existingMatch.uri.split(':')[2];
                        if (cId && eId) {
                            const [cIsrc, eIsrc] = await Promise.all([fetchIsrc(cId), fetchIsrc(eId)]);
                            if (cIsrc && eIsrc && cIsrc === eIsrc) {
                                isConsideredDuplicateOfAnExistingUnique = true;
                                break;
                            }
                        }
                    }
                }
            }
        }

        if (isConsideredDuplicateOfAnExistingUnique) {
            finalRemovedTracks.push(candidateTrack);
        } else {
            finalUniqueTracks.push(candidateTrack);

            if (!cleanTitleBuckets.has(candidateCleanTitle)) {
                cleanTitleBuckets.set(candidateCleanTitle, []);
            }
            cleanTitleBuckets.get(candidateCleanTitle).push(candidateTrack);
            
            if (candidateHasValidPlayCount) {
                const pc = Number(candidateTrack.playCount);
                if (!playCountBuckets.has(pc)) {
                    playCountBuckets.set(pc, []);
                }
                playCountBuckets.get(pc).push(candidateTrack);
            }
            
            if (candTokens.length === 0) {
                fallbackBucket.push(candidateTrack);
            } else {
                for (let t = 0; t < candTokens.length; t++) {
                    const token = candTokens[t];
                    if (!wordBuckets.has(token)) {
                        wordBuckets.set(token, []);
                    }
                    wordBuckets.get(token).push(candidateTrack);
                }
            }
        }
    }

    return { unique: finalUniqueTracks, removed: finalRemovedTracks };
  }

  async function handleScrobblesSorting(tracks, sortType, updateProgress) {
    if (sortType !== 'scrobbles' && sortType !== 'personalScrobbles') {
      throw new Error('Invalid sort type for scrobbles sorting');
    }
    const isPersonal = sortType === 'personalScrobbles';
    if (isPersonal) {
      const lastFmUsername = loadLastFmUsername();
      if (!lastFmUsername) throw new Error('Last.fm username required for personal scrobbles sorting');
    }

    const tracksWithIds = tracks.map(track => ({
      ...track,
      id: track.uri.split(":")[2]
    }));
    const allIds = tracksWithIds.map(t => t.id);

    const storeName = isPersonal ? 'personalScrobbles' : 'scrobbles';
    const expiryTime = isPersonal ? CACHE_EXPIRE_PERSONAL_SCROBBLES : CACHE_EXPIRE_GLOBAL_SCROBBLES;
    
    const cachedMap = await idb.getMany(storeName, allIds, expiryTime);

    const results = [];
    const missingTracks = [];

    tracksWithIds.forEach(track => {
        const cached = cachedMap.get(track.id);
        
        let hasValidCache = false;
        let val = null;

        if (isPersonal) {
            if (cached && !cached.pendingUpdate) {
                val = cached.count;
                hasValidCache = true;
            }
        } else {
            if (cached !== undefined && cached !== null) {
                val = cached;
                hasValidCache = true;
            }
        }

        if (hasValidCache) {
            results.push({ ...track, [sortType]: val });
        } else {
            missingTracks.push({
                ...track,
                name: track.songTitle || track.name,
                artistName: track.artistName || (track.artists && track.artists[0]?.name),
                artists: track.artists || [{ name: track.artistName }]
            });
        }
    });

    if (missingTracks.length > 0) {
        const fetchFunction = isPersonal ? getTrackDetailsWithPersonalScrobbles : getTrackDetailsWithScrobbles;
        
        const safeConcurrencyPerKey = 5;
        const validKeys = L_F_M_Key_Pool.length - revokedLfmKeys.size;
        const totalConcurrency = Math.min(50, Math.max(5, validKeys * safeConcurrencyPerKey));

        const queue = [...missingTracks];
        let processedCount = 0;
        const totalMissing = missingTracks.length;

        const worker = async () => {
            while (queue.length > 0) {
                const track = queue.shift();
                if (!track) continue;

                try {
                    const result = await fetchFunction(track);
                    if (result) {
                        if (isPersonal) {
                            const val = (result.error && result.personalScrobbles !== -1) ? null : result.personalScrobbles;
                            if (val !== null && val !== undefined) setCachedPersonalScrobbles(track.id, val, false);
                        } else {
                            const val = (result.error && result.scrobbles !== -1) ? null : result.scrobbles;
                            if (val !== null && val !== undefined) setCachedScrobbles(track.id, val);
                        }
                        results.push(result);
                    }
                } catch (error) {
                    console.error(`Error fetching scrobbles for track ${track.name}:`, error);
                } finally {
                    processedCount++;
                    const totalProgress = Math.round(((results.length) / tracks.length) * 100);
                    updateProgress(totalProgress);
                }
            }
        };

        const workers = Array(totalConcurrency).fill(null).map(() => worker());
        await Promise.all(workers);
    } else {
        updateProgress(100);
    }

    if (results.length === 0) {
      throw new Error(`No tracks found with ${isPersonal ? 'personal ' : ''}Last.fm data to sort.`);
    }

    return results;
  }

  async function handleLastScrobbledSorting(tracks, updateProgress) {
    const lastFmUsername = loadLastFmUsername();
    if (!lastFmUsername) {
      throw new Error('Last.fm username required for this sorting type');
    }

    const includeZeroScrobbles = localStorage.getItem("sort-play-include-no-scrobbles") !== "false";

    updateProgress(0);
    const scrobblesMap = await fetchRecentScrobblesMap((progress) => {
        updateProgress(Math.floor(progress * 0.90));
    });

    if (scrobblesMap.size === 0 && !includeZeroScrobbles) {
        throw new Error("Could not fetch any recent scrobbles from Last.fm.");
    }

    updateProgress(95);
    const tracksWithTimestamp = tracks.map(track => {
        const artist = (track.artistName || (track.artists && track.artists[0]?.name) || "").toLowerCase();
        const name = (track.songTitle || track.name || "").toLowerCase();
        const key = `${artist}|-|${name}`;
        return {
            ...track,
            lastScrobbledTimestamp: scrobblesMap.get(key) || 0,
        };
    });

    const uniqueTracksMap = new Map();
    const removedTracks = [];
    tracksWithTimestamp.forEach(track => {
        const key = `${(track.songTitle || track.name).toLowerCase()}|-|${(track.artistName || track.artists[0].name).toLowerCase()}`;
        const existing = uniqueTracksMap.get(key);

        if (!existing || track.lastScrobbledTimestamp > existing.lastScrobbledTimestamp) {
            if (existing) {
                removedTracks.push(existing);
            }
            uniqueTracksMap.set(key, track);
        } else {
            removedTracks.push(track);
        }
    });
    
    const uniqueTracks = Array.from(uniqueTracksMap.values());

    const scrobbledTracks = uniqueTracks.filter(track => track.lastScrobbledTimestamp > 0);
    const unscrobbledTracks = uniqueTracks.filter(track => track.lastScrobbledTimestamp === 0);

    const sortedScrobbledTracks = scrobbledTracks.sort((a, b) => {
        if (sortOrderState.lastScrobbled) {
            return a.lastScrobbledTimestamp - b.lastScrobbledTimestamp;
        }
        return b.lastScrobbledTimestamp - a.lastScrobbledTimestamp;
    });

    let sortedTracks;
    if (includeZeroScrobbles) {
        sortedTracks = [...sortedScrobbledTracks, ...unscrobbledTracks];
    } else {
        sortedTracks = sortedScrobbledTracks;
    }

    if (sortedTracks.length === 0) {
        if (includeZeroScrobbles) {
            throw new Error("No tracks found in this playlist.");
        } else {
            throw new Error("None of the tracks in this playlist appear in your recent Last.fm history.");
        }
    }
    
    updateProgress(100);
    return { sortedTracks, removedTracks };
  }

  async function fetchRecentScrobblesMap(updateProgress) {
    const username = loadLastFmUsername();
    if (!username) {
      throw new Error('Last.fm username is not set.');
    }

    const scrobblesMap = new Map();
    const limit = 200;
    const maxPages = 25;
    let currentPage = 1;

    updateProgress(0);

    while (currentPage <= maxPages) {
      const params = new URLSearchParams({
        method: 'user.getrecenttracks',
        user: username,
        limit: limit.toString(),
        page: currentPage.toString(),
        format: 'json'
      });
      
      try {
        const response = await fetchLfmWithGateway(params);
        if (!response.ok) {
            console.warn(`Last.fm API request for recent tracks failed on page ${currentPage}`);
            break; 
        }

        const data = await response.json();
        const tracks = data.recenttracks?.track;

        if (!tracks || tracks.length === 0) {
          break;
        }
        
        const processableTracks = tracks.filter(t => t.date && t.date.uts);

        for (const track of processableTracks) {
          const artist = track.artist['#text'].toLowerCase();
          const name = track.name.toLowerCase();
          const key = `${artist}|-|${name}`;
          
          if (!scrobblesMap.has(key)) {
            scrobblesMap.set(key, parseInt(track.date.uts, 10) * 1000);
          }
        }

        updateProgress(Math.floor((currentPage / maxPages) * 100));

        if (currentPage >= data.recenttracks['@attr'].totalPages) {
            break;
        }

        currentPage++;
      } catch (error) {
        console.error(`Error fetching page ${currentPage} of recent scrobbles:`, error);
        break; 
      }
    }
    
    updateProgress(100);
    return scrobblesMap;
  }

  menuButtons.forEach((element) => {
    if (element.tagName.toLowerCase() === "div") {
        return;
    }
    const buttonText = element.querySelector("span")?.innerText;
    const buttonStyle = buttonStyles.menuItems.find(
        (item) => item.text === buttonText
    );

    if (!buttonStyle) {
        return;
    }
    
    if (buttonStyle.hasInnerPlayButton) {
        const innerPlayButton = createInnerPlayButton(element);
        element.appendChild(innerPlayButton);
    }
    
    if (buttonStyle.isSetting) {
        element.addEventListener("click", (event) => {
            event.stopPropagation();
            showSettingsModal();
        });
    } else if (buttonStyle.type === "parent" || buttonStyle.type === "divider") {
        return;
    } else if (buttonStyle.sortType === "customFilter") {
        element.addEventListener("click", (event) => {
            event.stopPropagation();
            handleCustomFilter();
        });
    } else if (buttonStyle.sortType === "convertToSpotify") {
        element.addEventListener("click", (event) => {
            event.stopPropagation();
            convertLocalPlaylistToSpotify();
        });
    } else {
        const sortType = buttonStyle.sortType;
        element.addEventListener("click", async (event) => {
            event.stopPropagation();
            if (buttonStyle.onClick) {
                await buttonStyle.onClick(event);
            } else if (sortType === "genreFilter") {
                setButtonProcessing(true);
                mainButton.style.backgroundColor = buttonStyles.main.disabledBackgroundColor;
                mainButton.style.color = buttonStyles.main.disabledColor;
                mainButton.style.cursor = "default";
                svgElement.style.fill = buttonStyles.main.disabledColor;
                toggleMenu();
                closeAllMenus();
                menuButtons.forEach((button) => {
                    button.disabled = true;
                    if (button.tagName.toLowerCase() === 'button') {
                        button.style.backgroundColor = "transparent";
                    }
                });

                try {
                    const currentUri = getCurrentUri();
                    if (!currentUri) {
                        resetButtons();
                        showNotification("Please select a playlist first");
                        return;
                    }

                    let tracks;
                    let isArtistPage = false;

                    if (URI.isPlaylistV1OrV2(currentUri)) {
                        const playlistId = currentUri.split(":")[2];
                        tracks = await getPlaylistTracks(playlistId);
                    } else if (URI.isArtist(currentUri)) {
                        tracks = await getArtistTracks(currentUri);
                        isArtistPage = true;
                    } else if (isLikedSongsPage(currentUri)) {
                        tracks = await getLikedSongs();
                    } else if (URI.isAlbum(currentUri)) {
                        const albumId = currentUri.split(":")[2];
                        tracks = await getAlbumTracks(albumId);
                    } else {
                        throw new Error("Invalid URI type");
                    }

                    if (!tracks || tracks.length === 0) {
                        throw new Error("No tracks found");
                    }

                    if (isArtistPage) {
                        tracks = await processArtistPageTracks(tracks);
                    }

                    const { convertedTracks, unconvertedCount } = await convertLocalTracksToSpotify(
                        tracks, 
                        (progress) => { mainButton.innerText = progress; }
                    );
        
                    if (unconvertedCount > 0) {
                        const plural = unconvertedCount === 1 ? "track" : "tracks";
                        showNotification(`${unconvertedCount} local ${plural} not found on Spotify and were skipped.`, 'warning');
                    }
        
                    if (!convertedTracks || convertedTracks.length === 0) {
                        throw new Error("No tracks found");
                    }
                    tracks = convertedTracks;
        
                    const openModal = async () => {
                        const { trackGenreMap, rawTrackGenres } = await fetchAllTrackGenres(
                            tracks
                        );
                        const modalPromise = showGenreFilterModal(tracks, trackGenreMap, rawTrackGenres, currentUri);
                        setTimeout(() => resetButtons(), 100);
                        await modalPromise;
                    };
        
                    await openModal();
                } catch (error) {
                    console.error("Error during genre filtering:", error);
                    showNotification(
                        "An error occurred during the genre filtering process."
                    );
                    resetButtons();
                } finally {
                }
            } else {
                menuButtons.forEach((btn) => {
                    if (btn.tagName.toLowerCase() === "button" && !btn.disabled) {
                        btn.style.backgroundColor = "transparent";
                    }
                });
                await handleSortAndCreatePlaylist(sortType);
            }
        });
    }
  });

  
  function resetButtons() {
    setButtonProcessing(false);
    mainButton.innerText = "Sort Play"; 
    mainButton.appendChild(svgElement); 
    mainButton.style.backgroundColor = buttonStyles.main.backgroundColor;
    mainButton.style.cursor = "pointer";
    applyCurrentThemeColors(); 
    mainButton.style.filter = "brightness(1)";
    isButtonClicked = false;
    menuButtons.forEach((button) => {
      button.disabled = false;
    });
  }

  async function getBatchTrackStats(trackIds, updateProgress = () => {}) {
    if (trackIds.length === 0) return {};

    const cacheKeys = trackIds.map(id => getCacheKey(id, true, false, "stats-column"));
    const cachedDataMap = await idb.getMany('aiData', cacheKeys);

    const results = {};
    const missingIds = [];

    trackIds.forEach((id, index) => {
        const key = cacheKeys[index];
        const cached = cachedDataMap.get(key);
        if (cached && cached.stats) {
            results[id] = cached.stats;
        } else {
            missingIds.push(id);
        }
    });

    if (missingIds.length === 0) return results;

    if (isFallbackActive()) {
        return results;
    }

    const BATCH_SIZE = 100;
    const MAX_RETRIES = 3;
    const INITIAL_DELAY = 1000;
    const CONCURRENCY_LIMIT = 10;

    const batches = [];
    for (let i = 0; i < missingIds.length; i += BATCH_SIZE) {
        batches.push(missingIds.slice(i, i + BATCH_SIZE));
    }

    let tracksProcessed = 0;

    const processBatch = async (batchIds) => {
        let success = false;
        let retries = 0;
        let delay = INITIAL_DELAY;

        while (!success && retries < MAX_RETRIES) {
            try {
                const [audioFeaturesResponse, trackDetailsResponse] = await Promise.all([
                    Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/audio-features?ids=${batchIds.join(',')}`),
                    Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${batchIds.join(',')}`)
                ]);

                if (!audioFeaturesResponse?.audio_features || !trackDetailsResponse?.tracks) {
                    throw new Error('Incomplete data received from Spotify API for a batch.');
                }

                const pitchClasses = ["C", "Câ™¯/Dâ™­", "D", "Dâ™¯/Eâ™­", "E", "F", "Fâ™¯/Gâ™­", "G", "Gâ™¯/Aâ™­", "A", "Aâ™¯/Bâ™­", "B"];
                
                for (let i = 0; i < audioFeaturesResponse.audio_features.length; i++) {
                    const features = audioFeaturesResponse.audio_features[i];
                    const trackDetails = trackDetailsResponse.tracks[i];
                    
                    if (features && trackDetails) {
                        const stats = {
                            danceability: features.danceability ? Math.round(100 * features.danceability) : null,
                            energy: features.energy ? Math.round(100 * features.energy) : null,
                            key_raw: features.key,
                            mode: features.mode,
                            key: features.key === -1 ? "Undefined" : pitchClasses[features.key],
                            loudness: features.loudness ?? null,
                            speechiness: features.speechiness ? Math.round(100 * features.speechiness) : null,
                            acousticness: features.acousticness ? Math.round(100 * features.acousticness) : null,
                            instrumentalness: features.instrumentalness ? Math.round(100 * features.instrumentalness) : null,
                            liveness: features.liveness ? Math.round(100 * features.liveness) : null,
                            valence: features.valence ? Math.round(100 * features.valence) : null,
                            tempo: features.tempo ? Math.round(features.tempo) : null,
                            popularity: trackDetails.popularity ?? null,
                            releaseDate: trackDetails.album?.release_date ?? null
                        };
                        
                        results[features.id] = stats;
                        
                        await setTrackCache(features.id, stats, true, false, "stats-column");
                    }
                }
                success = true;
            } catch (error) {
                retries++;
                if (retries < MAX_RETRIES) await new Promise(resolve => setTimeout(resolve, delay *= 2));
                else console.error(`[Sort-Play] Failed to fetch batch stats.`);
            }
        }
        tracksProcessed += batchIds.length;
        if (updateProgress) updateProgress(Math.min(100, Math.floor((tracksProcessed / missingIds.length) * 100)));
    };

    const workers = [];
    for (let i = 0; i < batches.length; i += CONCURRENCY_LIMIT) {
        const concurrentBatch = batches.slice(i, i + CONCURRENCY_LIMIT);
        await Promise.all(concurrentBatch.map(batch => processBatch(batch)));
    }

    return results;
  }

  function getTracklistTrackUri(tracklistElement) {
    let values = Object.values(tracklistElement);
    if (!values || !values[0]?.pendingProps) {
        return null;
    }
    return (
        values[0]?.pendingProps?.children?.props?.value?.spec?._path?.[0]?.uri ||
        values[0]?.pendingProps?.children[0]?.props?.children?.props?.uri ||
        values[0]?.pendingProps?.children[0]?.props?.children?.props?.children?.props?.uri ||
        values[0]?.pendingProps?.children[0]?.props?.children?.props?.children?.props?.children?.props
            ?.uri ||
        values[0]?.pendingProps?.children[0]?.props?.children[0]?.props?.uri
    );
}

  const waitForElement = (selector) => {
    return new Promise((resolve) => {
      if (document.querySelector(selector)) {
        return resolve(document.querySelector(selector));
      }
      const observer = new MutationObserver(() => {
        if (document.querySelector(selector)) {
          observer.disconnect();
          resolve(document.querySelector(selector));
        }
      });
      observer.observe(document.body, {
        childList: true,
        subtree: true,
      });
    });
  };

  async function setCachedScrobbles(trackId, scrobbleCount) {
    await idb.set('scrobbles', trackId, scrobbleCount);
  }
  
  async function getCachedPersonalScrobbles(trackId) {
    return await idb.get('personalScrobbles', trackId, CACHE_EXPIRE_PERSONAL_SCROBBLES);
  }
  async function setCachedPersonalScrobbles(trackId, scrobbleCount, isPending) {
    await idb.set('personalScrobbles', trackId, { count: scrobbleCount, pendingUpdate: isPending });
  }

  async function flagCachedPersonalScrobbleForUpdate(trackId) {
    try {
      const cached = await idb.get('personalScrobbles', trackId);
      
      if (cached) {
        cached.pendingUpdate = true;
        await idb.set('personalScrobbles', trackId, cached);
      }
    } catch (error) {
      console.error('Error flagging personal scrobble cache:', error);
    }
  }
  
  let previousTrackUriForScrobbleCache = null;

  function initializeSongChangeWatcher() {
    if (!Spicetify || !Spicetify.Player) {
        setTimeout(initializeSongChangeWatcher, 100);
        return;
    }

    const handleSongChange = (uri) => {
        if (!uri) return;

        if (!localStorage.getItem("sort-play-lastfm-username")) return;
        
        if (previousTrackUriForScrobbleCache && previousTrackUriForScrobbleCache !== uri) {
            const prevId = previousTrackUriForScrobbleCache.split(":")[2];
            if (prevId) flagCachedPersonalScrobbleForUpdate(prevId);
        }

        currentTrackUriForScrobbleCache = uri;
        previousTrackUriForScrobbleCache = uri; 
        
        const trackId = uri.split(":")[2];
        idb.del('personalScrobbles', trackId);
    };

    const currentTrack = Spicetify.Player.data?.item;
    if (currentTrack) {
        handleSongChange(currentTrack.uri);
    }

    Spicetify.Player.addEventListener("songchange", (event) => {
        const newTrack = event?.data?.item;
        if (newTrack) {
            handleSongChange(newTrack.uri);
        }
    });
  }

  async function setCachedReleaseDate(trackId, rawReleaseDate) { 
    await idb.set('releaseDates', trackId, rawReleaseDate);
  }
  
  function formatReleaseDate(rawDate, format = 'YYYY-MM-DD') {
    if (!rawDate || rawDate === "_" || rawDate === "â€•") {
        return "â€•";
    }

    let dateObj;
    let yearOnly = false;
    let monthYearOnly = false;

    if (typeof rawDate === 'number') { 
        dateObj = new Date(rawDate);
    } else if (typeof rawDate === 'string') {
        let dateStrToParse = rawDate;
        if (rawDate.length === 4) { 
             yearOnly = true;
             dateStrToParse = `${rawDate}-01-01`;
        } else if (rawDate.length === 7) {
             monthYearOnly = true;
             dateStrToParse = `${rawDate}-01`; 
        }
        dateObj = new Date(dateStrToParse);
    } else {
        return "â€•";
    }

    if (isNaN(dateObj.getTime())) {
        return "â€•";
    }

    const year = dateObj.getFullYear();
    const monthNumeric = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const dayNumeric = dateObj.getDate().toString().padStart(2, '0');
    const monthShort = dateObj.toLocaleString('default', { month: 'short' });

    if (yearOnly) {
        switch (format) {
            case 'YYYY': return year.toString();
            case 'MM-YYYY': return `??-${year}`;
            case 'YYYY-MM': return `${year}-??`;
            case 'MMM D, YYYY': return `???, ${year}`; 
            case 'D MMM, YYYY': return `???, ${year}`; 
            case 'YYYY, MMM D': return `${year}, ???`;
            default: return year.toString();
        }
    }

    if (monthYearOnly) {
        switch (format) {
            case 'YYYY': return year.toString();
            case 'MM-YYYY': return `${monthNumeric}-${year}`;
            case 'YYYY-MM': return `${year}-${monthNumeric}`;
            case 'MMM D, YYYY': return `${monthShort}, ${year}`; 
            case 'D MMM, YYYY': return `${monthShort}, ${year}`; 
            case 'YYYY, MMM D': return `${year}, ${monthShort}`;
            default: return `${year}-${monthNumeric}`;
        }
    }

    switch (format) {
        case 'YYYY-MM-DD':
            return `${year}-${monthNumeric}-${dayNumeric}`;
        case 'DD-MM-YYYY':
            return `${dayNumeric}-${monthNumeric}-${year}`;
        case 'MM-DD-YYYY':
            return `${monthNumeric}-${dayNumeric}-${year}`;
        case 'YYYY':
            return year.toString();
        case 'YYYY-MM':
            return `${year}-${monthNumeric}`;
        case 'MM-YYYY':
            return `${monthNumeric}-${year}`;
        case 'MMM D, YYYY':
            return `${monthShort} ${dateObj.getDate()}, ${year}`;
        case 'D MMM, YYYY':
            return `${dateObj.getDate()} ${monthShort}, ${year}`;
        case 'YYYY, MMM D':
            return `${year}, ${monthShort} ${dateObj.getDate()}`;
        default:
            return `${year}-${monthNumeric}-${dayNumeric}`;
    }
  }

  function cleanupLegacyGenreCache() {
    if (localStorage.getItem('sort-play-idb-migration-cleanup-done') === 'true') {
        return;
    }

    const keysToRemove = [
        'spotify-play-count-cache2', 
        'spotify-play-count-cache-timestamp2',
        'spotify-release-date-cache2', 
        'spotify-release-date-cache-timestamp2',
        'spotify-scrobbles-cache3', 
        'spotify-scrobbles-cache-timestamp3',
        'sort-play-personal-scrobbles-cache', 
        'sort-play-personal-scrobbles-cache-timestamp',
        'spotify-palette-analysis-cache',
        'spotify-palette-analysis-cache-timestamp'
    ];

    let removedCount = 0;

    keysToRemove.forEach(key => {
        if (localStorage.getItem(key)) {
            localStorage.removeItem(key);
            removedCount++;
        }
    });

    const prefixes = [
        'sort-play-playlist-cache-v1-',
        'sort-play-genre-cache-v2-'
    ];

    Object.keys(localStorage).forEach(key => {
        if (prefixes.some(prefix => key.startsWith(prefix))) {
            localStorage.removeItem(key);
            removedCount++;
        }
    });
    
    if (removedCount > 0) {
        console.log(`[Sort-Play] Migrated to IndexedDB: Cleaned up ${removedCount} legacy localStorage items.`);
    }

    localStorage.setItem('sort-play-idb-migration-cleanup-done', 'true');
  }

  async function setCachedPlayCount(trackId, playCount) {
    await idb.set('playCounts', trackId, playCount);
  }

  function getTrackDataObject(trackElement) {
    const reactPropsKey = Object.keys(trackElement).find(key => key.startsWith("__reactProps$"));
    if (!reactPropsKey) return null;

    const props = trackElement[reactPropsKey];
    if (!props) return null;

    const potentialPaths = [
        () => props.children?.props?.item,
        () => props.children?.[0]?.props?.item,
        () => props.children?.props?.value?.item,
        () => props.children?.[0]?.props?.children?.props?.item,
        () => props.children?.[0]?.props?.children?.[0]?.props?.item,
    ];

    for (const getPath of potentialPaths) {
        const trackData = getPath();
        if (trackData && trackData.uri && trackData.name && trackData.artists) {
            return trackData;
        }
    }
    
    return null;
  }

  function showColumnSelector(event, contextType) {
    event.stopPropagation();
    const existing = document.getElementById('sort-play-column-selector');
    if (existing) existing.remove();

    const options = [
        { value: 'playCount', label: 'Play Count' },
        { value: 'popularity', label: 'Popularity' },
        { value: 'releaseDate', label: 'Release Date' },
        { value: 'scrobbles', label: 'Scrobbles' },
        { value: 'personalScrobbles', label: 'My Scrobbles' },
        { value: 'djInfo', label: 'DJ Info' },
        { value: 'key', label: 'Key' },
        { value: 'tempo', label: 'Tempo (BPM)' },
        { value: 'energy', label: 'Energy' },
        { value: 'danceability', label: 'Danceability' },
        { value: 'valence', label: 'Valence' }
    ];

    let currentOptions = options;
    if (contextType === 'album') {
        currentOptions = options.filter(o => o.value !== 'playCount');
    }

    const menu = document.createElement('div');
    menu.id = 'sort-play-column-selector';
    menu.className = 'main-contextMenu-menu sort-play-font-scope';
    menu.style.cssText = `
        position: fixed; z-index: 9999; background-color: #282828; border-radius: 4px; padding: 4px;
        box-shadow: 0 16px 24px rgba(0,0,0,.3), 0 6px 8px rgba(0,0,0,.2); max-height: 400px; overflow-y: auto;
        min-width: 140px; display: flex; flex-direction: column;
    `;

    currentOptions.forEach(opt => {
        const item = document.createElement('button');
        item.className = 'main-contextMenu-menuItemButton';
        item.style.cssText = 'color: #b3b3b3; padding: 4px 8px; width: 100%; text-align: left; background: transparent; border: none; cursor: pointer; display: flex; align-items: center; font-size: 13px; border-radius: 2px; height: 28px;';
        item.innerText = opt.label;
        
        let isSelected = false;
        if (contextType === 'playlist1' && selectedColumnType === opt.value) isSelected = true;
        if (contextType === 'playlist2' && selectedSecondColumnType === opt.value) isSelected = true;
        if (contextType === 'album' && selectedAlbumColumnType === opt.value) isSelected = true;
        if (contextType === 'artist' && selectedArtistColumnType === opt.value) isSelected = true;

        if (isSelected) {
            item.style.color = '#fff';
            item.style.fontWeight = 'bold';
            item.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
        }

        item.onmouseenter = () => {
            if (!isSelected) item.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
            item.style.color = '#fff';
        };
        item.onmouseleave = () => {
            if (!isSelected) {
                item.style.backgroundColor = 'transparent';
                item.style.color = '#b3b3b3';
            } else {
                item.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                item.style.color = '#fff';
            }
        };

        item.onclick = () => {
            if (contextType === 'playlist1') {
                selectedColumnType = opt.value;
                localStorage.setItem("sort-play-selected-column-type", selectedColumnType);
                updateTracklist();
            } else if (contextType === 'playlist2') {
                selectedSecondColumnType = opt.value;
                localStorage.setItem("sort-play-selected-second-column-type", selectedSecondColumnType);
                updateTracklist();
            } else if (contextType === 'album') {
                selectedAlbumColumnType = opt.value;
                localStorage.setItem("sort-play-selected-album-column-type", selectedAlbumColumnType);
                updateAlbumTracklist();
            } else if (contextType === 'artist') {
                selectedArtistColumnType = opt.value;
                localStorage.setItem("sort-play-selected-artist-column-type", selectedArtistColumnType);
                updateArtistTracklist();
            }
            menu.remove();
            document.removeEventListener('click', closeMenu);
        };
        menu.appendChild(item);
    });

    document.body.appendChild(menu);
    const rect = event.currentTarget.getBoundingClientRect();
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    let top = rect.bottom + 7;
    let left = rect.left + (rect.width / 2) - (menuWidth / 2);

    if (left + menuWidth > viewportWidth) {
        left = viewportWidth - menuWidth - 10;
    }
    if (left < 10) left = 10;

    if (top + menuHeight > viewportHeight) {
        top = rect.top - menuHeight - 5;
    }

    menu.style.top = `${top}px`;
    menu.style.left = `${left}px`;

    const closeMenu = (e) => {
        if (!menu.contains(e.target) && e.target !== event.currentTarget) {
            menu.remove();
            document.removeEventListener('click', closeMenu);
        }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 0);
  }
  
  async function loadAdditionalColumnData(tracklist_) {
    const currentUri = getCurrentUri();
    let columnConfigs = [];
    const audioFeatureTypes = ['key', 'tempo', 'energy', 'danceability', 'valence', 'djInfo'];

    if (URI.isPlaylistV1OrV2(currentUri) || isLikedSongsPage(currentUri) || isLocalFilesPage(currentUri)) {
        if (showSecondAdditionalColumn) columnConfigs.push({ type: selectedSecondColumnType, dataSelector: ".sort-play-second-data" });
        if (showAdditionalColumn) columnConfigs.push({ type: selectedColumnType, dataSelector: ".sort-play-data" });
    } else if (URI.isAlbum(currentUri)) {
        if (showAlbumColumn) columnConfigs.push({ type: selectedAlbumColumnType, dataSelector: ".sort-play-data" });
    } else if (URI.isArtist(currentUri)) {
        if (showArtistColumn) columnConfigs.push({ type: selectedArtistColumnType, dataSelector: ".sort-play-data" });
    }

    if (columnConfigs.length === 0) return;

    const allTrackRows = Array.from(tracklist_.getElementsByClassName("main-trackList-trackListRow"));
    const spotifyTracksToProcess = [];

    for (const trackElement of allTrackRows) {
        if (trackElement.classList.contains('sort-play-processing') || trackElement.hasAttribute('data-sp-fetch-failed')) continue;
        const trackUri = getTracklistTrackUri(trackElement);
        if (!trackUri) continue;

        if (Spicetify.URI.isLocal(trackUri)) {
            trackElement.classList.add('sort-play-processing');
            const trackData = getTrackDataObject(trackElement);

            if (trackData) {
                const rawArtistName = trackData.artists[0]?.name || "";
                const cleanedArtistName = rawArtistName.includes(';') ? rawArtistName.split(';')[0].trim() : rawArtistName;
                const localTrackInfo = { name: trackData.name, artistName: cleanedArtistName, artists: [{ name: cleanedArtistName }], uri: trackData.uri };

                const localPromises = columnConfigs.map(async (config) => {
                    const dataElement = trackElement.querySelector(config.dataSelector);
                    if (!dataElement || dataElement.dataset.spProcessed) return;

                    try {
                        if (config.type === 'scrobbles') {
                            const result = await getTrackDetailsWithScrobbles(localTrackInfo, true);
                            if (result.scrobbles === -1 || result.error) {
                                updateDisplay(dataElement, { error: result.error || "Track not found on Last.fm", errorLabel: result.errorLabel || "N/A" }, config.type);
                            } else {
                                updateDisplay(dataElement, result.scrobbles, config.type);
                            }
                        } else if (config.type === 'personalScrobbles') {
                            if (!loadLastFmUsername()) {
                                updateDisplay(dataElement, { error: "Set Last.fm username in setting", errorLabel: "No User" }, config.type);
                            } else {
                                const result = await getTrackDetailsWithPersonalScrobbles(localTrackInfo, true);
                                if (result.personalScrobbles === -1 || result.error) {
                                    updateDisplay(dataElement, { error: result.error || "Track not found on Last.fm", errorLabel: result.errorLabel || "N/A" }, config.type);
                                } else {
                                    updateDisplay(dataElement, result.personalScrobbles, config.type);
                                }
                            }
                        } else {
                            updateDisplay(dataElement, "â€•", config.type);
                        }
                    } catch (e) {
                        updateDisplay(dataElement, { error: "Local Load Failed", errorLabel: "Err" }, config.type);
                        trackElement.setAttribute('data-sp-fetch-failed', 'true');
                    }
                });
                
                Promise.all(localPromises).finally(() => {
                    trackElement.classList.remove('sort-play-processing');
                });
            } else {
                trackElement.classList.remove('sort-play-processing');
            }
        } else if (trackUri.includes("track")) {
            const needsProcessing = columnConfigs.some(config => {
                const dataElement = trackElement.querySelector(config.dataSelector);
                return dataElement && !dataElement.dataset.spProcessed;
            });
            if (needsProcessing) {
                const props = getTrackDataObject(trackElement);
                spotifyTracksToProcess.push({ element: trackElement, id: trackUri.split(":")[2], props });
            }
        }
    }

    if (spotifyTracksToProcess.length === 0) return;

    const BATCH_SIZE = 50; 
    
    for (let i = 0; i < spotifyTracksToProcess.length; i += BATCH_SIZE) {
        const batch = spotifyTracksToProcess.slice(i, i + BATCH_SIZE);
        const batchIds = batch.map(item => item.id);
        
        const dataMap = { playCounts: null, releaseDates: null, scrobbles: null, personal: null, ai: null };
        const fetchPromises = [];

        if (columnConfigs.some(c => c.type === 'playCount')) {
            fetchPromises.push(idb.getMany('playCounts', batchIds, CACHE_EXPIRE_PLAYCOUNTS).then(res => dataMap.playCounts = res));
        }
        if (columnConfigs.some(c => c.type === 'releaseDate')) {
            fetchPromises.push(idb.getMany('releaseDates', batchIds, CACHE_EXPIRE_RELEASE_DATE).then(res => dataMap.releaseDates = res));
        }
        if (columnConfigs.some(c => c.type === 'scrobbles')) {
            fetchPromises.push(idb.getMany('scrobbles', batchIds, CACHE_EXPIRE_GLOBAL_SCROBBLES).then(res => dataMap.scrobbles = res));
        }
        if (columnConfigs.some(c => c.type === 'personalScrobbles')) {
            fetchPromises.push(idb.getMany('personalScrobbles', batchIds, CACHE_EXPIRE_PERSONAL_SCROBBLES).then(res => dataMap.personal = res));
        }
        
        const audioFeatureConfig = columnConfigs.find(c => audioFeatureTypes.includes(c.type));
        if (audioFeatureConfig) {
            const aiKeys = batchIds.map(id => getCacheKey(id, true, false, "stats-column"));
            fetchPromises.push(idb.getMany('aiData', aiKeys, CACHE_EXPIRE_AI_DATA).then(res => dataMap.ai = res));
        }

        await Promise.all(fetchPromises);

        const idsToFetchFromApi = [];
        const elementsToFetchFromApi = new Map();
        const propsMap = new Map();

        for (const { element, id, props } of batch) {
            let isFullyCached = true;

            for (const config of columnConfigs) {
                const dataElement = element.querySelector(config.dataSelector);
                if (!dataElement || (dataElement.textContent !== "" && dataElement.textContent !== "_" && dataElement.textContent !== "â€•")) continue;

                let val = undefined;
                if (config.type === 'playCount' && dataMap.playCounts) val = dataMap.playCounts.get(id);
                else if (config.type === 'releaseDate' && dataMap.releaseDates) val = dataMap.releaseDates.get(id);
                else if (config.type === 'scrobbles' && dataMap.scrobbles) val = dataMap.scrobbles.get(id);
                else if (config.type === 'personalScrobbles' && dataMap.personal) {
                    const d = dataMap.personal.get(id);
                    if (d && !d.pendingUpdate) val = d.count;
                } else if (audioFeatureTypes.includes(config.type) && dataMap.ai) {
                    const aiKey = getCacheKey(id, true, false, "stats-column");
                    const stats = dataMap.ai.get(aiKey);
                    if (stats) val = config.type === 'djInfo' ? stats : stats[config.type];
                }

                if (val !== undefined && val !== null) {
                    if ((config.type === 'scrobbles' || config.type === 'personalScrobbles') && val === -1) {
                         updateDisplay(dataElement, { error: "Track not found on Last.fm", errorLabel: "N/A" }, config.type);
                    } else {
                         updateDisplay(dataElement, val, config.type);
                    }
                } else {
                    element.classList.add('sort-play-processing');
                    isFullyCached = false;
                }
            }

            if (!isFullyCached) {
                idsToFetchFromApi.push(id);
                elementsToFetchFromApi.set(id, element);
                if (props) propsMap.set(id, props);
            }
        }

        if (idsToFetchFromApi.length > 0) {
            if (audioFeatureConfig) {
                try {
                    const stats = await getBatchTrackStats(idsToFetchFromApi);
                    for (const id of idsToFetchFromApi) {
                        const el = elementsToFetchFromApi.get(id);
                        const stat = stats[id];
                        if (stat && el) {
                            await setTrackCache(id, stat, true, false, "stats-column");
                            columnConfigs.forEach(c => {
                                if (audioFeatureTypes.includes(c.type)) {
                                    updateDisplay(el.querySelector(c.dataSelector), c.type === 'djInfo' ? stat : stat[c.type], c.type);
                                }
                            });
                        }
                    }
                } catch(e) {}
            }

            const nonAudioConfigs = columnConfigs.filter(c => !audioFeatureTypes.includes(c.type));
            if (nonAudioConfigs.length > 0) {
                const processTrackData = async (t) => {
                    if (!t) return;
                    const el = elementsToFetchFromApi.get(t.id);
                    if (!el) return;
                    
                    for (const c of nonAudioConfigs) {
                        const dEl = el.querySelector(c.dataSelector);
                        if (!dEl || dEl.dataset.spProcessed) continue;

                        if (c.type === 'playCount') {
                            const r = await getTrackDetailsWithPlayCount({ track: { album: { id: t.album.id }, id: t.id } });
                            updateDisplay(dEl, r?.playCount, c.type);
                            if (r?.playCount !== "N/A") await setCachedPlayCount(t.id, r.playCount);
                        } else if (c.type === 'releaseDate') {
                            updateDisplay(dEl, t.album.release_date, c.type);
                            if (t.album.release_date) await setCachedReleaseDate(t.id, t.album.release_date);
                        } else if (c.type === 'popularity') {
                            updateDisplay(dEl, t.popularity, c.type);
                        } else if (c.type === 'scrobbles' || c.type === 'personalScrobbles') {
                            const info = { name: t.name, artists: t.artists, uri: t.uri };
                            if (c.type === 'scrobbles') {
                                const r = await getTrackDetailsWithScrobbles(info, true);
                                if (r.scrobbles === -1 || r.error) {
                                    updateDisplay(dEl, { error: r.error || "Not found", errorLabel: "N/A" }, c.type);
                                } else {
                                    updateDisplay(dEl, r.scrobbles, c.type);
                                    if (r.scrobbles !== null) await setCachedScrobbles(t.id, r.scrobbles);
                                }
                            } else {
                                if (loadLastFmUsername()) {
                                    const r = await getTrackDetailsWithPersonalScrobbles(info, true);
                                    updateDisplay(dEl, (r.personalScrobbles === -1 || r.error) ? { error: r.error || "Not found", errorLabel: "N/A" } : r.personalScrobbles, c.type);
                                } else {
                                    updateDisplay(dEl, { error: "Set username", errorLabel: "No User" }, c.type);
                                }
                            }
                        }
                    }
                    el.classList.remove('sort-play-processing');
                };

                const fetchAndProcessInternal = async () => {
                    const currentUri = getCurrentUri();
                    const isAlbum = Spicetify.URI.isAlbum(currentUri);
                    const albumIdFromUrl = isAlbum ? currentUri.split(':')[2] : null;

                    await Promise.all(idsToFetchFromApi.map(async (id) => {
                        let t = null;
                        const props = propsMap.get(id);
                        
                        const needsPopularity = nonAudioConfigs.some(c => c.type === 'popularity');
                        const needsReleaseDate = nonAudioConfigs.some(c => c.type === 'releaseDate');

                        if (props) {
                            const albId = props.album?.uri ? props.album.uri.split(':')[2] : albumIdFromUrl;
                            const hasReleaseDate = props.album?.release_date;
                            
                            if (albId && (!needsPopularity) && (!needsReleaseDate || hasReleaseDate)) {
                                t = {
                                    id: id,
                                    name: props.name,
                                    album: { id: albId, release_date: props.album?.release_date },
                                    artists: props.artists || [],
                                    uri: `spotify:track:${id}`
                                };
                            }
                        }
                        
                        if (!t) t = await fetchInternalTrackMetadata(id);
                        await processTrackData(t);
                    }));
                };

                if (isFallbackActive()) {
                    await fetchAndProcessInternal();
                } else {
                    try {
                        const resp = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${idsToFetchFromApi.join(',')}`);
                        if (resp?.tracks) {
                            await Promise.all(resp.tracks.map(processTrackData));
                        }
                    } catch(e) {
                        if (registerWebApiFailure()) await fetchAndProcessInternal();
                    }
                }
            }
            
            idsToFetchFromApi.forEach(id => {
                const el = elementsToFetchFromApi.get(id);
                if (el) {
                    el.classList.remove('sort-play-processing');
                }
            });
        }
    }
  }

  function updateDisplay(element, value, type) {
    if (!element) return;
    element.dataset.spProcessed = "true";

    if (value && typeof value === 'object' && value.error) {
        const label = value.errorLabel || "Error";
        element.innerHTML = `
            <span class="sort-play-failed-cell">
                ${label}
                <span class="sort-play-tooltip">${value.error}</span>
            </span>
        `;
        element.style.fontSize = "14px";
        element.style.fontWeight = "400";
        element.style.color = "var(--spice-subtext)";
        return; 
    }

    let displayValue = "";

    if (type === 'playCount') {
        if (value > 0 && !isNaN(value)) {
            displayValue = new Intl.NumberFormat('en-US').format(value);
        } else {
            displayValue = "â€•";
        }
    } else if (type === 'personalScrobbles') {
        if (value === 0) {
            displayValue = "â€•";
        } else if (value > 0 && !isNaN(value)) {
            if (myScrobblesDisplayMode === 'sign') {
                displayValue = '\u2705';
            } else { 
                displayValue = new Intl.NumberFormat('en-US').format(value);
            }
        } else {
            displayValue = "Err"; 
        }
    } else if (type === 'scrobbles') {
        if (value !== null && value !== undefined && !isNaN(value) && value !== -1) {
            if (value > 0) {
                displayValue = new Intl.NumberFormat('en-US').format(value);
            } else {
                displayValue = "â€•";
            }
        } else {
             displayValue = "Err";
        }
    } else if (type === 'releaseDate') {
        displayValue = formatReleaseDate(value, releaseDateFormat);
    } else if (type === 'djInfo') {
        if (value && typeof value === 'object') {
            const parts = [];
            if (value.key && value.key !== 'Undefined') parts.push(value.key);
            if (value.tempo) parts.push(`${value.tempo}â™«`);
            if (value.energy) parts.push(`E${value.energy}`);
            if (parts.length > 0) {
                displayValue = parts.join(' | ');
            } else {
                displayValue = "â€•";
            }
        } else {
            displayValue = "â€•";
        }
    } else if (['key', 'tempo', 'energy', 'danceability', 'valence', 'popularity'].includes(type)) {
        if (value !== null && value !== undefined) {
            displayValue = String(value);
        } else {
            displayValue = "â€•";
        }
    }

    element.textContent = displayValue;
    element.style.fontSize = "14px";
    element.style.fontWeight = "400";
    element.style.color = "var(--spice-subtext)";
  }
  
  async function updateTracklist() {
    const currentUri = getCurrentUri();
    if (!showAdditionalColumn || !currentUri || !(URI.isPlaylistV1OrV2(currentUri) || isLikedSongsPage(currentUri))) {
      return;
    }
  
    if (isUpdatingTracklist) return;
  
    try {
      isUpdatingTracklist = true;
  
      const tracklists = document.getElementsByClassName("main-trackList-indexable");
      if (!tracklists.length) return;
  
      for (const tracklist_ of tracklists) {
        if (!tracklist_) continue;
  
        await updateTracklistStructure(tracklist_);

        requestAnimationFrame(() => {
          loadAdditionalColumnData(tracklist_);
        });
      }
    } finally {
      isUpdatingTracklist = false;
    }
  }
  
  async function updateTracklistStructure(tracklist_) {
    const currentUri = getCurrentUri();
    if (!currentUri || !(URI.isPlaylistV1OrV2(currentUri) || isLikedSongsPage(currentUri))) return;

    await new Promise(resolve => requestAnimationFrame(resolve));

    const tracklistHeader = tracklist_.querySelector(".main-trackList-trackListHeaderRow");
    if (!tracklistHeader) {
      return;
    }

    const currentPlaylistName = getCurrentPlaylistName();
    const isExcludedPlaylist = excludedPlaylistNames.includes(currentPlaylistName);
    const shouldRemoveDateAdded = removeDateAdded && !isExcludedPlaylist;
    const gridCss = getGridCss(shouldRemoveDateAdded);

    const existingHeaderColumn = tracklistHeader.querySelector(".sort-play-column");
    const headerTextSpan = existingHeaderColumn?.querySelector("span");
    const existingSecondHeaderColumn = tracklistHeader.querySelector(".sort-play-second-column");
    const secondHeaderTextSpan = existingSecondHeaderColumn?.querySelector("span");

    let expectedHeaderText;
    switch (selectedColumnType) {
        case 'playCount': expectedHeaderText = "Plays"; break;
        case 'popularity': expectedHeaderText = "Popularity"; break;
        case 'releaseDate': expectedHeaderText = "Rel. Date"; break;
        case 'scrobbles': expectedHeaderText = "Scrobbles"; break;
        case 'personalScrobbles': expectedHeaderText = myScrobblesDisplayMode === 'sign' ? "Listened" : "My Scrobbles"; break;
        case 'djInfo': expectedHeaderText = "DJ Info"; break;
        case 'key': expectedHeaderText = "Key"; break;
        case 'tempo': expectedHeaderText = "BPM"; break;
        case 'energy': expectedHeaderText = "Energy"; break;
        case 'danceability': expectedHeaderText = "Dance"; break;
        case 'valence': expectedHeaderText = "Valence"; break;
        default: expectedHeaderText = "Plays";
    }
    const columnTypeChanged = existingHeaderColumn && headerTextSpan?.innerText !== expectedHeaderText;

    let expectedSecondHeaderText;
    switch (selectedSecondColumnType) {
        case 'playCount': expectedSecondHeaderText = "Plays"; break;
        case 'popularity': expectedSecondHeaderText = "Popularity"; break;
        case 'releaseDate': expectedSecondHeaderText = "Rel. Date"; break;
        case 'scrobbles': expectedSecondHeaderText = "Scrobbles"; break;
        case 'personalScrobbles': expectedSecondHeaderText = myScrobblesDisplayMode === 'sign' ? "Listened" : "My Scrobbles"; break;
        case 'djInfo': expectedSecondHeaderText = "DJ Info"; break;
        case 'key': expectedSecondHeaderText = "Key"; break;
        case 'tempo': expectedSecondHeaderText = "BPM"; break;
        case 'energy': expectedSecondHeaderText = "Energy"; break;
        case 'danceability': expectedSecondHeaderText = "Dance"; break;
        case 'valence': expectedSecondHeaderText = "Valence"; break;
        default: expectedSecondHeaderText = "Popularity";
    }
    const secondColumnTypeChanged = existingSecondHeaderColumn && secondHeaderTextSpan?.innerText !== expectedSecondHeaderText;

    if (showAdditionalColumn) {
        if (!existingHeaderColumn) {
            const lastColumn = tracklistHeader.querySelector(".main-trackList-rowSectionEnd");
            if (lastColumn) {
                const colIndexInt = parseInt(lastColumn.getAttribute("aria-colindex"));
                const newGridTemplate = colIndexInt === 4 ? gridCss.fiveColumnGridCss : colIndexInt === 5 ? gridCss.sixColumnGridCss : gridCss.sevenColumnGridCss;
                tracklistHeader.style.cssText = newGridTemplate;

                const insertionPoint = shouldRemoveDateAdded ? tracklistHeader.querySelector('[aria-colindex="4"]') : lastColumn;
                let headerColumn = document.createElement("div");
                headerColumn.className = "main-trackList-rowSectionVariable sort-play-column";
                headerColumn.setAttribute("role", "columnheader");
                headerColumn.style.cssText = "display: flex; justify-content: center;";
                headerColumn.setAttribute("aria-colindex", colIndexInt.toString());
                
                const btn = document.createElement("button");
                btn.className = "main-trackList-column main-trackList-sortable sort-play-column-header";
                btn.onclick = (e) => showColumnSelector(e, 'playlist1');
                const title = document.createElement("span");
                title.className = "TypeElement-mesto-type standalone-ellipsis-one-line";
                title.innerText = expectedHeaderText;
                btn.appendChild(title);
                headerColumn.appendChild(btn);

                if (insertionPoint) {
                    tracklistHeader.insertBefore(headerColumn, insertionPoint);
                    lastColumn.setAttribute("aria-colindex", (colIndexInt + 1).toString());
                }
            }
        } else if (columnTypeChanged) {
            if (headerTextSpan) headerTextSpan.innerText = expectedHeaderText;
            const allCells = tracklist_.querySelectorAll('.sort-play-data');
            allCells.forEach(cell => {
                cell.textContent = "";
                delete cell.dataset.spProcessed;
            });
        }
    } else { 
        if (existingHeaderColumn) {
            existingHeaderColumn.remove();
            const lastColumn = tracklistHeader.querySelector(".main-trackList-rowSectionEnd");
            if (lastColumn) {
                const colIndexInt = parseInt(lastColumn.getAttribute("aria-colindex"));
                lastColumn.setAttribute("aria-colindex", (colIndexInt - 1).toString());
                switch (colIndexInt - 1) {
                    case 4: tracklistHeader.style.cssText = "grid-template-columns: [index] 16px [first] 4fr [var1] 2fr [var2] minmax(120px,1fr) [last] minmax(120px,1fr)"; break;
                    case 5: tracklistHeader.style.cssText = "grid-template-columns: [index] 16px [first] 6fr [var1] 4fr [var2] 3fr [var3] minmax(120px,1fr) [last] minmax(120px,1fr)"; break;
                    case 6: tracklistHeader.style.cssText = "grid-template-columns: [index] 16px [first] 6fr [var1] 4fr [var2] 3fr [var3] minmax(120px,2fr) [var4] minmax(120px,1fr) [last] minmax(120px,1fr)"; break;
                }
            }
        }
    }

    if (showSecondAdditionalColumn) {
        if (!existingSecondHeaderColumn) {
            const lastColumn = tracklistHeader.querySelector(".main-trackList-rowSectionEnd");
            if (lastColumn) {
                const colIndexInt = parseInt(lastColumn.getAttribute("aria-colindex"));
                const newGridTemplate = colIndexInt === 5 ? gridCss.sixColumnGridCss_twoExtra : colIndexInt === 6 ? gridCss.sevenColumnGridCss_twoExtra : gridCss.sevenColumnGridCss_twoExtra;
                tracklistHeader.style.cssText = newGridTemplate;

                const firstColumnHeader = tracklistHeader.querySelector(".sort-play-column");
                const insertionPoint = firstColumnHeader || (shouldRemoveDateAdded ? tracklistHeader.querySelector('[aria-colindex="4"]') : lastColumn);
                
                let headerColumn = document.createElement("div");
                headerColumn.className = "main-trackList-rowSectionVariable sort-play-second-column";
                headerColumn.setAttribute("role", "columnheader");
                headerColumn.style.cssText = "display: flex; justify-content: center;";
                headerColumn.setAttribute("aria-colindex", (colIndexInt - (showAdditionalColumn ? 1 : 0)).toString());
                
                const btn = document.createElement("button");
                btn.className = "main-trackList-column main-trackList-sortable sort-play-column-header";
                btn.onclick = (e) => showColumnSelector(e, 'playlist2');
                const title = document.createElement("span");
                title.className = "TypeElement-mesto-type standalone-ellipsis-one-line";
                title.innerText = expectedSecondHeaderText;
                btn.appendChild(title);
                headerColumn.appendChild(btn);

                if (insertionPoint) {
                    tracklistHeader.insertBefore(headerColumn, insertionPoint);
                    if (firstColumnHeader) firstColumnHeader.setAttribute("aria-colindex", colIndexInt.toString());
                    lastColumn.setAttribute("aria-colindex", (colIndexInt + 1).toString());
                }
            }
        } else if (secondColumnTypeChanged) {
            if (secondHeaderTextSpan) secondHeaderTextSpan.innerText = expectedSecondHeaderText;
            const allCells = tracklist_.querySelectorAll('.sort-play-second-data');
            allCells.forEach(cell => {
                cell.textContent = "";
                delete cell.dataset.spProcessed;
            });
        }
    } else {
        if (existingSecondHeaderColumn) {
            existingSecondHeaderColumn.remove();
            const lastColumn = tracklistHeader.querySelector(".main-trackList-rowSectionEnd");
            if (lastColumn) {
                const colIndexInt = parseInt(lastColumn.getAttribute("aria-colindex"));
                lastColumn.setAttribute("aria-colindex", (colIndexInt - 1).toString());
                const newGridTemplate = colIndexInt - 1 === 4 ? gridCss.fiveColumnGridCss : colIndexInt - 1 === 5 ? gridCss.sixColumnGridCss : gridCss.sevenColumnGridCss;
                tracklistHeader.style.cssText = newGridTemplate;
            }
        }
    }

    const dateAddedHeader = tracklistHeader.querySelector('[aria-colindex="4"]');
    if (dateAddedHeader) {
        dateAddedHeader.style.display = shouldRemoveDateAdded ? 'none' : '';
    }

    const allRows = tracklist_.getElementsByClassName("main-trackList-trackListRow");
    for (const track of allRows) {
        const existingDataColumn = track.querySelector(".sort-play-data-column");
        const existingSecondDataColumn = track.querySelector(".sort-play-second-data-column");

        if (showAdditionalColumn) {
            if (!existingDataColumn) {
                const lastColumn = track.querySelector(".main-trackList-rowSectionEnd");
                if (lastColumn) {
                    const colIndexInt = parseInt(lastColumn.getAttribute("aria-colindex"));
                    const newGridTemplate = colIndexInt === 4 ? gridCss.fiveColumnGridCss : colIndexInt === 5 ? gridCss.sixColumnGridCss : gridCss.sevenColumnGridCss;
                    track.style.cssText = newGridTemplate;

                    let dataColumn = document.createElement("div");
                    dataColumn.className = "main-trackList-rowSectionVariable sort-play-data-column sort-play-column";
                    dataColumn.setAttribute("aria-colindex", colIndexInt.toString());
                    dataColumn.style.cssText = "display: flex; justify-content: center; align-items: center;";
                    dataColumn.innerHTML = `<span class="sort-play-data" style="font-size: 14px; font-weight: 400; color: var(--spice-subtext);"></span>`;

                    const insertionPoint = shouldRemoveDateAdded ? track.querySelector('[aria-colindex="4"]') : lastColumn;
                    if (insertionPoint) {
                        track.insertBefore(dataColumn, insertionPoint);
                        lastColumn.setAttribute("aria-colindex", (colIndexInt + 1).toString());
                    }
                }
            } else if (columnTypeChanged) {
                const dataSpan = existingDataColumn.querySelector('.sort-play-data');
                if (dataSpan) dataSpan.textContent = "";
            }
        } else { 
            if (existingDataColumn) {
                existingDataColumn.remove();
                const lastColumn = track.querySelector(".main-trackList-rowSectionEnd");
                if(lastColumn) {
                    const colIndexInt = parseInt(lastColumn.getAttribute("aria-colindex"));
                    lastColumn.setAttribute("aria-colindex", (colIndexInt - 1).toString());
                    switch (colIndexInt - 1) {
                         case 4: track.style.cssText = "grid-template-columns: [index] 16px [first] 4fr [var1] 2fr [var2] minmax(120px,1fr) [last] minmax(120px,1fr)"; break;
                         case 5: track.style.cssText = "grid-template-columns: [index] 16px [first] 6fr [var1] 4fr [var2] 3fr [var3] minmax(120px,1fr) [last] minmax(120px,1fr)"; break;
                         case 6: track.style.cssText = "grid-template-columns: [index] 16px [first] 6fr [var1] 4fr [var2] 3fr [var3] minmax(120px,2fr) [var4] minmax(120px,1fr) [last] minmax(120px,1fr)"; break;
                    }
                }
            }
        }

        if (showSecondAdditionalColumn) {
            if (!existingSecondDataColumn) {
                const lastColumn = track.querySelector(".main-trackList-rowSectionEnd");
                if (lastColumn) {
                    const colIndexInt = parseInt(lastColumn.getAttribute("aria-colindex"));
                    const newGridTemplate = colIndexInt === 5 ? gridCss.sixColumnGridCss_twoExtra : colIndexInt === 6 ? gridCss.sevenColumnGridCss_twoExtra : gridCss.sevenColumnGridCss_twoExtra;
                    track.style.cssText = newGridTemplate;

                    let dataColumn = document.createElement("div");
                    dataColumn.className = "main-trackList-rowSectionVariable sort-play-second-data-column sort-play-second-column";
                    dataColumn.setAttribute("aria-colindex", (colIndexInt - (showAdditionalColumn ? 1 : 0)).toString());
                    dataColumn.style.cssText = "display: flex; justify-content: center; align-items: center;";
                    dataColumn.innerHTML = `<span class="sort-play-second-data" style="font-size: 14px; font-weight: 400; color: var(--spice-subtext);"></span>`;

                    const firstColumnCell = track.querySelector(".sort-play-data-column");
                    const insertionPoint = firstColumnCell || (shouldRemoveDateAdded ? track.querySelector('[aria-colindex="4"]') : lastColumn);
                    if (insertionPoint) {
                        track.insertBefore(dataColumn, insertionPoint);
                        if (firstColumnCell) firstColumnCell.setAttribute("aria-colindex", colIndexInt.toString());
                        lastColumn.setAttribute("aria-colindex", (colIndexInt + 1).toString());
                    }
                }
            } else if (secondColumnTypeChanged) {
                const dataSpan = existingSecondDataColumn.querySelector('.sort-play-second-data');
                if (dataSpan) dataSpan.textContent = "";
            }
        } else {
            if (existingSecondDataColumn) {
                existingSecondDataColumn.remove();
                const lastColumn = track.querySelector(".main-trackList-rowSectionEnd");
                if(lastColumn) {
                    const colIndexInt = parseInt(lastColumn.getAttribute("aria-colindex"));
                    lastColumn.setAttribute("aria-colindex", (colIndexInt - 1).toString());
                    const newGridTemplate = colIndexInt - 1 === 4 ? gridCss.fiveColumnGridCss : colIndexInt - 1 === 5 ? gridCss.sixColumnGridCss : gridCss.sevenColumnGridCss;
                    track.style.cssText = newGridTemplate;
                }
            }
        }

        const dateAddedCell = track.querySelector('[aria-colindex="4"]');
        if (dateAddedCell) {
            dateAddedCell.style.display = shouldRemoveDateAdded ? 'none' : '';
        }
    }
  }

  
  const getGridCss = (removeDateAdded) => {
    if (removeDateAdded) {
      return {
        fiveColumnGridCss: "grid-template-columns: [index] 16px [first] 4fr [var1] 2fr [var2] 2fr [last] minmax(120px,1fr) !important",
        sixColumnGridCss: "grid-template-columns: [index] 16px [first] 5fr [var1] 3fr [var2] 2fr [var3] 2fr [last] minmax(120px,1fr) !important",
        sevenColumnGridCss: "grid-template-columns: [index] 16px [first] 5fr [var1] 3fr [var2] 2fr [var3] 2fr [var4] 2fr [last] minmax(120px,1fr) !important",
        sixColumnGridCss_twoExtra: "grid-template-columns: [index] 16px [first] 4fr [var1] 2fr [var2] 2fr [var3] 2fr [last] minmax(120px,1fr) !important",
        sevenColumnGridCss_twoExtra: "grid-template-columns: [index] 16px [first] 5fr [var1] 3fr [var2] 2fr [var3] 2fr [var4] 2fr [last] minmax(120px,1fr) !important",
      };
    }
    return {
      fiveColumnGridCss: "grid-template-columns: [index] 16px [first] 4fr [var1] 2fr [var2] 2fr [last] minmax(120px,1fr) !important",
      sixColumnGridCss: "grid-template-columns: [index] 16px [first] 5fr [var1] 3fr [var2] 2fr [var3] 2fr [last] minmax(120px,1fr) !important",
      sevenColumnGridCss: "grid-template-columns: [index] 16px [first] 5fr [var1] 3fr [var2] 2fr [var3] minmax(120px,1fr) [var4] 2fr [last] minmax(120px,1fr) !important",
      sixColumnGridCss_twoExtra: "grid-template-columns: [index] 16px [first] 4fr [var1] 2fr [var2] 2fr [var3] 2fr [last] minmax(120px,1fr) !important",
      sevenColumnGridCss_twoExtra: "grid-template-columns: [index] 16px [first] 5fr [var1] 3fr [var2] 2fr [var3] 2fr [var4] 2fr [last] minmax(120px,1fr) !important",
    };
  };

  function updateAlbumTracklist() {
    const tracklistContainer = document.querySelector(".main-trackList-trackList.main-trackList-indexable");
    if (!tracklistContainer) return;

    const currentUri = getCurrentUri();

    if (!showAlbumColumn || !currentUri || !URI.isAlbum(currentUri)) {
        const existingHeader = tracklistContainer.querySelector('.sort-play-album-col-header');
        if (existingHeader) {
            const headerRow = existingHeader.parentElement;
            const originalGridTemplate = "[index] 16px [first] 4fr [var1] 2fr [last] minmax(120px,1fr)";
            existingHeader.remove();
            if(headerRow) headerRow.style.gridTemplateColumns = originalGridTemplate;
            tracklistContainer.setAttribute('aria-colcount', '4');
            const allRows = tracklistContainer.querySelectorAll('.main-trackList-trackList .main-trackList-trackListRow');
            allRows.forEach(row => {
                const cell = row.querySelector('.sort-play-album-col');
                if (cell) cell.remove();
                row.style.gridTemplateColumns = originalGridTemplate;
            });
        }
        return;
    }

    const headerRow = tracklistContainer.querySelector('.main-trackList-trackListHeaderRow');
    if (!headerRow) return;

    let expectedHeaderText;
    switch (selectedAlbumColumnType) {
        case 'playCount': expectedHeaderText = "Plays"; break;
        case 'popularity': expectedHeaderText = "Popularity"; break;
        case 'releaseDate': expectedHeaderText = "Rel. Date"; break;
        case 'scrobbles': expectedHeaderText = "Scrobbles"; break;
        case 'personalScrobbles': expectedHeaderText = myScrobblesDisplayMode === 'sign' ? "Listened" : "My Scrobbles"; break;
        case 'djInfo': expectedHeaderText = "DJ Info"; break;
        case 'key': expectedHeaderText = "Key"; break;
        case 'tempo': expectedHeaderText = "BPM"; break;
        case 'energy': expectedHeaderText = "Energy"; break;
        case 'danceability': expectedHeaderText = "Dance"; break;
        case 'valence': expectedHeaderText = "Valence"; break;
        default: expectedHeaderText = "Plays";
    }

    const newGridTemplate = "[index] 16px [first] 6fr [var1] 3fr [var2] 3fr [last] minmax(120px,1fr)";
    const existingHeader = headerRow.querySelector('.sort-play-album-col-header');

    if (!existingHeader) {
        headerRow.style.gridTemplateColumns = newGridTemplate;
        tracklistContainer.setAttribute('aria-colcount', '5');
        const newHeaderCell = document.createElement('div');
        newHeaderCell.className = 'main-trackList-rowSectionVariable sort-play-album-col-header';
        newHeaderCell.innerHTML = `<button class="main-trackList-column sort-play-column-header"><span class="encore-text-body-small">${expectedHeaderText}</span></button>`;
        newHeaderCell.setAttribute('role', 'columnheader');
        newHeaderCell.firstChild.onclick = (e) => showColumnSelector(e, 'album');
        newHeaderCell.setAttribute('aria-colindex', '4');
        newHeaderCell.style.justifyContent = 'center';

        const playsHeaderCell = headerRow.querySelector('[role="columnheader"][aria-colindex="3"]');
        if (playsHeaderCell) {
            playsHeaderCell.after(newHeaderCell);
            const lastHeaderCell = headerRow.querySelector('.main-trackList-rowSectionEnd');
            if (lastHeaderCell) lastHeaderCell.setAttribute('aria-colindex', '5');
        }
    } else {
        const headerTextSpan = existingHeader.querySelector('span');
        if (headerTextSpan && headerTextSpan.innerText !== expectedHeaderText) {
            headerTextSpan.innerText = expectedHeaderText;
            const allCells = tracklistContainer.querySelectorAll('.sort-play-album-col .sort-play-data');
            allCells.forEach(cell => {
                cell.textContent = "";
                delete cell.dataset.spProcessed;
            });
        }
    }
    
    const trackRows = tracklistContainer.querySelectorAll('.main-trackList-trackListRow');
    trackRows.forEach(row => {
        if (row.querySelector('.sort-play-album-col')) return;
        row.style.gridTemplateColumns = newGridTemplate;
        const newCell = document.createElement('div');
        newCell.className = 'main-trackList-rowSectionVariable sort-play-album-col';
        newCell.innerHTML = `<span class="sort-play-data encore-text-body-small encore-internal-color-text-subdued" data-encore-id="text"></span>`;
        newCell.setAttribute('role', 'gridcell');
        newCell.setAttribute('aria-colindex', '4');
        newCell.style.display = 'flex';
        newCell.style.alignItems = 'center';
        newCell.style.justifyContent = 'center';

        const playsCell = row.querySelector('[role="gridcell"][aria-colindex="3"]');
        if (playsCell) {
            playsCell.after(newCell);
            const lastCell = row.querySelector('.main-trackList-rowSectionEnd');
            if (lastCell) lastCell.setAttribute('aria-colindex', '5');
        }
    });

    loadAdditionalColumnData(tracklistContainer);
  }

  function updateArtistTracklist() {
    const tracklistContainer = document.querySelector('div.main-trackList-trackList[aria-label="popular tracks"]');
    if (!tracklistContainer) return;

    const currentUri = getCurrentUri();

    if (!showArtistColumn || !currentUri || !URI.isArtist(currentUri)) {
        const existingHeaderWrapper = tracklistContainer.querySelector('.sort-play-artist-header-wrapper');
        if (existingHeaderWrapper) {
            const trackRows = tracklistContainer.querySelectorAll('.main-trackList-trackListRow.main-trackList-trackListRowGrid');
            const originalGridTemplate = "[index] 16px [first] 4fr [var1] 2fr [last] minmax(120px,1fr)";
            existingHeaderWrapper.remove();
            tracklistContainer.setAttribute('aria-colcount', '4');
            trackRows.forEach(row => {
                const cell = row.querySelector('.sort-play-artist-col');
                if (cell) cell.remove();
                row.style.gridTemplateColumns = originalGridTemplate;
            });
        }
        return;
    }

    let expectedHeaderText;
    switch (selectedArtistColumnType) {
        case 'playCount': expectedHeaderText = "Plays"; break;
        case 'popularity': expectedHeaderText = "Popularity"; break;
        case 'releaseDate': expectedHeaderText = "Rel. Date"; break;
        case 'scrobbles': expectedHeaderText = "Scrobbles"; break;
        case 'personalScrobbles': expectedHeaderText = myScrobblesDisplayMode === 'sign' ? "Listened" : "My Scrobbles"; break;
        case 'djInfo': expectedHeaderText = "DJ Info"; break;
        case 'key': expectedHeaderText = "Key"; break;
        case 'tempo': expectedHeaderText = "BPM"; break;
        case 'energy': expectedHeaderText = "Energy"; break;
        case 'danceability': expectedHeaderText = "Dance"; break;
        case 'valence': expectedHeaderText = "Valence"; break;
        default: expectedHeaderText = "Plays";
    }
    
    const newGridTemplate = "[index] 16px [first] 6fr [var1] 3fr [var2] 3fr [last] minmax(120px,1fr)";
    const existingHeaderWrapper = tracklistContainer.querySelector('.sort-play-artist-header-wrapper');

    if (!existingHeaderWrapper) {
        tracklistContainer.setAttribute('aria-colcount', '5');
        const headerWrapper = document.createElement('div');
        headerWrapper.className = 'main-trackList-trackListHeader sort-play-artist-header-wrapper';
        headerWrapper.innerHTML = `<div class="main-trackList-trackListHeaderRow main-trackList-trackListRowGrid" role="row" style="grid-template-columns: ${newGridTemplate};">
            <div class="main-trackList-rowSectionIndex" role="columnheader" aria-colindex="1"><div>#</div></div>
            <div class="main-trackList-rowSectionStart" role="columnheader" aria-colindex="2"><div class="main-trackList-column"><span class="encore-text-body-small">Title</span></div></div>
            <div class="main-trackList-rowSectionVariable" role="columnheader" aria-colindex="3"><div><span class="encore-text-body-small">Plays</span></div></div>
            <div class="main-trackList-rowSectionVariable sort-play-artist-col-header" role="columnheader" aria-colindex="4" style="justify-content: center;"><button class="main-trackList-column sort-play-column-header"><span class="encore-text-body-small">${expectedHeaderText}</span></button></div>
            <div class="main-trackList-rowSectionEnd" role="columnheader" aria-colindex="5"><div aria-label="Duration" class="main-trackList-column main-trackList-durationHeader"><svg data-encore-id="icon" role="img" aria-hidden="true" viewBox="0 0 16 16" class="Svg-sc-ytk21e-0 Svg-img-icon-small"><path d="M8 1.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8z"></path><path d="M8 3.25a.75.75 0 0 1 .75.75v3.25H11a.75.75 0 0 1 0 1.5H7.25V4A.75.75 0 0 1 8 3.25z"></path></svg></div></div>
        </div>`;
        headerWrapper.style.cssText = 'position: sticky; top: 0px; z-index: 2;';
        headerWrapper.querySelector('.sort-play-artist-col-header button').onclick = (e) => showColumnSelector(e, 'artist');
        const rootlistWrapper = tracklistContainer.querySelector('.main-rootlist-wrapper');
        if (rootlistWrapper) {
            tracklistContainer.insertBefore(headerWrapper, rootlistWrapper);
        } else {
            tracklistContainer.prepend(headerWrapper);
        }
    } else {
        const headerTextSpan = existingHeaderWrapper.querySelector('.sort-play-artist-col-header span');
        if (headerTextSpan && headerTextSpan.innerText !== expectedHeaderText) {
            headerTextSpan.innerText = expectedHeaderText;
            const allCells = tracklistContainer.querySelectorAll('.sort-play-artist-col .sort-play-data');
            allCells.forEach(cell => {
                cell.textContent = "";
                delete cell.dataset.spProcessed;
            });
        }
    }

    const trackRows = tracklistContainer.querySelectorAll('.main-trackList-trackListRow.main-trackList-trackListRowGrid');
    trackRows.forEach(row => {
        if (row.querySelector('.sort-play-artist-col')) return;
        row.style.gridTemplateColumns = newGridTemplate;
        const newCell = document.createElement('div');
        newCell.className = 'main-trackList-rowSectionVariable sort-play-artist-col';
        newCell.innerHTML = `<span class="sort-play-data encore-text-body-small encore-internal-color-text-subdued" data-encore-id="text"></span>`;
        newCell.setAttribute('role', 'gridcell');
        newCell.setAttribute('aria-colindex', '4');
        newCell.style.display = 'flex';
        newCell.style.alignItems = 'center';
        newCell.style.justifyContent = 'center';

        const playsCell = row.querySelector('[role="gridcell"][aria-colindex="3"]');
        if (playsCell) {
            playsCell.after(newCell);
            const endSection = row.querySelector('.main-trackList-rowSectionEnd');
            if (endSection) endSection.setAttribute('aria-colindex', '5');
        }
    });

    loadAdditionalColumnData(tracklistContainer);
  }
  
  async function initializeTracklistObserver() {
    const currentUri = getCurrentUri();
    if (!currentUri || !(URI.isPlaylistV1OrV2(currentUri) || isLikedSongsPage(currentUri))) return;

    const tracklist = await waitForElement(".main-trackList-indexable");
    if (!tracklist) return;

    updateTracklist();

    if (tracklistObserver) tracklistObserver.disconnect();

    tracklistObserver = new MutationObserver(() => {
        clearTimeout(updateDebounceTimeout);
        updateDebounceTimeout = setTimeout(updateTracklist, 150);
    });
    
    const rowContainer = tracklist.querySelector(':scope > [role="presentation"]');
    if (rowContainer) {
        tracklistObserver.observe(rowContainer, { childList: true });
    } else {
        tracklistObserver.observe(tracklist, { childList: true, subtree: true });
    }
  }

  async function initializeAlbumTracklistObserver() {
    const currentUri = getCurrentUri();
    if (!currentUri || !URI.isAlbum(currentUri)) return;

    const tracklist = await waitForElement(".main-trackList-trackList.main-trackList-indexable");
    if (!tracklist) return;

    updateAlbumTracklist();

    if (albumTracklistObserver) albumTracklistObserver.disconnect();

    albumTracklistObserver = new MutationObserver(() => {
        clearTimeout(updateDebounceTimeout);
        updateDebounceTimeout = setTimeout(updateAlbumTracklist, 150);
    });
    
    albumTracklistObserver.observe(tracklist, {
      childList: true,
      subtree: true,
    });
  }

  async function initializeArtistTracklistObserver() {
    const currentUri = getCurrentUri();
    if (!currentUri || !URI.isArtist(currentUri)) return;

    const tracklist = await waitForElement('div.main-trackList-trackList[aria-label="popular tracks"]');
    if (!tracklist) return;

    updateArtistTracklist();

    if (artistTracklistObserver) artistTracklistObserver.disconnect();

    artistTracklistObserver = new MutationObserver(() => {
        clearTimeout(updateDebounceTimeout);
        updateDebounceTimeout = setTimeout(updateArtistTracklist, 150);
    });
    
    artistTracklistObserver.observe(tracklist, {
      childList: true,
      subtree: true,
    });
  }
    
  function insertButton() {
    const currentUri = getCurrentUri(); 
    if (!currentUri) return;
  
    if (URI.isPlaylistV1OrV2(currentUri)) {
      const playlistContainer = document.querySelector(".playlist-playlist-searchBoxContainer");
      if (playlistContainer && !playlistContainer.contains(mainButton)) {
        mainButton.style.marginLeft = ""; 
        mainButton.style.marginRight = "";
        if (playlistContainer.firstChild) {
          playlistContainer.insertBefore(mainButton, playlistContainer.firstChild);
        } else {
          playlistContainer.appendChild(mainButton);
        }
      }
    } else if (URI.isArtist(currentUri)) {
      const artistActionBar = document.querySelector(".main-actionBar-ActionBarRow");
      if (artistActionBar && !artistActionBar.contains(mainButton)) {
        mainButton.style.marginLeft = "auto"; 
        mainButton.style.marginRight = "31px"; 
        artistActionBar.appendChild(mainButton);
      }
    } else if (isLikedSongsPage(currentUri)) {
      const likedSongsContainer = document.querySelector(".playlist-playlist-searchBoxContainer");
      if (likedSongsContainer && !likedSongsContainer.contains(mainButton)) {
        mainButton.style.marginLeft = ""; 
        mainButton.style.marginRight = "";
        if (likedSongsContainer.firstChild) {
          likedSongsContainer.insertBefore(mainButton, likedSongsContainer.firstChild);
        } else {
          likedSongsContainer.appendChild(mainButton);
        }
      }
      } else if (isLocalFilesPage(currentUri)) {
        const localFilesActionBar = document.querySelector(".main-actionBar-ActionBarRow");
        if (localFilesActionBar) {
            const controlsContainer = localFilesActionBar.querySelector("div:last-child");
            if (controlsContainer && !controlsContainer.contains(mainButton)) {
                mainButton.style.marginLeft = ""; 
                mainButton.style.marginRight = "8px";
                if (controlsContainer.firstChild) {
                    controlsContainer.insertBefore(mainButton, controlsContainer.firstChild);
                } else {
                    controlsContainer.appendChild(mainButton);
                }
            }
        }
    } 
    else if (URI.isAlbum(currentUri)) {
        const listButton = document.querySelector(".x-sortBox-sortDropdown");

        if (listButton && listButton.parentElement) {
            const container = listButton.parentElement;
            if (!container.contains(mainButton)) {
                mainButton.style.marginLeft = "";
                mainButton.style.marginRight = "1px";
                container.insertBefore(mainButton, listButton);
            }
        } else {
            const albumActionBar = document.querySelector(".main-actionBar-ActionBarRow");
            if (albumActionBar && !albumActionBar.contains(mainButton)) {
                mainButton.style.marginLeft = "auto"; 
                mainButton.style.marginRight = "31px"; 
                albumActionBar.appendChild(mainButton);
            }
        }
    }
  }

  function getNativeMenuBackgroundColor() {
    const primaryClass = 'main-contextMenu-menu';
    const fallbackClass = 'wlb3dYO07PZuYfmNfmkS';
    let tempContainer = null;
    try {
      tempContainer = document.createElement('div');
      tempContainer.className = primaryClass;
      tempContainer.style.cssText = 'position: absolute; top: -9999px; left: -9999px; visibility: hidden;';
      document.body.appendChild(tempContainer);

      let bgColor = window.getComputedStyle(tempContainer).backgroundColor;

      if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
        return bgColor;
      }
      
      tempContainer.className = fallbackClass;
      bgColor = window.getComputedStyle(tempContainer).backgroundColor;

      if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
        return bgColor;
      }

      return '#282828';
    } catch (error) {
      return '#282828';
    } finally {
      if (tempContainer) {
        document.body.removeChild(tempContainer);
      }
    }
  }
  
  function applyCurrentThemeColors(elementToUpdate = null) {
    requestAnimationFrame(() => {
        if (!elementToUpdate) {
            const nativeButtonColor = getNativeTertiaryButtonColor();
            if (mainButton && !isProcessing) { 
                mainButton.style.color = nativeButtonColor;
                if (svgElement) svgElement.style.fill = nativeButtonColor;
            }
        }

        const allMenus = document.querySelectorAll('.main-contextMenu-menu.sort-play-font-scope');

        if (allMenus.length > 0) {
            const nativeMenuColor = getNativeMenuTextColor();

            allMenus.forEach(menu => {
                const childButtons = menu.querySelectorAll('button');
                childButtons.forEach(button => {
                    button.style.color = nativeMenuColor;
                });

                const childIcons = menu.querySelectorAll('svg');
                childIcons.forEach(svg => {
                    if (svg.style.fill !== 'rgb(30, 215, 96)') { 
                        svg.style.fill = nativeMenuColor;
                    }
                });
            });
        }
    });
  }
  const LIKE_BUTTON_ICON_NOT_LIKED = `<path d="M1.69 2A4.582 4.582 0 018 2.023 4.583 4.583 0 0111.88.817h.002a4.618 4.618 0 013.782 3.65v.003a4.543 4.543 0 01-1.011 3.84L9.35 14.629a1.765 1.765 0 01-2.093.464 1.762 1.762 0 01-.605-.463L1.348 8.309A4.582 4.582 0 011.689 2zm3.158.252A3.082 3.082 0 002.49 7.337l.005.005L7.8 13.664a.264.264 0 00.311.069.262.262 0 00.09-.069l5.312-6.33a3.043 3.043 0 00.68-2.573 3.118 3.118 0 00-2.551-2.463 3.079 3.079 0 00-2.612.816l-.007.007a1.501 1.501 0 01-2.045 0l-.009-.008a3.082 3.082 0 00-2.121-.861z"></path>`;
  const LIKE_BUTTON_ICON_LIKED = `<path d="M15.724 4.22A4.313 4.313 0 0012.192.814a4.269 4.269 0 00-3.622 1.13.837.837 0 01-1.14 0 4.272 4.272 0 00-6.21 5.855l5.916 7.05a1.128 1.128 0 001.727 0l5.916-7.05a4.228 4.228 0 00.945-3.577z"></path>`;
  const LIKE_BUTTON_ICON_ISRC_LIKED = `<path d="m15.92,3.56h0c-.36-1.81-1.8-3.2-3.62-3.49-1.35-.22-2.72.21-3.71,1.16-.16.15-.37.23-.58.23s-.42-.08-.58-.23c-.85-.82-1.95-1.23-3.04-1.23S2.09.45,1.23,1.33c-1.57,1.63-1.65,4.18-.17,5.9l6.06,7.22c.23.27.56.41.89.41h0c.26,0,.53-.09.74-.27.05-.04.1-.09.14-.14l6.06-7.22c.87-1.01,1.23-2.36.97-3.66h0Zm-7.91,9.39h0L2.31,6.18h0s0-.01,0-.01c-.45-.52-.68-1.18-.66-1.86s.29-1.33.77-1.82c.52-.54,1.22-.83,1.97-.83s1.39.27,1.9.77h.01s.01.02.01.02c.46.43,1.07.67,1.7.67v9.86h0Z"></path>`;
  
  function initializeLikeButtonFeature() {
    const styleId = 'sort-play-like-button-tooltip-style';
    if (!document.getElementById(styleId)) {
        const style = document.createElement('style');
        style.id = styleId;
        style.innerHTML = `
            .like-button-tooltip {
                background-color: #282828;
                color: #ffffff;
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 14px;
                font-family: 'SpotifyMixUI', 'CircularSp', 'Circular', 'Helvetica', 'Arial', sans-serif;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
                z-index: 1001;
                max-width: 300px;
                text-align: center;
                pointer-events: none;
                opacity: 0;
                transition: opacity 200ms ease-in-out;
            }

            .like-button-tooltip.visible {
                opacity: 1;
            }
        `;
        document.head.appendChild(style);
    }

    const visibilityStyleId = 'sort-play-like-button-visibility-style';
    if (!document.getElementById(visibilityStyleId)) {
        const style = document.createElement('style');
        style.id = visibilityStyleId;
        style.innerHTML = `
            .main-trackList-trackListRow .sort-play-like-button[aria-checked="true"],
            div[role="row"][aria-selected] .sort-play-like-button[aria-checked="true"] {
                opacity: 1 !important;
            }
        `;
        document.head.appendChild(style);
    }

    let likeButton_likedTracksIdsISRCs = new Map(); 
    let likeButton_likedTracksISRCs = new Set(likeButton_likedTracksIdsISRCs.values());
    var proxy_likeButton_likedTracksIdsISRCs;
    var likeButton_likedTracksChangeEvent = new CustomEvent('likeButton_likedTracksChange');

    async function likeButton_initiateLikedSongs() {
        if (!Spicetify.Platform?.LibraryAPI?.getTracks) {
            setTimeout(likeButton_initiateLikedSongs, 100);
            return;
        }

        let likedTracksData;
        try {
            likedTracksData = await Spicetify.Platform.LibraryAPI.getTracks({
                limit: Number.MAX_SAFE_INTEGER,
            });
        } catch (error) {
            console.error("[Sort-Play Like Button] Error fetching liked songs via LibraryAPI:", error);
            setTimeout(likeButton_initiateLikedSongs, 30000);
            return;
        }

        if (!likedTracksData || !likedTracksData.items || likedTracksData.items.length === 0) {
            setTimeout(likeButton_initiateLikedSongs, 5000);
            return;
        }

        let likedTracksIds = likedTracksData.items.map(item => item.uri.replace("spotify:track:", ""));

        let newLikedTracksIdsISRCs = new Map();
        let likedTracksIdsWithUnknownISRCs = [];

        likedTracksIds.forEach(trackId => {
            const trackIsrc = localStorage.getItem("sort-play-like-" + trackId)
            if (trackIsrc != null) {
                newLikedTracksIdsISRCs.set(trackId, trackIsrc)
            } else if (!trackId.startsWith("spotify:local:")) {
                likedTracksIdsWithUnknownISRCs.push(trackId);
            }
        });

        let promises = [];
        const processLikeInternal = async (id) => {
            const track = await fetchInternalTrackMetadata(id);
            if (track) {
                const cacheData = {
                    name: track.name,
                    album: track.album,
                    artists: track.artists,
                    duration_ms: track.duration_ms,
                    popularity: track.popularity,
                    external_ids: track.external_ids,
                    id: track.id,
                    uri: track.uri
                };
                idb.set('trackMetadata', track.id, cacheData);

                if (track.external_ids && track.external_ids.isrc) {
                    newLikedTracksIdsISRCs.set(track.id, track.external_ids.isrc);
                    localStorage.setItem("sort-play-like-" + track.id, track.external_ids.isrc);
                }
            }
        };

        if (isFallbackActive()) {
            promises = likedTracksIdsWithUnknownISRCs.map(id => processLikeInternal(id));
        } else {
            for (let i = 0; i < likedTracksIdsWithUnknownISRCs.length; i += 50) {
                let batch = likedTracksIdsWithUnknownISRCs.slice(i, i + 50);
                promises.push(
                    Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${batch.join(",")}`).then(response => {
                        if (response && response.tracks) {
                            response.tracks.forEach(track => {
                                if (track && track.external_ids && track.external_ids.isrc) {
                                    newLikedTracksIdsISRCs.set(track.id, track.external_ids.isrc);
                                    localStorage.setItem("sort-play-like-" + track.id, track.external_ids.isrc);
                                }
                            });
                        }
                    }).catch(error => {
                        if (registerWebApiFailure()) {
                            return Promise.all(batch.map(id => processLikeInternal(id)));
                        }
                    })
                );
            }
        }
        await Promise.all(promises);

        likeButton_likedTracksIdsISRCs = newLikedTracksIdsISRCs;
        likeButton_likedTracksISRCs = new Set(likeButton_likedTracksIdsISRCs.values());

        proxy_likeButton_likedTracksIdsISRCs = new Proxy(likeButton_likedTracksIdsISRCs, {
            get: function (target, property, receiver) {
                if (['set', 'delete'].includes(property) && typeof target[property] === 'function') {
                    return function (...args) {
                        const result = target[property].apply(target, args);
                        likeButton_likedTracksISRCs = new Set(likeButton_likedTracksIdsISRCs.values());
                        document.dispatchEvent(likeButton_likedTracksChangeEvent);
                        return result;
                    };
                }
                return Reflect.get(target, property, receiver);
            }
        });

        document.dispatchEvent(likeButton_likedTracksChangeEvent);
        setTimeout(likeButton_initiateLikedSongs, 30000);
    }

    const LikeButton = Spicetify.React.memo(function LikeButton({ uri, classList, size = 16, dynamicSizeSelector = null }) {
        const trackId = uri.replace("spotify:track:", "");
        const [currentSize, setCurrentSize] = Spicetify.React.useState(size);
        const [isrc, setISRC] = Spicetify.React.useState(localStorage.getItem("sort-play-like-" + trackId));
        const [isLiked, setIsLiked] = Spicetify.React.useState(likeButton_likedTracksIdsISRCs.has(trackId));
        const [hasISRCLiked, setHasISRCLiked] = Spicetify.React.useState(likeButton_likedTracksISRCs.has(isrc));
        const [isHovered, setIsHovered] = Spicetify.React.useState(false);
        const buttonRef = Spicetify.React.useRef(null);
    
        const [isTooltipVisible, setIsTooltipVisible] = Spicetify.React.useState(false);
        const tooltipTimeoutRef = Spicetify.React.useRef(null);
        const tooltipRef = Spicetify.React.useRef(null);
        const tooltipCheckIntervalRef = Spicetify.React.useRef(null);
    
        const tooltipContent = isLiked ? "Remove from Liked Songs" : hasISRCLiked ? "You've already liked another version." : "Add to Liked Songs";

        Spicetify.React.useEffect(() => {
            return () => {
                clearTimeout(tooltipTimeoutRef.current);
                clearInterval(tooltipCheckIntervalRef.current);
                const tooltipNode = tooltipRef.current;
                if (tooltipNode && tooltipNode.parentNode) {
                    tooltipNode.parentNode.removeChild(tooltipNode);
                }
            };
        }, []);

        Spicetify.React.useEffect(() => {
            if (isTooltipVisible) {
                if (buttonRef.current && tooltipRef.current) {
                    const buttonRect = buttonRef.current.getBoundingClientRect();
                    const tooltip = tooltipRef.current;
                    const tooltipRect = tooltip.getBoundingClientRect();
                    const viewportWidth = window.innerWidth;
                    const margin = 8;

                    tooltip.style.top = `${buttonRect.top - tooltipRect.height - 8}px`;
                    let idealLeft = buttonRect.left + (buttonRect.width / 2) - (tooltipRect.width / 2);
                    
                    if (idealLeft < margin) idealLeft = margin;
                    else if (idealLeft + tooltipRect.width > viewportWidth - margin) idealLeft = viewportWidth - tooltipRect.width - margin;

                    tooltip.style.left = `${idealLeft}px`;
                    
                    const timeoutId = setTimeout(() => tooltip.classList.add('visible'), 10);
                    
                    tooltipCheckIntervalRef.current = setInterval(() => {
                        if (!buttonRef.current || !document.body.contains(buttonRef.current)) {
                            setIsTooltipVisible(false);
                        }
                    }, 150);

                    return () => clearTimeout(timeoutId);
                }
            } else {
                clearInterval(tooltipCheckIntervalRef.current);
                if (tooltipRef.current) {
                    tooltipRef.current.classList.remove('visible');
                }
            }
        }, [isTooltipVisible]);
    
        Spicetify.React.useEffect(() => {
            if (!dynamicSizeSelector) return;

            const referenceElement = document.querySelector(dynamicSizeSelector);
            if (!referenceElement) return;

            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    const newSize = entry.contentRect.height || entry.contentRect.width;
                    if (newSize > 0) {
                        setCurrentSize(newSize);
                    }
                }
            });

            resizeObserver.observe(referenceElement);

            const initialSize = referenceElement.getBoundingClientRect().height;
            if (initialSize > 0) {
                setCurrentSize(initialSize);
            }

            return () => resizeObserver.disconnect();
        }, [dynamicSizeSelector]);


        Spicetify.React.useEffect(() => {
            async function initISRC() {
                try {
                    if (isrc == null && trackId) {
                        let track = null;
                        if (isFallbackActive()) {
                            track = await fetchInternalTrackMetadata(trackId);
                        } else {
                            try {
                                track = await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks/${trackId}`);
                            } catch (e) {
                                if (registerWebApiFailure()) {
                                    track = await fetchInternalTrackMetadata(trackId);
                                }
                            }
                        }

                        if (track && track.external_ids && track.external_ids.isrc) {
                            setISRC(track.external_ids.isrc);
                            localStorage.setItem("sort-play-like-" + track.id, track.external_ids.isrc);
                            setHasISRCLiked(likeButton_likedTracksISRCs.has(track.external_ids.isrc));
                        }
                    } else {
                        setHasISRCLiked(likeButton_likedTracksISRCs.has(isrc));
                    }
                } catch (error) {
                    console.error('[Sort-Play Like Button] Error fetching ISRC:', error);
                }
            };
            initISRC();
        }, [trackId]);

        Spicetify.React.useEffect(() => {
            if (isrc) {
                setHasISRCLiked(likeButton_likedTracksISRCs.has(isrc));
            }
        }, [isrc]);

        Spicetify.React.useEffect(() => {
            const handleLikedTracksChange = () => {
                setIsLiked(likeButton_likedTracksIdsISRCs.has(trackId));
                const currentISRC = localStorage.getItem("sort-play-like-" + trackId);
                if (currentISRC) {
                    setHasISRCLiked(likeButton_likedTracksISRCs.has(currentISRC));
                }
            };
            
            document.addEventListener('likeButton_likedTracksChange', handleLikedTracksChange);
            return () => {
                document.removeEventListener('likeButton_likedTracksChange', handleLikedTracksChange);
            };
        }, [trackId]);
    
        const handleClick = async function () {
            if (!Spicetify.Platform?.LibraryAPI?.add || !Spicetify.Platform?.LibraryAPI?.remove) {
                showNotification("Library API not available.", true);
                console.error("[Sort-Play Like Button] Spicetify.Platform.LibraryAPI.add/remove is not available.");
                return;
            }
            if (isLiked) {
                try {
                    await Spicetify.Platform.LibraryAPI.remove({ uris: [uri] });
                    proxy_likeButton_likedTracksIdsISRCs.delete(trackId);
                } catch (error) {
                    console.error('[Sort-Play Like Button] Error unliking track with LibraryAPI:', error);
                    showNotification("Failed to unlike song.", true);
                }
            } else {
                try {
                    await Spicetify.Platform.LibraryAPI.add({ uris: [uri] });
                    if (isrc) {
                        proxy_likeButton_likedTracksIdsISRCs.set(trackId, isrc);
                    }
                } catch (error) {
                    console.error('[Sort-Play Like Button] Error liking track with LibraryAPI:', error);
                    showNotification("Failed to like song.", true);
                }
            }
        };
    
        const finalClassName = `${classList} sort-play-like-button`;

        return Spicetify.React.createElement(Spicetify.React.Fragment, null,
            Spicetify.React.createElement("button", {
                ref: buttonRef,
                className: finalClassName,
                title: "",
                "aria-label": tooltipContent,
                "aria-checked": isLiked || hasISRCLiked,
                onClick: handleClick,
                onMouseEnter: () => {
                    setIsHovered(true);
                    clearTimeout(tooltipTimeoutRef.current);
                    tooltipTimeoutRef.current = setTimeout(() => {
                        setIsTooltipVisible(true);
                    }, 250);
                },
                onMouseLeave: () => {
                    setIsHovered(false);
                    clearTimeout(tooltipTimeoutRef.current);
                    setIsTooltipVisible(false);
                },
                style: { marginRight: "12px" }
            }, Spicetify.React.createElement("span", {
                className: "Wrapper-sm-only Wrapper-small-only",
                style: {
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                }
            }, Spicetify.React.createElement("svg", {
                role: "img", height: currentSize, width: currentSize, viewBox: "0 0 16 16",
                className: (isLiked || hasISRCLiked) ? "Svg-sc-ytk21e-0 Svg-img-icon-small-textBrightAccent" : "Svg-sc-ytk21e-0 Svg-img-icon-small",
                style: {
                    fill: (isLiked || hasISRCLiked) ? "var(--text-bright-accent)" : "var(--text-subdued)",
                    filter: isHovered ? 'brightness(1.1)' : 'none',
                    transition: 'filter 0.1s ease-in-out'
                },
                dangerouslySetInnerHTML: {
                    __html: isLiked
                        ? LIKE_BUTTON_ICON_LIKED
                        : (hasISRCLiked
                            ? LIKE_BUTTON_ICON_ISRC_LIKED
                            : LIKE_BUTTON_ICON_NOT_LIKED)
                }
            }))),
            isTooltipVisible && Spicetify.ReactDOM.createPortal(
                Spicetify.React.createElement("div", {
                    ref: tooltipRef,
                    className: "like-button-tooltip",
                    style: { position: 'fixed' }
                }, tooltipContent),
                document.body
            )
        );
    });
    
    async function mountLikeButton(isDebounced = false) {
        if (!isDebounced) {
            clearTimeout(mountLikeButton_debounceTimer);
            mountLikeButton_debounceTimer = setTimeout(() => {
                mountLikeButton(true);
            }, 300);
            return;
        }
    
        if (mountLikeButton_isRunning) {
            return;
        }
        mountLikeButton_isRunning = true;
    
        const MAX_RETRIES = 10;
        let retryDelay = 250;
    
        try {
            const uri = Spicetify.Player.data?.item?.uri || "";
            const nowPlayingWidget = document.querySelector(".main-nowPlayingWidget-nowPlaying");
            let container = nowPlayingWidget ? nowPlayingWidget.querySelector(".likeControl-wrapper") : null;

            if (!uri || !uri.startsWith("spotify:track:")) {
                if (container) {
                    Spicetify.ReactDOM.unmountComponentAtNode(container);
                }
                mountLikeButton_isRunning = false;
                return;
            }

            for (let i = 0; i < MAX_RETRIES; i++) {
                if (!nowPlayingWidget) {
                    console.warn(`[Sort-Play Like Button] Retry ${i + 1}: Now playing widget not found`);
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    retryDelay = Math.min(retryDelay * 2, 3000);
                    continue;
                }
    
                const nativeLikeButton = nowPlayingWidget.querySelector('button[aria-label*="Liked Songs"], button[aria-label*="Add to playlist"]');
                if (!nativeLikeButton || !nativeLikeButton.parentNode) {
                    console.warn(`[Sort-Play Like Button] Retry ${i + 1}: Native like button not found or has no parent`);
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    retryDelay = Math.min(retryDelay * 2, 3000);
                    continue;
                }
                
                container = nowPlayingWidget.querySelector(".likeControl-wrapper");
                
                if (container && container.dataset.renderedUri === uri && container.firstChild) {
                    mountLikeButton_failedAttempts = 0;
                    mountLikeButton_isRunning = false;
                    return;
                }
                
                if (container && container.dataset.renderedUri !== uri) {
                }
                
                if (!container) {
                    container = document.createElement("div");
                    container.className = "likeControl-wrapper";
                    
                    const currentNativeLikeButton = nowPlayingWidget.querySelector('button[aria-label*="Liked Songs"], button[aria-label*="Add to playlist"]');
                    if (!currentNativeLikeButton || !currentNativeLikeButton.parentNode) {
                        console.warn(`[Sort-Play Like Button] Retry ${i + 1}: Native button parent disappeared before insertion`);
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                        retryDelay = Math.min(retryDelay * 2, 3000);
                        continue;
                    }
                    
                    try {
                        currentNativeLikeButton.parentNode.insertBefore(container, currentNativeLikeButton.nextSibling);
                    } catch (error) {
                        console.error(`[Sort-Play Like Button] Retry ${i + 1}: Failed to insert like button wrapper`, error);
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                        retryDelay = Math.min(retryDelay * 2, 3000);
                        continue;
                    }
                }
                
                try {
                    const currentNativeLikeButton = nowPlayingWidget.querySelector('button[aria-label*="Liked Songs"], button[aria-label*="Add to playlist"]');
                    if (!currentNativeLikeButton) {
                        console.warn(`[Sort-Play Like Button] Retry ${i + 1}: Native button disappeared before render`);
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                        retryDelay = Math.min(retryDelay * 2, 3000);
                        continue;
                    }
                    
                    Spicetify.ReactDOM.render(
                        Spicetify.React.createElement(LikeButton, { 
                            uri: uri, 
                            key: uri, 
                            classList: currentNativeLikeButton.className 
                        }), 
                        container
                    );
                    
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    if (!container.firstChild) {
                        console.error(`[Sort-Play Like Button] Retry ${i + 1}: React render completed but no child element found`);
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                        retryDelay = Math.min(retryDelay * 2, 3000);
                        continue;
                    }
                    
                    container.dataset.renderedUri = uri;
                    container.firstChild.style.marginRight = "0px";
                    
                    mountLikeButton_failedAttempts = 0;
                    mountLikeButton_isRunning = false;
                    return;
                    
                } catch (error) {
                    console.error(`[Sort-Play Like Button] Retry ${i + 1}: React render error`, error);
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    retryDelay = Math.min(retryDelay * 2, 3000);
                    continue;
                }
            }
    
            mountLikeButton_failedAttempts++;
            console.error(`[Sort-Play Like Button] Failed to mount like button after ${MAX_RETRIES} retries. Failed attempts: ${mountLikeButton_failedAttempts}`);
            
            if (mountLikeButton_failedAttempts < 3) {
                console.log(`[Sort-Play Like Button] Scheduling retry in 2 seconds...`);
                setTimeout(() => mountLikeButton(true), 2000);
            }
        } finally {
            mountLikeButton_isRunning = false;
        }
    }

    async function mountLikeButtonNowPlayingView() {
        const MAX_RETRIES = 15;
        let retryDelay = 250;
    
        const uri = Spicetify.Player.data?.item?.uri || "";
        
        if (!uri || !uri.startsWith("spotify:track:")) {
            const nowPlayingView = document.querySelector(".main-nowPlayingView-contextItemInfo");
            const container = nowPlayingView ? nowPlayingView.querySelector(".likeControl-wrapper-npv") : null;
            if (container) {
                Spicetify.ReactDOM.unmountComponentAtNode(container);
            }
            return;
        }
    
        for (let i = 0; i < MAX_RETRIES; i++) {
            const nowPlayingView = document.querySelector(".main-nowPlayingView-contextItemInfo");
            
            if (!nowPlayingView) {
                await new Promise(resolve => setTimeout(resolve, retryDelay));
                retryDelay = Math.min(retryDelay * 2, 3000);
                continue;
            }
    
            const addToPlaylistButtonWrapper = nowPlayingView.querySelector('.CAVVGuPYPRDhrbGiFOc1');
            if (!addToPlaylistButtonWrapper || !addToPlaylistButtonWrapper.parentElement) {
                console.warn(`[Sort-Play Like Button NPV] Retry ${i + 1}: Add to playlist button wrapper not found or has no parent`);
                await new Promise(resolve => setTimeout(resolve, retryDelay));
                retryDelay = Math.min(retryDelay * 2, 3000);
                continue;
            }
    
            const templateButton = nowPlayingView.querySelector('button[aria-label="Copy link to Song"]') || nowPlayingView.querySelector('.CAVVGuPYPRDhrbGiFOc1 button');
            if (!templateButton) {
                console.warn(`[Sort-Play Like Button NPV] Retry ${i + 1}: Template button not found`);
                await new Promise(resolve => setTimeout(resolve, retryDelay));
                retryDelay = Math.min(retryDelay * 2, 3000);
                continue;
            }
    
            let container = nowPlayingView.querySelector(".likeControl-wrapper-npv");
            if (!container) {
                container = document.createElement("div");
                container.className = "likeControl-wrapper-npv";
                container.style.display = "contents";
                try {
                    addToPlaylistButtonWrapper.parentElement.insertBefore(container, addToPlaylistButtonWrapper);
                } catch (error) {
                    console.error(`[Sort-Play Like Button NPV] Retry ${i + 1}: Failed to insert like button wrapper`, error);
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    retryDelay = Math.min(retryDelay * 2, 3000);
                    continue;
                }
            }
    
            if (container.dataset.renderedUri === uri && container.firstChild) {
                return;
            }
    
            const dynamicSizeSelector = '.CAVVGuPYPRDhrbGiFOc1 button svg';
    
            try {
                Spicetify.ReactDOM.render(
                    Spicetify.React.createElement(LikeButton, {
                        uri: uri,
                        key: uri,
                        classList: templateButton.className,
                        size: 21,
                        dynamicSizeSelector: dynamicSizeSelector
                    }),
                    container
                );
                
                await new Promise(resolve => setTimeout(resolve, 50));
                
                if (!container.firstChild) {
                    console.error(`[Sort-Play Like Button NPV] Retry ${i + 1}: React render completed but no child element found`);
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    retryDelay = Math.min(retryDelay * 2, 3000);
                    continue;
                }
                
                container.dataset.renderedUri = uri;
                container.firstChild.style.marginRight = "0px";
                container.firstChild.style.marginLeft = "12px";
                
                return;
                
            } catch (error) {
                console.error(`[Sort-Play Like Button NPV] Retry ${i + 1}: React render error`, error);
                await new Promise(resolve => setTimeout(resolve, retryDelay));
                retryDelay = Math.min(retryDelay * 2, 3000);
                continue;
            }
        }
    }
    
    (async function initialize() {
        await likeButton_initiateLikedSongs();
    
        while (!Spicetify?.Player?.data?.item || !document.querySelector(".main-nowPlayingWidget-nowPlaying")) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        await new Promise(resolve => setTimeout(resolve, 500));
    
        await mountLikeButton();
        await mountLikeButtonNowPlayingView();
    
        Spicetify.Player.addEventListener("songchange", () => {
            mountLikeButton();
            mountLikeButtonNowPlayingView();
        });
    })();

    function likeButton_findVal(obj, key, maxDepth = 15, visited = new Set()) {
        if (!obj || typeof obj !== 'object' || maxDepth <= 0 || visited.has(obj)) return undefined;
        visited.add(obj);
        if (obj.hasOwnProperty(key)) return obj[key];
        for (const k in obj) {
            if (obj.hasOwnProperty(k)) {
                const result = likeButton_findVal(obj[k], key, maxDepth - 1, visited);
                if (result !== undefined) return result;
            }
        }
        return undefined;
    }

    const likeButton_addLikeButtonToRow = (row) => {
        if (row.classList.contains("sort-play-like-button-injected")) return;
        const actionButtonsContainer = Array.from(row.querySelectorAll('div[role="gridcell"]')).pop();
        if (!actionButtonsContainer) return;
        if (actionButtonsContainer.querySelector(".likeControl-wrapper")) {
            row.classList.add("sort-play-like-button-injected");
            return;
        }
        const entryPoint = actionButtonsContainer.querySelector("button:not(:last-of-type)");
        if (!entryPoint) return;
        const reactPropsKey = Object.keys(row).find(key => key.startsWith("__reactProps$"));
        if (!reactPropsKey) return;
        const uri = likeButton_findVal(row[reactPropsKey], "uri");
        if (!uri || !uri.startsWith("spotify:track:")) return;
        row.classList.add("sort-play-like-button-injected");
        const likeButtonWrapper = document.createElement("div");
        likeButtonWrapper.className = "likeControl-wrapper";
        likeButtonWrapper.style.display = "contents";
        const likeButtonElement = entryPoint.parentElement.insertBefore(likeButtonWrapper, entryPoint);
        Spicetify.ReactDOM.render(Spicetify.React.createElement(LikeButton, { uri, classList: entryPoint.className }), likeButtonElement);
    };

    const likeButton_processTracklist = (mainView) => {
        const tracklist = mainView.querySelector(".main-trackList-indexable, div[data-testid='track-list'], div[aria-label='Songs search results']");
        if (tracklist) {
            tracklist.querySelectorAll('.main-trackList-trackListRow, div[role="row"][aria-selected]').forEach(likeButton_addLikeButtonToRow);
        }
    };

    likeButton_connectObserver = () => {
        if (likeButton_observerInitialized) {
            return;
        }
                
        if (likeButton_tracklistObserver) {
            likeButton_tracklistObserver.disconnect();
        }
        const mainView = document.querySelector("main");
        if (!mainView) {
            setTimeout(likeButton_connectObserver, 250);
            return;
        }
    
        likeButton_processTracklist(mainView);
        mountLikeButton();
        mountLikeButtonNowPlayingView();
    
        likeButton_tracklistObserver = new MutationObserver((mutations) => {
            if (document.querySelector(".main-nowPlayingWidget-nowPlaying") && !document.querySelector(".likeControl-wrapper")) {
                mountLikeButton();
            }
            
            const nowPlayingView = document.querySelector(".main-nowPlayingView-contextItemInfo");
            if (nowPlayingView) {
                mountLikeButtonNowPlayingView();
            }
    
            for (const mutation of mutations) {
                if (mutation.target.closest && mutation.target.closest('.likeControl-wrapper-npv')) {
                    continue;
                }
                
                for (const node of mutation.addedNodes) {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        if (node.classList && node.classList.contains('likeControl-wrapper-npv')) {
                            continue;
                        }
                        if (node.matches('.main-trackList-trackListRow, div[role="row"][aria-selected]')) {
                            likeButton_addLikeButtonToRow(node);
                        } else {
                            node.querySelectorAll('.main-trackList-trackListRow, div[role="row"][aria-selected]').forEach(likeButton_addLikeButtonToRow);
                        }
                    }
                }
            }
        });
    
        likeButton_tracklistObserver.observe(mainView, { childList: true, subtree: true });
        likeButton_observerInitialized = true;
      };
  }

  function onPageChange() {
    if (tracklistObserver) tracklistObserver.disconnect();
    if (albumTracklistObserver) albumTracklistObserver.disconnect();
    if (artistTracklistObserver) artistTracklistObserver.disconnect();
    
    insertButton();
    updateArtistPageGenres(); 
    const currentUri = getCurrentUri();
    const path = Spicetify.Platform.History.location?.pathname;
    const isSearchPage = path && path.startsWith('/search');

    if (!currentUri && !isSearchPage) {
        return;
    }

    likeButton_connectObserver();

    if (currentUri) {
        if (URI.isPlaylistV1OrV2(currentUri) || isLikedSongsPage(currentUri)) {
            initializeTracklistObserver();
        } else if (URI.isAlbum(currentUri)) {
            initializeAlbumTracklistObserver();
        } else if (URI.isArtist(currentUri)) {
            initializeArtistTracklistObserver();
        }
    }
  }

  const mainPageObserver = new MutationObserver(onPageChange);

  mainPageObserver.observe(document.body, {
    childList: true,
    subtree: true,
  });

  Spicetify.Platform.History.listen(onPageChange);

  const themeObserver = new MutationObserver(() => {
    requestAnimationFrame(() => {
      applyCurrentThemeColors();
    });
  });
  
  themeObserver.observe(document.body, {
    attributes: true,
    attributeFilter: ['class'],
  });

  const startupInterval = setInterval(() => {
    if (Spicetify.Player?.data) {
      clearInterval(startupInterval);
      applyCurrentThemeColors();
    }
  }, 100);

  await idb.init();
  await idb.clear('personalScrobbles');
  await migrateJobHistoryToIdb();
  loadSettings();
  fetchUserMarket();
  cleanupLegacyGenreCache();

  if (showLikeButton) {
    initializeLikeButtonFeature();
  }
  
  startScheduler();
  initializeSongChangeWatcher();
  
  Spicetify.Player.addEventListener("songchange", async () => {
      const p1 = displayNowPlayingData();
      const p2 = displayGenreTags();
      
      await Promise.allSettled([p1, p2]);
      
      prefetchNextTrackData();
  });

  displayNowPlayingData();
  displayGenreTags();
  prefetchNextTrackData();
  console.log(`Sort-Play loaded`);
  onPageChange();
  }

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = main;
  } else {
    await main();
  }
})();
